#+TODO: TODO PLAN CODE TEST | WONTFIX DONE

Gradu: duunit
* Koodi
** generator
*** TODO java-versiot / analogiset mittaukset loppuun
**** TODO NIO complete read write
*** TEST check-interrupted-interval ja max-repetitions, oikeat arvot
    - ok: maxreps 100, bmparameter 8 * 8
      - mock command line: vieläkin wait for concurrent
*** TEST variations on array traversal, read + write
*** TEST c>c hitaampi kuin j>j (johtunee interrupt-checkistä) ??
*** TODO varmista että kaikissa on side effect (java)
    varmista overhead-tsekkiin vertaamalla
    minimaalinen "summaava" tallennus ?
    tai yksinkertainen "tsekkaa onko null / 0 vai ei", säädä result-muuttuja
    - otettu käyttöön array -iteraatioissa, muihinkin ?
*** TODO checkaa const-asiat (gcc warning)
*** TODO JNI error checking! (käy koodi läpi vielä kerran)
*** TODO lisää eri kutsutyypit (virtual, nonvirtual) benchmarkkeihin?
*** TODO testaa call-variants (ellipsis, array, va_args)
*** TODO poista turhat log-viestit
*** TODO sopivassa vaiheessa poista interrupt check kokonaan, ehkä ui-päivityskin
    Ei muuten voi poistaa koska linux perf tool.
    Pitäisi refaktoroida omiksi benchmarkeiksi?
    (Generoida 2 versiota?)
*** WONTFIX refactor tempating to oo style
** nativebenchmark
*** param
*** runner
**** TEST thread priority ? 
**** TODO default != 0 != the first iterator value ...
**** TODO shuffle takaisin päälle
**** TODO lisää ja arvioi oikea perf event spesifikaatio
**** WONTFIX kallsyms pitää tallentaa perf-pakettiin
     System.map sisältää samat.
**** TODO oprofile (?)
**** TODO benchmarkrunner: yhdistä eri size-variaatiota vaativat bm:t (?)
**** TODO erottele android-spesifi osa jni-benchmarkeista
***** TODO logging
***** TODO sdcard path
***** TODO system clock
*** native
**** TODO c-koodissa: mikä on check interrupted-overheadi, korvaa muuttujalla?
** analyzer
*** TODO mieti tarkemmin dynamic-non-dynamic keskinäinen vertailu
*** TODO kaikki custom-benchmarkit mukaan
*** TODO filtteröi representative
*** TODO tsekkaa automaattisesti datasta columnien määrä?
*** TODO tulosta jokaiseen pdf:ään id, jolla löytää metatiedot
*** TODO metatiedot erilliseen tekstitiedostoon
*** TODO any-logiikka ei toimi (0-arvoilla, reference types)
*** TODO mittausten tilastollinen tulkinta
      (truncated mean? (THIS >> or assume lower limit...))
**** TODO >> mittaa vasteaikojen tilastollinen jakauma > mallinna

* Tarkista / huomioi
** TODO huomaa, että getfieldin tyypit yms. voisi parametrisoida
** TODO gof-book: onko proxy oikea termi peer classille?
** TODO androidin jni-toteutus ei käytä funktiotauluja?
** TODO register natives?
   The RegisterNatives function is useful for a number of purposes:
   - It is sometimes more convenient and *more efficient* to register
     a large number of native method implementations eagerly, as
     opposed to letting the virtual machine link these entries lazily.
   - You may call RegisterNatives multiple times on a method, allowing the
   native method implementation to be updated at runtime.
   - RegisterNatives is particularly useful when a native application embeds a
   virtual machine implementation and needs to link with a native
   method implementation defined in the native application. The
   virtual machine would not be able to find this native method
   implementation automatically because it only searches in native
   libraries, not the application itself.
* Korjaa
** TODO perustele miksei lisätty muut kuin jnienv-funktiot testiin
** TODO frameworks/native/libs/utils/Timers.cpp
*** rivi 35 uptimemillis toteutus, ei aina käytä gettimeofdayta



* Benchmarks
** DONE refactoring: metadatacontainer -> map
* JNI-funktiot, use caset, kilpakumppanit
** MUST
*** access fields vs calling methods
**** erottele: find id , call
**** variaatiot: static, nonvirtual (nonvirtual: tarvitsee perintäpuun?
*** string, array, nio, variaatiot !!
*** löytämismetodit, reflektionomaiset
**** findclass, getobjectclass, getmethodid, getfieldid
**** isinstanceof, issameobject
*** viitteidenhallinta
**** new + delete : global, local, weak global
**** new local, ensurecapacity vs push/pop localframe
** MAYBE
*** poikkeukset:
**** hallinta java -> c
***** check / occurred / clear
**** heittäminen c -> java
***** throw, throw new
*** reflektio:
    jos käsitellään niin pitäisi verrata getmethodid vs
    javan reflektio-eroja...
*** threadit
**** monitorenter
** NOT
**** getsuperclass, isassignablefrom
**** defineclass, fatalerror, registernatives
