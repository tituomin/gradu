#+TODO: TODO PLAN CODE TEST | WONTFIX DONE

Gradu: duunit
* Koodi
** generator
*** TODO j2jglobalweakreference aiheuttaa gc:tä...
*** TODO java-versiot / analogiset mittaukset loppuun
**** TODO NIO complete read write
*** PLAN potentiaalisesti puuttuvat benchmarkit
**** DONE measuring-overhead: kaikki variaatiot ! (merkkaa benchmarkkeihin loop-variaatio)
**** JNI-vastinparit
***** TEST J>J puuttuu (non-dynamic)
****** kaikki paitsi
       - writeobjectarrayelement
       - getobjectclass
       - accessdirectbuffer
       - weakglobalref
       - findclass
****** newstringutf 0:ssa?
****** createobjectref minimissä?
*** TEST check-interrupted-interval ja max-repetitions, oikeat arvot
    - ok: maxreps 100, bmparameter 8 * 8
      - mock command line: vieläkin wait for concurrent
*** TEST variations on array traversal, read + write
*** WONTFIX c>c hitaampi kuin j>j (johtunee interrupt-checkistä) ??
*** TODO varmista että kaikissa on side effect (java)
    varmista overhead-tsekkiin vertaamalla
    minimaalinen "summaava" tallennus ?
    tai yksinkertainen "tsekkaa onko null / 0 vai ei", säädä result-muuttuja
    - otettu käyttöön array -iteraatioissa, muihinkin ?
*** TODO checkaa const-asiat (gcc warning)
*** TODO JNI error checking! (käy koodi läpi vielä kerran)
*** TODO lisää eri kutsutyypit (virtual, nonvirtual) benchmarkkeihin?
*** TODO testaa call-variants (ellipsis, array, va_args)
*** TODO poista turhat log-viestit
*** TODO sopivassa vaiheessa poista interrupt check kokonaan, ehkä ui-päivityskin
    Ei muuten voi poistaa koska linux perf tool.
    Pitäisi refaktoroida omiksi benchmarkeiksi?
    (Generoida 2 versiota?)
** nativebenchmark
*** TODO tsekkaa vielä kerran millis/micros/ym. ..
    android_os_SystemClock.cpp
    micros käyttää gettimeofdayta,
    millis käyttää (parempaa?) clock_gettime(MONOTONIC):ia
*** param
*** runner
**** TEST thread priority ? 
**** TODO default != 0 != the first iterator value ...
**** TEST shuffle takaisin päälle
**** TODO lisää ja arvioi oikea perf event spesifikaatio
**** TODO oprofile (?)
**** TODO warmup: tulosten stabiloituminen?
**** TODO benchmarkrunner: yhdistä eri size-variaatiota vaativat bm:t (?)
**** TODO erottele android-spesifi osa jni-benchmarkeista
***** TODO logging
***** TODO sdcard path
***** TODO system clock
*** native
**** TODO c-koodissa: mikä on check interrupted-overheadi, korvaa muuttujalla?
** analyzer
*** DONE kaikki custom-benchmarkit mukaan
*** DONE filtteröi representative
*** DONE akselien labelit
*** DONE tulosta jokaiseen pdf:ään id, jolla löytää metatiedot
**** DONE metatiedot erilliseen tekstitiedostoon
*** TODO mittausten tilastollinen tulkinta
      (truncated mean? (THIS >> or assume lower limit...))
**** TODO >> mittaa vasteaikojen tilastollinen jakauma > mallinna
*** TODO overhead-normalisointi
*** TODO multiplication-skaalaus
*** TODO any-logiikka ei toimi (0-arvoilla, reference types)
*** TODO mieti tarkemmin dynamic-non-dynamic keskinäinen vertailu
*** DONE tsekkaa automaattisesti datasta columnien määrä?

* Tarkista / huomioi
** TODO huomaa, että getfieldin tyypit yms. voisi parametrisoida
** TODO gof-book: onko proxy oikea termi peer classille?
** TODO androidin jni-toteutus ei käytä funktiotauluja?
** TODO register natives?
   The RegisterNatives function is useful for a number of purposes:
   - It is sometimes more convenient and *more efficient* to register
     a large number of native method implementations eagerly, as
     opposed to letting the virtual machine link these entries lazily.
   - You may call RegisterNatives multiple times on a method, allowing the
   native method implementation to be updated at runtime.
   - RegisterNatives is particularly useful when a native application embeds a
   virtual machine implementation and needs to link with a native
   method implementation defined in the native application. The
   virtual machine would not be able to find this native method
   implementation automatically because it only searches in native
   libraries, not the application itself.
* Korjaa
** TODO perustele miksei lisätty muut kuin jnienv-funktiot testiin
** TODO frameworks/native/libs/utils/Timers.cpp
*** rivi 35 uptimemillis toteutus, ei aina käytä gettimeofdayta



* Benchmarks
** DONE refactoring: metadatacontainer -> map
* JNI-funktiot, use caset, kilpakumppanit
** MUST
*** access fields vs calling methods
**** erottele: find id , call
**** variaatiot: static, nonvirtual (nonvirtual: tarvitsee perintäpuun?
*** string, array, nio, variaatiot !!
*** löytämismetodit, reflektionomaiset
**** findclass, getobjectclass, getmethodid, getfieldid
**** isinstanceof, issameobject
*** viitteidenhallinta
**** new + delete : global, local, weak global
**** new local, ensurecapacity vs push/pop localframe
** MAYBE
*** poikkeukset:
**** hallinta java -> c
***** check / occurred / clear
**** heittäminen c -> java
***** throw, throw new
*** reflektio:
    jos käsitellään niin pitäisi verrata getmethodid vs
    javan reflektio-eroja...
*** threadit
**** monitorenter
** NOT
**** getsuperclass, isassignablefrom
**** defineclass, fatalerror, registernatives
