
Gradu: duunit
* Benchmarks
** GC_FOR_ALLOC -- muisti ilmeisesti loppuu?
   korjattu: map vie älyttömästi muistia
** for loopista pois?
int i = reps + 1;
while (--i != 0) ...
** varmista että kaikissa on side effect

** TODO perf init: cat >kptr_restrict, paranoid etc. (run as root?) + cpu scaling
** TODO poista stdio c-koodista (android string logging formatting)
** TODO JNI error checking! (käy koodi läpi vielä kerran)
** TODO mittausten tilastollinen tulkinta
     (truncated mean? (THIS >> or assume lower limit...))
**** TODO >> mittaa vasteaikojen tilastollinen jakauma > mallinna
**** git rev-parse HEAD
     lisää custom ruleseihin ()
** DONE UI mittausten keskeyttäminen -> ei tarvitse määrittää rounds..
** DONE zip
** DONE useampi mittauskierros
*** DONE warmup round
*** DONE UI
*** DONE ne kierrokset
*** DONE mittausluettelo
*** DONE build: include git tag as resource
** DONE perf
**** TODO analyze part -> latex tables etc.
**** TODO inspect build ids
***** eu-readelf -n (elfutils) (should be done in analyze part...)
**** TODO huom! löydä oikea kerneli, systematisoi
** TODO oprofile (?)
** TODO dynamic parameter variations
** TODO lisätestit
*** TODO jni functions
*** TODO testaa call-variants (ellipsis, array, va_args)
*** DONE modifiers
** TODO funktioiden paluuarvojen tallennus? (ehkä ei)
** TODO java: final local variables?
    android designing for performance: Without a JIT, direct field
 access is about 3x faster than invoking a trivial getter. With the
 JIT (where direct field access is as cheap as accessing a local),
 direct field access is about 7x faster than invoking a trivial
 getter. This is true in Froyo, but will improve in the future when
 the JIT inlines getter methods. !!!! yes but used only once
** TODO lisää muut kuin jnienv-funktiot testiin? (tai perustele miksei)
** TODO turn off screen? (manually?) (can be done during warmup)
** TODO erottele android-spesifi osa jni-benchmarkeista
** DONE refactoring: metadatacontainer -> map
** DONE no call arguments !!!
** DONE siirrä koodi eri repoon kuin gradu
** DONE korjaa build dependencies
* JNI-funktiot, use caset, kilpakumppanit
** MUST
*** access fields vs calling methods
**** erottele: find id , call
**** variaatiot: static, nonvirtual (nonvirtual: tarvitsee perintäpuun?
*** string, array, nio, variaatiot !!
*** löytämismetodit, reflektionomaiset
**** findclass, getobjectclass, getmethodid, getfieldid
**** isinstanceof, issameobject
*** viitteidenhallinta
**** new + delete : global, local, weak global
**** new local, ensurecapacity vs push/pop localframe
** MAYBE
*** poikkeukset:
**** hallinta java -> c
***** check / occurred / clear
**** heittäminen c -> java
***** throw, throw new
*** reflektio:
    jos käsitellään niin pitäisi verrata getmethodid vs
    javan reflektio-eroja...
*** threadit
**** monitorenter
** NOT
**** getsuperclass, isassignablefrom
**** defineclass, fatalerror, registernatives
* Tarkista
** TODO gof-book: onko proxy oikea termi peer classille?
** TODO androidin jni-toteutus ei käytä funktiotauluja?
** TODO register natives?
   The RegisterNatives function is useful for a number of purposes:
   - It is sometimes more convenient and *more efficient* to register
     a large number of native method implementations eagerly, as
     opposed to letting the virtual machine link these entries lazily.
   - You may call RegisterNatives multiple times on a method, allowing the
   native method implementation to be updated at runtime.
   - RegisterNatives is particularly useful when a native application embeds a
   virtual machine implementation and needs to link with a native
   method implementation defined in the native application. The
   virtual machine would not be able to find this native method
   implementation automatically because it only searches in native
   libraries, not the application itself.

* Korjaa
** TODO frameworks/native/libs/utils/Timers.cpp
*** rivi 35 uptimemillis toteutus, ei aina käytä gettimeofdayta
* DONE Peruskutsutestit

| java | c    | suunta | java | NOTES                                                                    |
|------+------+--------+------+--------------------------------------------------------------------------|
| :.   | :.   | ->     | :.   | C2JBenchmarkNNNN -> t_caller_java(classname) -> javacounterparts         |
| :.   | :.:: | <<     | ---- | C2CBenchmarkNNNN -> t_caller_native(methodname)                          |
| ---- | ::   | <-     | ::   | J2CBenchmarkNNNN -> c_nativemethod.t                                     |
| ---- | ---- | >>     | :.   | J2JBenchmarkNNNN -> javacounterparts                                     |
|------+------+--------+------+--------------------------------------------------------------------------|

Native2JavaBenchmark:
native run method, method name derived from Native2JavaBenchmark_X_run
 - callee name derived from benchmark number NNNN

Native2NativeBenchmark:
native run method, method name derived from Native2NativeBenchmark_X_run
 - callee name derived from benchmark number NNNN

Benchmark:
native counterpart, method name derived from Benchmark_nativemethod

Java2JavaBenchmark:
java run method, callee name derived from benchmark number NNNN
