
Gradu: duunit
* Koodi
** generator
*** TODO persistentvalue first local then save to field
*** TODO check-interrupted-interval ja max-repetitions, oikeat arvot
*** TODO java-versiot / analogiset mittaukset loppuun
*** TODO variations on array traversal, read + write
*** TODO varmista että kaikissa on side effect (java)
    varmista overhead-tsekkiin vertaamalla
    minimaalinen "summaava" tallennus ?
    tai yksinkertainen "tsekkaa onko null / 0 vai ei", säädä result-muuttuja
    otettu käyttöön array -iteraatioissa, muihinkin ?
*** TODO sopivassa vaiheessa, sopivilla perusteluilla vähennä tyyppien määrää benchmarkeissa
*** TODO jni functions
**** TODO c>c hitaampi kuin j>j (johtunee interrupt-checkistä) ??
**** TODO 10^6 lienee minimi jolla j>j saadaan järkeväksi ?
**** DONE tarkempi säätö, tarvitaanko local frame push / pop
     !! toisaalta vaikuttaa testien yhteismitallisuuteen !!
**** DONE taulukot
**** DONE taulukot par
**** DONE taulukot test
**** DONE vary-size -> välitä java runnerille
**** DONE perusinfra (generator)
*** TODO checkaa const-asiat (gcc warning)
*** TODO JNI error checking! (käy koodi läpi vielä kerran)
*** TODO lisää eri kutsutyypit (virtual, nonvirtual) benchmarkkeihin?
*** TODO testaa call-variants (ellipsis, array, va_args)
*** TODO sopivassa vaiheessa poista interrupt check kokonaan, ehkä ui-päivityskin
    Ei muuten voi poistaa koska linux perf tool.
    Pitäisi refaktoroida omiksi benchmarkeiksi?
    (Generoida 2 versiota?)
*** DONE wontfix java: params -> fields? local variables?
    android designing for performance: Without a JIT, direct field
    access is about 3x faster than invoking a trivial getter. With the
    JIT (where direct field access is as cheap as accessing a local),
    direct field access is about 7x faster than invoking a trivial
    getter. This is true in Froyo, but will improve in the future when
    the JIT inlines getter methods. !!!!
     - yes but used only once
*** DONE (?) poista stdio c-koodista (android string logging formatting + null) ?
*** DONE java custom infra
*** DONE Benchmark = abstract class, not interface
*** DONE mittausoverheadin mittaus: reversible composable bijection
** nativebenchmark
*** param
**** DONE BenchmarkParam: set custom params (context)
***** native code
***** java code
**** DONE init a \0 terminated string
*** runner
**** TODO thread priority ? 
**** TODO default != 0 != the first iterator value ...
**** TODO shuffle takaisin päälle
**** TODO lisää ja arvioi oikea perf event spesifikaatio
**** TODO kallsyms pitää tallentaa perf-pakettiin
**** TODO oprofile (?)
**** TODO benchmarkrunner: yhdistä eri size-variaatiota vaativat bm:t (?)
**** TODO erottele android-spesifi osa jni-benchmarkeista
***** TODO logging
***** TODO sdcard path
***** TODO system clock
**** DONE deletoi perf-data? (tehty?)
*** native
**** TODO c-koodissa: mikä on check interrupted-overheadi, korvaa muuttujalla?
     tai poista koko interrupt-homma  (>kill process in terminal)
** analyzer
*** TODO tsekkaa automaattisesti datasta columnien määrä?
*** TODO tulosta jokaiseen pdf:ään id, jolla löytää metatiedot
*** TODO metatiedot erilliseen tekstitiedostoon
*** TODO any-logiikka ei toimi (0-arvoilla, reference types)
*** TODO mittausten tilastollinen tulkinta
      (truncated mean? (THIS >> or assume lower limit...))
**** TODO >> mittaa vasteaikojen tilastollinen jakauma > mallinna
*** DONE git rev-parse HEAD
    lisää custom ruleseihin ()
*** DONE primitiivityypit puuttuu ploteista (return_type)
*** DONE uudet jni-benchmarkit
*** DONE directions labelit menee väärin

* Tarkista / huomioi
** TODO huomaa, että getfieldin tyypit yms. voisi parametrisoida
** TODO gof-book: onko proxy oikea termi peer classille?
** TODO androidin jni-toteutus ei käytä funktiotauluja?
** TODO register natives?
   The RegisterNatives function is useful for a number of purposes:
   - It is sometimes more convenient and *more efficient* to register
     a large number of native method implementations eagerly, as
     opposed to letting the virtual machine link these entries lazily.
   - You may call RegisterNatives multiple times on a method, allowing the
   native method implementation to be updated at runtime.
   - RegisterNatives is particularly useful when a native application embeds a
   virtual machine implementation and needs to link with a native
   method implementation defined in the native application. The
   virtual machine would not be able to find this native method
   implementation automatically because it only searches in native
   libraries, not the application itself.
* Korjaa
** TODO perustele miksei lisätty muut kuin jnienv-funktiot testiin
** TODO frameworks/native/libs/utils/Timers.cpp
*** rivi 35 uptimemillis toteutus, ei aina käytä gettimeofdayta



* Benchmarks
** DONE erikokoiset Object-instanssit
** DONE for loopista pois?
   int i = reps + 1;
   while (--i != 0) ...
** DONE turn off screen? (manually?) (can be done during warmup)
** DONE GC_FOR_ALLOC -- muisti ilmeisesti loppuu?
   korjattu: map vie älyttömästi muistia
** DONE perf init: cat >kptr_restrict, paranoid etc. (run as root?) + cpu scaling
** DONE UI mittausten keskeyttäminen -> ei tarvitse määrittää rounds..
** DONE zip
** DONE useampi mittauskierros
*** DONE warmup round
*** DONE UI
*** DONE ne kierrokset
*** DONE mittausluettelo
*** DONE build: include git tag as resource
** DONE perf
**** TODO analyze part -> latex tables etc.
**** TODO inspect build ids
***** eu-readelf -n (elfutils) (should be done in analyze part...)
**** TODO huom! löydä oikea kerneli, systematisoi
** DONE dynamic parameter variations
** DONE refactoring: metadatacontainer -> map
** DONE no call arguments !!!
** DONE siirrä koodi eri repoon kuin gradu
** DONE korjaa build dependencies
* JNI-funktiot, use caset, kilpakumppanit
** MUST
*** access fields vs calling methods
**** erottele: find id , call
**** variaatiot: static, nonvirtual (nonvirtual: tarvitsee perintäpuun?
*** string, array, nio, variaatiot !!
*** löytämismetodit, reflektionomaiset
**** findclass, getobjectclass, getmethodid, getfieldid
**** isinstanceof, issameobject
*** viitteidenhallinta
**** new + delete : global, local, weak global
**** new local, ensurecapacity vs push/pop localframe
** MAYBE
*** poikkeukset:
**** hallinta java -> c
***** check / occurred / clear
**** heittäminen c -> java
***** throw, throw new
*** reflektio:
    jos käsitellään niin pitäisi verrata getmethodid vs
    javan reflektio-eroja...
*** threadit
**** monitorenter
** NOT
**** getsuperclass, isassignablefrom
**** defineclass, fatalerror, registernatives
* DONE Peruskutsutestit

| java | c    | suunta | java | NOTES                                                                    |
|------+------+--------+------+--------------------------------------------------------------------------|
| :.   | :.   | ->     | :.   | C2JBenchmarkNNNN -> t_caller_java(classname) -> javacounterparts         |
| :.   | :.:: | <<     | ---- | C2CBenchmarkNNNN -> t_caller_native(methodname)                          |
| ---- | ::   | <-     | ::   | J2CBenchmarkNNNN -> c_nativemethod.t                                     |
| ---- | ---- | >>     | :.   | J2JBenchmarkNNNN -> javacounterparts                                     |
|------+------+--------+------+--------------------------------------------------------------------------|

Native2JavaBenchmark:
native run method, method name derived from Native2JavaBenchmark_X_run
 - callee name derived from benchmark number NNNN

Native2NativeBenchmark:
native run method, method name derived from Native2NativeBenchmark_X_run
 - callee name derived from benchmark number NNNN

Benchmark:
native counterpart, method name derived from Benchmark_nativemethod

Java2JavaBenchmark:
java run method, callee name derived from benchmark number NNNN
