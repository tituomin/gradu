* l‰hteet

@www-manual{aosp-build-device,
  url={https://source.android.com/source/building.html},
  organization={Android open source project},
  title={Android open source project---Downloading and building---Preparing to build},
  note={Tekninen dokumentaatio},
  year={2016},
  valid={20.8.2016}
}

ART VIRTUAL MACHINE

@INPROCEEDINGS{7280085,
author={R. Yadav and R. S. Bhadoria},
booktitle={Communication Systems and Network Technologies (CSNT), 2015 Fifth International Conference on},
title={Performance Analysis for Android Runtime Environment},
year={2015},
pages={1076-1079},
abstract={A new runtime was introduced with Android 4.4 i.e. Kit Kat, which should eventually replace the Dalvik runtime. ART (Android Runtime) and Dalvik as the runtime executes the Dalvik Executable format and Dex byte code specification. In other words, when an app is run on android, it goes through a runtime. Previously, Android's runtime was Dalvik. While it performed well, it was still a bottleneck as it only ran the code at the moment it needed to, with a JIT compiler (Just-in-time). AOT (Ahead-of-time) compilation paradigm is followed by ART to process application instructions before they are even required. In the next section, the background of compilation on various architectures is described. In next section, ART is introduced with its new features. In next section, ART has been tested against traditional Dalvik runtime. Then before the conclusion, ARM big. LITTLE architecture is described with some results.},
keywords={Android (operating system);performance evaluation;program compilers;Android 4.4;Android runtime environment;Dalvik Executable format;Dalvik runtime replacement;Dex byte code specification;JIT compiler;Kit Kat;ahead-of-time compilation paradigm;just-in-time compiler;Androids;Computer architecture;Humanoid robots;Java;Performance evaluation;Runtime;Subspace constraints;Android Runtime;Dalvik;LITTLE Architecture;big},
doi={10.1109/CSNT.2015.52},
month={April},}

@inproceedings{android-art,
 author = {Kyle, Stephen and Leather, Hugh and Franke, Bj\"{o}rn and Butcher, Dave and Monteith, Stuart},
 title = {Application of Domain-aware Binary Fuzzing to Aid Android Virtual Machine Testing},
 booktitle = {Proceedings of the 11th ACM SIGPLAN/SIGOPS International Conference on Virtual Execution Environments},
 series = {VEE '15},
 year = {2015},
 isbn = {978-1-4503-3450-1},
 location = {Istanbul, Turkey},
 pages = {121--132},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/2731186.2731198},
 doi = {10.1145/2731186.2731198},
 acmid = {2731198},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {android, art, compiler testing, dex, fuzzing, random testing, testing, virtual machine testing},
}

(NOT ART)

@article{Su:2014:RVP:2544375.2544379,
 author = {Su, Tzu-Hsiang and Tsai, Hsiang-Jen and Yang, Keng-Hao and Chang, Po-Chun and Chen, Tien-Fu and Zhao, Yi-Ting},
 title = {Reconfigurable Vertical Profiling Framework for the Android Runtime System},
 journal = {ACM Transactions on Embedded Computing Systems},
 issue_date = {January 2014},
 volume = {13},
 number = {2s},
 month = jan,
 year = {2014},
 issn = {1539-9087},
 pages = {59:1--59:25},
 articleno = {59},
 numpages = {25},
 url = {http://doi.acm.org/10.1145/2544375.2544379},
 doi = {10.1145/2544375.2544379},
 acmid = {2544379},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Profiling, embedded systems, nonintrusive profiling, vertical profiling, virtual machine profiling},
}



Cortex-A8 Technical Reference Manual	Revision: r3p2
Home > Instruction Cycle Timing > About instruction cycle timing
16.1. About instruction cycle timing

** uuden aallon l√§hteet

*** java benchmarking jvm

@techreport{citeulike:2088216,
    author = {ISO/IEC JTC1 SC22 WG21},
    citeulike-article-id = {2088216},
    citeulike-linkout-0 = {http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf},
    day = {15},
    keywords = {cxx, standard},
    month = jul,
    posted-at = {2009-08-19 15:17:56},
    priority = {0},
    publisher = {{ISO}/{IEC}},
    title = {{ISO/IEC TR 18015: Technical Report on C++ Performance}},
    url = {http://www.open-std.org/jtc1/sc22/wg21/docs/TR18015.pdf},
    year = {2004},
    file = {TR18015.pdf},
}

- vihavaiselta alkup., l√§hteit√§ etc.

@ARTICLE{970569,
author={Liu, Y.A. and Gomez, G.},
journal={Computers, IEEE Transactions on},
title={Automatic accurate cost-bound analysis for high-level languages},
year={2001},
volume={50},
number={12},
pages={1295-1309},
abstract={Not Available},
keywords={Buildings;Cost function;Embedded system;Extraterrestrial measurements;High level languages;Optimizing compilers;Performance analysis;Real time systems;Time measurement;Timing},
doi={10.1109/TC.2001.970569},
ISSN={0018-9340},
file={},
}

@www-article{goetz-benchmark,
    author = {Goetz, Brian},
    citeulike-article-id = {7531453},
    keywords = {benchmark, jvm, optimization},
    url = {http://www.ibm.com/developerworks/library/j-jtp02225/},
    title = {{J}ava theory and practice: Anatomy of a flawed microbenchmark},
    year = {2005},
    month = {helmikuu},
    day = {22},
    journal = {IBM developerWorks},
    publisher = {IBM},
    valid = {20.8.2016}
}

@article{curnow,
author = {Curnow, H. J. and Wichmann, B. A.},
title = {A synthetic benchmark},
volume = {19},
number = {1},
pages = {43-49},
year = {1976},
doi = {10.1093/comjnl/19.1.43},
abstract ={A simple method of measuring performance is by means of a benchmark program. Unless such a program is carefully constructed it is unlikely to be typical of the many thousands of programs run at an installation. An example benchmark for measuring the processor power of scientific computers is presented: this is compared with other methods of assessing computer power.},
URL = {http://comjnl.oxfordjournals.org/content/19/1/43.abstract},
eprint = {http://comjnl.oxfordjournals.org/content/19/1/43.full.pdf+html},
journal = {The Computer Journal},
file = {curnow.pdf}
}

@incollection{dependability-benchmarking,
year={2009},
isbn={978-3-642-b10423-7},
booktitle={Performance Evaluation and Benchmarking},
volume={5895},
series={Lecture Notes in Computer Science},
editor={Nambiar, Raghunath and Poess, Meikel},
doi={10.1007/978-3-642-10424-4_6},
title={From Performance to Dependability Benchmarking: A Mandatory Path},
url={http://dx.doi.org/10.1007/978-3-642-10424-4_6},
publisher={Springer Berlin Heidelberg},
keywords={Benchmarking; dependability; performance; metrics},
author={Vieira, Marco and Madeira, Henrique},
pages={67-83},
file={dependability-benchmarking.pdf}
}

- benchmarking, historiaa

@Article{coffee,
  author = {Stephen M. Blackburn and Kathryn S. McKinley and Robin Garner and Chris Hoffmann and Asjad M. Khan and Rotem Bentzur and Amer Diwan and Daniel Feinberg and Daniel Frampton and Samuel Z. Guyer and Martin Hirzel and Antony Hosking and Maria Jump and Han Lee and J. Eliot and B. Moss and Aashish Phansalkar and Darko Stefanovic and Thomas VanDrunen and Daniel von Dincklage and Ben Wiedermann},
  title = {{Wake Up and Smell the Coffee: Evaluation Methodology for the 21st Century}},
  journal = {Communications of the ACM},
  year = {2008},
  month = {August},
  publisher = {ACM Press},
  address = {New York, NY, USA},
  doi = {http://doi.acm.org/10.1145/1378704.1378723},
  note = {Invited paper. CACM Research Highlights.},
  file = {dacapo-cacm-2008.pdf},
  }

@Inproceedings{BGH+:06,
  author = {Stephen M. Blackburn and Robin Garner and Chris Hoffmann and Asjad M. Khang and Kathryn S. McKinley and Rotem Bentzur and Amer Diwan and Daniel Feinberg and Daniel Frampton and Samuel Z. Guyer and Martin Hirzel and Antony Hosking and Maria Jump and Han Lee and J. Eliot and B. Moss and Aashish Phansalkar and Darko Stefanovic and Thomas VanDrunen and Daniel von Dincklage and Ben Wiedermann},
  title = {{The DaCapo benchmarks: Java benchmarking development and analysis}},
  booktitle = {OOPSLA '06: Proceedings of the 21st annual ACM SIGPLAN conference on Object-oriented programming systems, languages, and applications},
  year = {2006},
  isbn = {1-59593-348-4},
  pages = {169--190},
  location = {Portland, Oregon, USA},
  doi = {http://doi.acm.org/10.1145/1167473.1167488},
  publisher = {ACM Press},
  address = {New York, NY, USA},
  file = {dacapo-oopsla-2006.pdf},
  }

@inproceedings{Blackburn:2006:DBJ:1167473.1167488,
 author = {Blackburn, Stephen M. and Garner, Robin and Hoffmann, Chris and Khang, Asjad M. and McKinley, Kathryn S. and Bentzur, Rotem and Diwan, Amer and Feinberg, Daniel and Frampton, Daniel and Guyer, Samuel Z. and Hirzel, Martin and Hosking, Antony and Jump, Maria and Lee, Han and Moss, J. Eliot B. and Phansalkar, Aashish and Stefanovi\'{c}, Darko and VanDrunen, Thomas and von Dincklage, Daniel and Wiedermann, Ben},
 title = {The DaCapo Benchmarks: Java Benchmarking Development and Analysis},
 booktitle = {Proceedings of the 21st Annual ACM SIGPLAN Conference on Object-oriented Programming Systems, Languages, and Applications},
 series = {OOPSLA '06},
 year = {2006},
 isbn = {1-59593-348-4},
 location = {Portland, Oregon, USA},
 pages = {169--190},
 numpages = {22},
 url = {http://doi.acm.org/10.1145/1167473.1167488},
 doi = {10.1145/1167473.1167488},
 acmid = {1167488},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {DaCapo, Java, SPEC, benchmark, methodology},
 file = {p169-blackburn.pdf},
}

Since benchmarks drive computer science research and industry product
development, which ones we use and how we evaluate them are key
questions for the community. Despite complex runtime tradeoffs due to
dynamic compilation and garbage collection required for Java programs,
many evaluations still use methodologies developed for C, C++, and
Fortran. SPEC, the dominant purveyor of benchmarks, compounded this
problem by institutionalizing these methodologies for their Java
benchmark suite. This paper recommends benchmarking selection and
evaluation methodologies, and introduces the DaCapo benchmarks, a set
of open source, client-side Java benchmarks. We demonstrate that the
complex interactions of (1) architecture, (2) compiler, (3) virtual
machine, (4) memory management, and (5) application require more
extensive evaluation than C, C++, and Fortran which stress (4) much
less, and do not require (3). We use and introduce new value,
time-series, and statistical metrics for static and dynamic properties
such as code complexity, code size, heap composition, and pointer
mutations. No benchmark suite is definitive, but these metrics show
that DaCapo improves over SPEC Java in a variety of ways, including
more complex code, richer object behaviors, and more demanding memory
system requirements. This paper takes a step towards improving
methodologies for choosing and evaluating benchmarks to foster
innovation in system design and implementation for Java and other
managed languages.



@inproceedings{Eeckhout:2003:JPI:949305.949321,
 author = {Eeckhout, Lieven and Georges, Andy and De Bosschere, Koen},
 title = {How Java Programs Interact with Virtual Machines at the Microarchitectural Level},
 booktitle = {Proceedings of the 18th Annual ACM SIGPLAN Conference on Object-oriented Programing, Systems, Languages, and Applications},
 series = {OOPSLA '03},
 year = {2003},
 isbn = {1-58113-712-5},
 location = {Anaheim, California, USA},
 pages = {169--186},
 numpages = {18},
 url = {http://doi.acm.org/10.1145/949305.949321},
 doi = {10.1145/949305.949321},
 acmid = {949321},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Java workloads, performance analysis, statistical data analysis, virtual machine technology, workload characterization},
 file = {p169-eeckhout.pdf},
}

ihan ok, mutta tuosta saa l√§hinn√§ yleisl√§pp√§√§

@inproceedings{Grimmer:2013:ENF:2500828.2500832,
 author = {Grimmer, Matthias and Rigger, Manuel and Stadler, Lukas and Schatz, Roland and M\"{o}ssenb\"{o}ck, Hanspeter},
 title = {An Efficient Native Function Interface for Java},
 booktitle = {Proceedings of the 2013 International Conference on Principles and Practices of Programming on the Java Platform: Virtual Machines, Languages, and Tools},
 series = {PPPJ '13},
 year = {2013},
 isbn = {978-1-4503-2111-2},
 location = {Stuttgart, Germany},
 pages = {35--44},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/2500828.2500832},
 doi = {10.1145/2500828.2500832},
 acmid = {2500832},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Graal, JNA, JNI, Java, Truffle, jblas, native code, native function interface, optimization},
 file = {p35-grimmer.pdf}
}

er‰s esimerkki benchmarkin k‰ytˆst‰

@article{saavedra,
 author = {Saavedra, Rafael H. and Smith, Alan J.},
 title = {Analysis of Benchmark Characteristics and Benchmark Performance Prediction},
 journal = {ACM Transactions on Computer Systems},
 issue_date = {Nov. 1996},
 volume = {14},
 number = {4},
 month = nov,
 year = {1996},
 issn = {0734-2071},
 pages = {344--384},
 numpages = {41},
 url = {http://doi.acm.org/10.1145/235543.235545},
 doi = {10.1145/235543.235545},
 acmid = {235545},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {abstract machine performance model, benchmark analysis, execution time prediction, microbenchmarking},
 file = {p344-saavedra.pdf}
}

# <<saavedra>>

lainaus:
Benchmarking is the process of running a specific program or workload on
a specific machine or system and measuring the resulting performance.


Standard benchmarking provides to run-times for given programs on
given machines, but fails to provide insight as to why those results
were obtained (either in terms of machine or program characteristics)
and fails to provide run-times for that program on some other machine,
or some other programs on that machine. We have developed a
machine-imdependent model of program execution to characterize both
machine performance and program execution. By merging these machine
and program characterizations, we can estimate execution time for
arbitrary machine/program combinations. Our technique allows us to
identify those operations, either on the machine or in the programs,
which dominate the benchmark results. This information helps designers
in improving the performance of future machines and users in tuning
their applications to better utilize the performance of existing
machines. Here we apply our methodology to characterize benchmarks and
predict their execution times. We present extensive run-time
statistics for a large set of benchmarks including the SPEC and
Perfect Club suites. We show how these statistics can be used to
identify important shortcoming in the programs. In addition, we give
execution time estimates for a large sample of programs and machines
and compare these against benchmark results. Finally, we develop a
metric for program similarity that makes it possible to classify
benchmarks with respect to a large set of characteristics.

*** modern computer architectures

@book{HELKA:1601042 ,
  author    = {Allen, Randy.},
  author    = {Kennedy, Ken.},
  title     = {Optimizing compilers for modern architectures : : a dependence-based approach /},
  isbn      = {1-55860-286-0},
  address   = {San Francisco (CA) :},
  publisher = {Morgan Kaufmann,},
  year      = {2002.},
  bibdate   = {20120403065007}
}

Kirjasto: Kumpulan kampuskirjasto, laina-aika 28 vrk
Sijainti: Hs 004.04 Allen

@inproceedings{Ailamaki:1999:DMP:645925.671662,
 author = {Ailamaki, Anastassia and DeWitt, David J. and Hill, Mark D. and Wood, David A.},
 title = {DBMSs on a Modern Processor: Where Does Time Go?},
 booktitle = {Proceedings of the 25th International Conference on Very Large Data Bases},
 series = {VLDB '99},
 year = {1999},
 isbn = {1-55860-615-7},
 pages = {266--277},
 numpages = {12},
 url = {http://dl.acm.org/citation.cfm?id=645925.671662},
 acmid = {671662},
 publisher = {Morgan Kaufmann Publishers Inc.},
 address = {San Francisco, CA, USA},
 file = {P28.pdf},
}


@article{wilhelm-wcet,
 author = {Wilhelm, Reinhard and Engblom, Jakob and Ermedahl, Andreas and Holsti, Niklas and Thesing, Stephan and Whalley, David and Bernat, Guillem and Ferdinand, Christian and Heckmann, Reinhold and Mitra, Tulika and Mueller, Frank and Puaut, Isabelle and Puschner, Peter and Staschulat, Jan and Stenstr\"{o}m, Per},
 title = {The Worst-case Execution-time Problem---Overview of Methods and Survey of Tools},
 journal = {ACM Transactions on Embedded Computing Systems},
 issue_date = {April 2008},
 volume = {7},
 number = {3},
 month = may,
 year = {2008},
 issn = {1539-9087},
 pages = {36:1--36:53},
 articleno = {36},
 numpages = {53},
 url = {http://doi.acm.org/10.1145/1347375.1347389},
 doi = {10.1145/1347375.1347389},
 acmid = {1347389},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Hard real time, worst-case execution times},
 file = {a36-wilhelm.pdf},
}

yll√§ oleva on eritt√§in hyv√§! s. 17!
sielt√§ l√∂ytyi t√§m√§:

@ARTICLE{cpu-influence,
author={Heckmann, R. and Langenbach, M. and Thesing, S. and Wilhelm, R.},
journal={Proceedings of the IEEE},
title={The influence of processor architecture on the design and the results of {WCET} tools},
year={2003},
volume={91},
number={7},
pages={1038-1054},
abstract={The architecture of tools for the determination of worst case execution times (WCETs) as well as the precision of the results of WCET analyses strongly depend on the architecture of the employed processor. The cache replacement strategy influences the results of cache behavior prediction; out-of-order execution and control speculation introduce interferences between processor components, e.g., caches, pipelines, and branch prediction units. These interferences forbid modular designs of WCET tools, which would execute the subtasks of WCET analysis consecutively. Instead, complex integrated designs are needed, resulting in high demand for memory space and analysis time. We have implemented WCET tools for a series of increasingly complex processors: SuperSPARC, Motorola ColdFire 5307, and Motorola PowerPC 755. In this paper, we describe the designs of these tools, report our results and the lessons learned, and give some advice as to the predictability of processor architectures.},
keywords={cache storage;parallel architectures;performance evaluation;Motorola ColdFire 5307;Motorola PowerPC 755;SuperSPARC;WCETs;architecture;branch prediction;cache behavior prediction;cache replacement;control speculation;out-of-order execution;static analysis;worst case execution times;Bridges;Computer architecture;Microprocessors;Out of order;Performance analysis;Pipelines;Power system modeling;Processor scheduling;Real time systems;Timing},
doi={10.1109/JPROC.2003.814618},
ISSN={0018-9219},
file={01215685.pdf}
}


** p√§√§l√§hteet
*** microbenchmarking
    https://www.ibm.com/developerworks/java/library/j-jtp02225/
*** android


@inproceedings{Gil:2011:MCS:2095050.2095100,
 author = {Gil, Joseph Yossi and Lenz, Keren and Shimron, Yuval},
 title = {A microbenchmark case study and lessons learned},
 booktitle = {Proceedings of the compilation of the co-located workshops on DSM'11, TMC'11, AGERE!'11, AOOPES'11, NEAT'11, \&\#38; VMIL'11},
 series = {SPLASH '11 Workshops},
 year = {2011},
 isbn = {978-1-4503-1183-0},
 location = {Portland, Oregon, USA},
 pages = {297--308},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/2095050.2095100},
 doi = {10.1145/2095050.2095100},
 acmid = {2095100},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {benchmark, measurements, steady-state},
 file = {p297-gil.pdf},
}

- eritt√§in hyvi√§ l√§hteit√§kin...

@Book{embedded,
  author =    {Yaghmour, Karim},
  ALTeditor =    {},
  title =        {Embedded Android},
  publisher =    {O'Reilly Media},
  year =         {2013},
  OPTkey =       {},
  OPTvolume =    {},
  OPTnumber =    {},
  OPTseries =    {},
  OPTaddress =   {},
  edition =   {Early release- },
  month =     {tammikuu},
  OPTnote =      {},
  OPTannote =    {}
}

*** historialliset

@article{emu,
 author = {Tucker, S. G.},
 title = {Emulation of large systems},
 journal = {Commun. ACM},
 issue_date = {Dec. 1965},
 volume = {8},
 number = {12},
 month = dec,
 year = {1965},
 issn = {0001-0782},
 pages = {753--761},
 numpages = {9},
 url = {http://doi.acm.org/10.1145/365691.365931},
 doi = {10.1145/365691.365931},
 acmid = {365931},
 publisher = {ACM},
 address = {New York, NY, USA},
}

- k√§sitteet, emulaatio vs. simulaatio

@book{jnibook,
 author = {Liang, Sheng},
 title = {Java Native Interface: Programmer's Guide and Reference},
 year = {1999},
 isbn = {0201325772},
 edition = {1st},
 publisher = {Addison-Wesley Longman Publishing Co., Inc.},
 address = {Boston, MA, USA},
 file = {jni-book/jni.pdf},
}

- s.28 getStringCritical: GC off -supported in Android?
- 72: encouraged to use PushLocalFrame/PopLocalFrame
- 89 + 93->: threading (check ndk docs)
  - 97: t√§rke√§! thread model native vs. java must be the same
- 109: wrappers, architecture!
  - 113: shared stubs
  - 123: peer classes, check NDK impl.
- 131: traps & pitfalls
- !145--> design motivations!
  - binary compatibility !



@article {fortran,
  author =       {Knuth, Donald E.},
  title =        {An empirical study of {FORTRAN} programs},
  journal =      {Software: Practice and Experience},
  volume =       1,
  number =       2,
  publisher =    {John Wiley & Sons, Ltd.},
  issn =         {1097-024X},
  url =          {http://dx.doi.org/10.1002/spe.4380010203},
  doi =          {10.1002/spe.4380010203},
  pages =        {105--133},
  keywords =     {FORTRAN, Optimization, Efficiency, Compiler},
  year =         1971,
  abstract =     {A sample of programs, written in FORTRAN by a wide
                  variety of people for a wide variety of
                  applications, was chosen "at random" in an attempt
                  to discover quantitatively "what programmers really
                  do". Statistical results of this survey are
                  presented here, together with some of their apparent
                  implications for future work in compiler design. The
                  principal conclusion which may be drawn is the
                  importance of a program "profile", namely a table of
                  frequency counts which record how often each
                  statement is performed in a typical run; there are
                  strong indications that profile-keeping should
                  become a standard practice in all computer systems,
                  for casual users as well as system programmers. This
                  paper is the report of a three month study
                  undertaken by the author and about a dozen students
                  and representatives of the software industry during
                  the summer of 1970. It is hoped that a reader who
                  studies this report will obtain a fairly clear
                  conception of how FORTRAN is being used, and what
                  compilers can do about it.},
  file =         {knuth-fortran.pdf}
}

- profilointi (k√§sitteen esittely: s. 113)
- huom! kustannusarviot /arvioita/, ei mittauksia
- jump tracing? gaines [13]
- p. 128 perusl√§pp√§√§ programmer vs. machine time (classic)

@article{goto,
 author = {Knuth, Donald E.},
 title = {Structured Programming with go to Statements},
 journal = {ACM Comput. Surv.},
 issue_date = {Dec. 1974},
 volume = {6},
 number = {4},
 month = dec,
 year = {1974},
 issn = {0360-0300},
 pages = {261--301},
 numpages = {41},
 url = {http://doi.acm.org/10.1145/356635.356640},
 doi = {10.1145/356635.356640},
 acmid = {356640},
 publisher = {ACM},
 address = {New York, NY, USA},
}

- s. 268: premature optimization  is the root of all evil


@book{Bentley:1982:WEP:539147,
 author = {Bentley, Jon Louis},
 title = {Writing efficient programs},
 year = 1982,
 isbn = {0-13-970251-2},
 publisher = {Prentice-Hall, Inc.},
 address = {Upper Saddle River, NJ, USA},
}

- Call Number:	 Hs 004.04 Bentley
- k√§yt√§nn√∂n periaatteita, ei niin oleellinen

*** automaattinen jni


@www-manual{jnitips,
  title = {JNI Tips},
  author = {Google},
  url = {http://developer.android.com/training/articles/perf-jni.html},
  valid={20.8.2016},
  year={2016}
}


@www-manual{sdk,
  title =        {Android SDK API Reference},
  url = {http://developer.android.com/reference/packages.html},
  OPTkey =       {},
  author =    {Google},
  OPTorganization = {},
  OPTaddress =   {},
  OPTedition =   {},
  year =      {2016},
  OPTnote =      {},
  OPTannote =    {},
  valid={20.8.2016}
}

@www-manual{android-tracing,
  title = {Profiling with Traceview and dmtracedump},
  url = {http://developer.android.com/tools/debugging/debugging-tracing.html},
  author = {Google},
  year = {2016},
  valid={20.8.2016}
}

@www-manual{ndk,
  title =        {Android Native Development Kit},
  OPTkey =       {},
  author =    {Google},
  OPTorganization = {},
  OPTaddress =   {},
  OPTedition =   {},
  year =      {2016},
  url = {http://developer.android.com/tools/sdk/ndk/index.html},
  OPTnote =      {},
  OPTannote =    {},
  valid={20.8.2016}
}





@Misc{aosp,
  OPTkey =       {},
  author =    {{Open Handset Alliance}},
  title =     {Android Open Source Project},
  OPThowpublished = {},
  month =     {marraskuu},
  year =      {2012},
  OPTnote =      {},
  OPTannote =    {}
}

todo month exact date

@inproceedings{aot,
 author = {Wang, Chih-Sheng and Perez, Guillermo and Chung,
 Yeh-Ching and Hsu, Wei-Chung and Shih, Wei-Kuan and
 Hsu, Hong-Rong},
 title = {A method-based ahead-of-time compiler for {Android} applications},
 booktitle = {Proceedings of the 14th international conference on
 Compilers, architectures and synthesis for embedded
 systems},
 series = {CASES '11},
 year = 2011,
 isbn = {978-1-4503-0713-0},
 location = {Taipei, Taiwan},
 pages = {15--24},
 numpages = 10,
 url = {http://doi.acm.org/10.1145/2038698.2038704},
 doi = {10.1145/2038698.2038704},
 acmid = 2038704,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {ahead-of-time compiler, android, dalvik bytecode,
 just-in-time compiler, reverse engineering, static
 profiling},
 file = {p15-wang.pdf}
}

Loistava artikkeli.

*idea* k√§yt√§ vastaavaa staattista analyysi√§ v√§hent√§m√§√§n native ->
dvm-kutsuja? (siirr√§ dvm-osapuoli my√∂s natiiviksi?)

- static profiling, aot (aheaod-of-time) vs jit
- problems
 - high jni overhed
 - taken into account in the profiling
 - type information loss
- tools
 - benchmark references
 - google traceview! (runs code once, combine with monkey?)
 - find out about real dynamic profiling
 - smali (dex disassembler)
- differences btw java & c, bridge
- optimisation tricks
 - avoid calling native code through jni
 - inlining (l√§hde 20)
 - native code runs in vm context ??
 - aot resolution (constant pool)
 - caching
 - method cloning
- testituloksia
 - string = expensive
 - expensive copying operators

@inproceedings{Stepanian:2005:IJN:1064979.1064997,
 author = {Stepanian, Levon and Brown, Angela Demke and Kielstra, Allan and Koblents, Gita and Stoodley, Kevin},
 title = {Inlining java native calls at runtime},
 booktitle = {Proceedings of the 1st ACM/USENIX international conference on Virtual execution environments},
 series = {VEE '05},
 year = {2005},
 isbn = {1-59593-047-7},
 location = {Chicago, IL, USA},
 pages = {121--131},
 numpages = {11},
 url = {http://doi.acm.org/10.1145/1064979.1064997},
 doi = {10.1145/1064979.1064997},
 acmid = {1064997},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {JIT compilation, JNI, Java, inlining, native code},
 file = {p121-stepanian.pdf}
}

*** suorituskyky

@inproceedings{rigor,
 author = {Georges, Andy and Buytaert, Dries and Eeckhout, Lieven},
 title = {Statistically Rigorous Java Performance Evaluation},
 booktitle = {Proceedings of the 22Nd Annual ACM SIGPLAN Conference on Object-oriented Programming Systems and Applications},
 series = {OOPSLA '07},
 year = {2007},
 isbn = {978-1-59593-786-5},
 location = {Montreal, Quebec, Canada},
 pages = {57--76},
 numpages = {20},
 url = {http://doi.acm.org/10.1145/1297027.1297033},
 doi = {10.1145/1297027.1297033},
 acmid = {1297033},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {benchmarking, data analysis, java, methodology, statistics},
 file = {p57-georges.pdf}
}

- eritt√§in hyv√§ l√§hde k√§ytett√§v√§ksi sellaisenaan
- soveltuu suoraan benchmark-metodien avaamiseen

@book {javaplatform,
 title = {Java Platform Performance: Strategies and Tactics},
 file = {http://web.archive.org/web/20060820211453/http://java.sun.com/docs/books/performance/}
}

-waybackmachine

@article{todo,
  author = {T, T and O, O and D, D},
  title = {Todo},
  publisher = {Prentice-Hall},
  year      = {2000},
  bibdate   = {20120402202956}
}

@book{ferrari,
  author    = {Ferrari, Domenico},
  title     = {Computer systems performance evaluation},
  isbn      = {0-13-165126-9},
  address   = {Englewood Cliffs (NJ)},
  publisher = {Prentice-Hall},
  year      = {1978},
  bibdate   = {20120402202956}
}

@book{spe,
 author = {Smith, Connie U.},
 title = {Performance engineering of software systems},
 isbn = {0-201-53769-9},
 address = {Reading (MA)},
 publisher = {Addison-Wesley,},
 year = {1990},
 bibdate = {20120402220445}
}

- vertaa my√∂h√§isemp√§√§n "painokseen"
- todo s. 337 benchmarkin m√§√§ritelm√§


@inproceedings{sharma,
 author = {Sharma, Vibhu Saujanya and Trivedi, Kishor S.},
 title = {Architecture based analysis of performance, reliability and security of software systems},
 booktitle = {Proceedings of the 5th international workshop on
 Software and performance},
 series = {WOSP '05},
 year = 2005,
 isbn = {1-59593-087-6},
 location = {Palma, Illes Balears, Spain},
 pages = {217--227},
 numpages = 11,
 url = {http://doi.acm.org/10.1145/1071021.1071046},
 doi = {10.1145/1071021.1071046},
 acmid = 1071046,
 publisher = {ACM},
 address = {New York, NY, USA},
 file = {p217-sharma.pdf}
}

-- modeling
-- markov chains, vaikuttaa juuri asialliselta

*** arkkitehtuuri

@inproceedings{perf-arch,
 author = {Williams, Lloyd G. and Smith, Connie U.},
 title = {Performance evaluation of software architectures},
 booktitle = {Proceedings of the 1st international workshop on
 Software and performance},
 series = {WOSP '98},
 year = 1998,
 isbn = {1-58113-060-0},
 location = {Santa Fe, New Mexico, United States},
 pages = {164--177},
 numpages = 14,
 url = {http://doi.acm.org/10.1145/287318.287353},
 doi = {10.1145/287318.287353},
 acmid = 287353,
 publisher = {ACM},
 address = {New York, NY, USA},
 file = {p164-williams.pdf}
}

- alussa hyvi√§ perusv√§itt√§mi√§, arkkitehtuuri + suorituskyky

@INPROCEEDINGS{arch,
author={Clements, P.C.},
booktitle={Parallel and Distributed Real-Time Systems, 1997. Proceedings of the Joint Workshop on}, title={Coming attractions in software architecture},
year={1997},
month={apr},
volume={},
number={},
pages={2 -9},
abstract={Software architecture has emerged as an important topic in software engineering. This paper examines what is new about the subject, and what is not, and what research trends we may expect in the future. We discuss the promise that work in the field holds, and organize the work into five predominant themes: selection, representation, evaluation, development, and recovery. Technology for the formal representation of architectures is examined in detail, along with notions of architectural styles and patterns. The paper begins by examining the range of meanings associated with the term in order to provide a context for its treatment},
keywords={development;evaluation;recovery;representation;selection;software architecture;software engineering;software engineering;technological forecasting;},
doi={10.1109/WPDRTS.1997.637857},
ISSN={},
file={00637857.pdf}}

- smith et al viittaa t√§h√§n, ehk√§ menee v√§h√§n liian yleish√∂lin√§ksi kuitenkin
- no, voi viitata suhteessa hajautettuihin j√§rjestelmiin

*** mallinnus

@incollection{rethink,
year={2008},
isbn={978-3-540-87878-0},
booktitle={Quality of Software Architectures. Models and Architectures},
volume={5281},
series={Lecture Notes in Computer Science},
editor={Becker, Steffen and Plasil, Frantisek and Reussner, Ralf},
doi={10.1007/978-3-540-87879-7_1},
title={Rethinking the Use of Models in Software Architecture},
url={http://dx.doi.org/10.1007/978-3-540-87879-7_1},
publisher={Springer Berlin Heidelberg},
author={Ardagna, Danilo and Ghezzi, Carlo and Mirandola, Raffaela},
pages={1-27},
file={rethinking-models.pdf}
}

- eritt√§in hyv√§lt√§ vaikuttava yleistajuinen esitys malleista

*** profilointi, ty√∂kalut

@inproceedings{du,
 author = {Du, Jiaqing and Sehrawat, Nipun and Zwaenepoel, Willy},
 title = {Performance profiling of virtual machines},
 booktitle = {Proceedings of the 7th ACM SIGPLAN/SIGOPS international conference on Virtual execution environments},
 series = {VEE '11},
 year = {2011},
 isbn = {978-1-4503-0687-4},
 location = {Newport Beach, California, USA},
 pages = {3--14},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/1952682.1952686},
 doi = {10.1145/1952682.1952686},
 acmid = {1952686},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {binary translation, hardware-assisted virtualization, paravirtualization, performance profiling, virtual machine},
 file = {p3-du.pdf}
}

- linux perf
- perusl√§pp√§√§ prosessorin countereista, ym

@book{advanced-unix,
 author = {Stevens, W. Richard and Rago, Stephen A.},
 title = {Advanced Programming in the UNIX Environment, Second Edition},
 year = {2008},
 isbn = {0321525949, 9780321525949},
 edition = {2nd},
 publisher = {Addison-Wesley Professional},
}



@ARTICLE{1667162,
author={Plattner, B. and Nievergelt, J.},
journal={Computer}, title={Special Feature: Monitoring Program Execution: A Survey},
year={1981},
month={nov. },
volume={14},
number={11},
pages={76 -93},
abstract={Progress in this realm of performance measurement has lagged behind advances in the general field of programming languages: careful study of its capabilities and limitations is long overdue.},
keywords={},
doi={10.1109/C-M.1981.220255},
ISSN={0018-9162},
file={01667162.pdf}
}




@article{vertical,
 author = {Hauswirth, Matthias and Sweeney, Peter F. and Diwan,
 Amer and Hind, Michael},
 title = {Vertical profiling: understanding the behavior of object-oriented applications},
 journal = {ACM SIGPLAN Notices},
 issue_date = {October 2004},
 volume = 39,
 number = 10,
 month = oct,
 year = 2004,
 issn = {0362-1340},
 pages = {251--269},
 numpages = 19,
 url = {http://doi.acm.org/10.1145/1035292.1028998},
 doi = {10.1145/1035292.1028998},
 acmid = 1028998,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {hardware performance monitors, perturbation,
 software performance monitors, vertical profiling,
 whole-system analysis},
 file = {p251-hauswirth.pdf}
}
@inproceedings{Hauswirth:2004:VPU:1028976.1028998,
 author = {Hauswirth, Matthias and Sweeney, Peter F. and Diwan,
 Amer and Hind, Michael},
 title = {Vertical profiling: understanding the behavior of object-oriented applications},
 booktitle = {Proceedings of the 19th annual ACM SIGPLAN
 conference on Object-oriented programming, systems,
 languages, and applications},
 series = {OOPSLA '04},
 year = 2004,
 isbn = {1-58113-831-8},
 location = {Vancouver, BC, Canada},
 pages = {251--269},
 numpages = 19,
 url = {http://doi.acm.org/10.1145/1028976.1028998},
 doi = {10.1145/1028976.1028998},
 acmid = 1028998,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {hardware performance monitors, perturbation,
 software performance monitors, vertical profiling,
 whole-system analysis},
 file = {p251-hauswirth.pdf}
}


@TECHREPORT{appel,
    author = {Andrew Appel and Bruce F. Duba and David B. Macqueen and Andrew P. Tolmach},
    title = {Profiling in the Presence of Optimization and Garbage Collection},
    institution = {Princeton University, Department of Computer Science},
    address = {Princeton, NJ, USA},
    number = {CS-TR-197-88},
    year = {1988},
    month = {{Nov.}},
    file = {10.1.1.51.7366.pdf},
}

- Eritt√§in hyv√§√§ perustietoa profiloinnista
  - interrupt-driven
  - call counting
- ei instituutiota?

@inproceedings{gprof,
 author = {Graham, Susan L. and Kessler, Peter B. and Mckusick, Marshall K.},
 title = {Gprof: A Call Graph Execution Profiler},
 booktitle = {Proceedings of the 1982 SIGPLAN Symposium on Compiler Construction},
 series = {SIGPLAN '82},
 year = {1982},
 isbn = {0-89791-074-5},
 location = {Boston, Massachusetts, USA},
 pages = {120--126},
 numpages = {7},
 url = {http://doi.acm.org.libproxy.helsinki.fi/10.1145/800230.806987},
 doi = {10.1145/800230.806987},
 acmid = {806987},
 publisher = {ACM},
 address = {New York, NY, USA},
}

@Manual{cortex,
  title =        {Cortex-A8 Technical Reference Manual},
  OPTkey =       {},
  author =    {{ARM Ltd.}},
  OPTorganization = {},
  OPTaddress =   {},
  edition =   {Revision r3p2},
  OPTmonth =     {},
  year =      {2010},
  OPTnote =      {},
  OPTannote =    {}
}

@Manual{cortex-programmer,
  title =        {Cortex A Series Programmers Guide},
  OPTkey =       {},
  author =    {{ARM Ltd.}},
  OPTorganization = {},
  OPTaddress =   {},
  edition =   {Version 4.0},
  OPTmonth =     {},
  year =      {2011--2013},
  OPTnote =      {},
  OPTannote =    {}
}

^DVFS: s. 20/7



16.1

Other pipeline-dependent latencies

In addition to the time taken for the scheduling and issuing of
instructions, there are other sources of latencies that effect the
time of a program sequence. The two most common examples are a branch
mispredict and a memory system stall such as a data cache miss of a
load instruction. These cases are the most difficult to predict and
often must be ignored or estimated using statistical analysis
techniques. Fortunately, you can ignore most of these additional
latencies when creating an optimal hand scheduling for a code
sequence. Hand scheduling is the most useful application of this cycle
timing information.




*** pelit
@article{Phelps:2004:FGM:971564.971592,
 author = {Phelps, Andrew M. and Parks, David M.},
 title = {Fun and Games: Multi-Language Development},
 journal = {Queue},
 issue_date = {February 2004},
 volume = {1},
 number = {10},
 month = feb,
 year = {2004},
 issn = {1542-7730},
 pages = {46--56},
 numpages = {11},
 url = {http://doi.acm.org/10.1145/971564.971592},
 doi = {10.1145/971564.971592},
 acmid = {971592},
 publisher = {ACM},
 address = {New York, NY, USA},
 file = {phelps.pdf}
}

** ehk√§ p√§√§l√§hteet

@ARTICLE{1291833,
author={Balsamo, S. and di Marco, A. and Inverardi, P. and Simeoni, M.},
journal={Software Engineering, IEEE Transactions on}, title={Model-based performance prediction in software development: a survey},
year={2004},
month={may},
volume={30},
number={5},
pages={ 295 - 310},
abstract={ Over the last decade, a lot of research has been directed toward integrating performance analysis into the software development process. Traditional software development methods focus on software correctness, introducing performance issues later in the development process. This approach does not take into account the fact that performance problems may require considerable changes in design, for example, at the software architecture level, or even worse at the requirement analysis level. Several approaches were proposed in order to address early software performance analysis. Although some of them have been successfully applied, we are still far from seeing performance analysis integrated into ordinary software development. In this paper, we present a comprehensive review of recent research in the field of model-based performance prediction at software development time in order to assess the maturity of the field and point out promising research directions.},
keywords={Automation;Availability;Performance analysis;Predictive models;Programming;Runtime;Software architecture;Software performance;Software systems;System software; formal verification; software performance evaluation; software process improvement; model-based performance prediction; requirement analysis level; software architecture level; software development process; software performance analysis; software verification;65;Software verification;integrated environments.;performance modeling and prediction;},
doi={10.1109/TSE.2004.9},
ISSN={0098-5589},
file = {01291833.pdf},
}


@inproceedings{beizer,
 author = {Beizer, Boris},
 title = {Analytical techniques for the statistical evaluation of program running time},
 booktitle = {Proceedings of the November 17-19, 1970, fall joint computer conference},
 series = {AFIPS '70 (Fall)},
 year = {1970},
 location = {Houston, Texas},
 pages = {519--524},
 numpages = {6},
 url = {http://doi.acm.org/10.1145/1478462.1478537},
 doi = {10.1145/1478462.1478537},
 acmid = {1478537},
 publisher = {ACM},
 address = {New York, NY, USA},
 file = {p519-beizer.pdf},
}

- alkuper√§inen markov-sovellus (found via ferrari)

S. Barber, ‚ÄúBeyond performance testing‚Äù, parts 1-14,
IBM DeveloperWorks, Rational Technical Library, 2004,
http://www.ibm.com/developerworks/rational/library/4169.html

- vaikuttaa hyv√§lt√§

@article{Nair:2011:EHN:1952522.1952525,
 author = {Nair, Ajay and Shankar, Karthik and Lysecky, Roman},
 title = {Efficient hardware-based nonintrusive dynamic application profiling},
 journal = {ACM Transactions on Embedded Computing Systems},
 issue_date = {April 2011},
 volume = 10,
 number = 3,
 month = may,
 year = 2011,
 issn = {1539-9087},
 pages = {32:1--32:22},
 articleno = 32,
 numpages = 22,
 url = {http://doi.acm.org/10.1145/1952522.1952525},
 doi = {10.1145/1952522.1952525},
 acmid = 1952525,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Java, array bounds check optimization, compilation,
 just-in-time, optimization, performance,
 verification},
 file = {a32-nair.pdf}
}

- perusl√§hteit√§ profilointiin?
- tosin aika h/w, embedded-focus
- itse tutkimus ei sovellu, mutta l√§hdelista voi olla hyv√§

@book{art-programming,
  author    = {Knuth, Donald E.},
  title     = {The art of computer programming},
  isbn      = {0-201-89683-4 (sid.)},
  address   = {Reading (MA)},
  publisher = {Addison-Wesley},
  year      = {1968},
  bibdate   = {20120403021153}
}

@ARTICLE{valgrind,
author={Nethercote, N. and Seward, J.},
title={Valgrind: A program supervision framework},
journal={Electronic Notes in Theoretical Computer Science},
year={2003},
volume={89},
number={2},
pages={47-69},
note={cited By (since 1996) 116},
url={http://www.scopus.com/inward/record.url?eid=2-s2.0-16244366310&partnerID=40&md5=84a49ab7d52b15ad5ca2d1468fc29a65},
affiliation={Computer Laboratory, University of Cambridge, Cambridge, United Kingdom},
abstract={Valgrind is a programmable framework for creating program supervision tools such as bug detectors and profilers. It executes supervised programs using dynamic binary translation, giving it total control over their every part without requiring source code, and without the need for recompilation or relinking prior to execution. New supervision tools can be easily created by writing skins that plug into Valgrind's core. As an example, we describe one skin that performs Purify-style memory checks for C and C++ programs. √Ç¬© 2003 Published by Elsevier Science B.V.},
document_type={Conference Paper},
source={Scopus},
 file={Valgrind.pdf}
}



@inproceedings{dvm-jit,
 author = {Absar, Javed and Shekhar, Deepak},
 title = {Eliminating partially-redundant array-bounds check in the {Android} {Dalvik} {JIT} compiler},
 booktitle = {Proceedings of the 9th International Conference on
 Principles and Practice of Programming in Java},
 series = {PPPJ '11},
 year = 2011,
 isbn = {978-1-4503-0935-6},
 location = {Kongens Lyngby, Denmark},
 pages = {121--128},
 numpages = 8,
 url = {http://doi.acm.org/10.1145/2093157.2093175},
 doi = {10.1145/2093157.2093175},
 acmid = 2093175,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Java, array bounds check optimization, compilation,
 just-in-time, optimization, performance,
 verification},
 file = {p121-absar.pdf},
}

- perusl√§pp√§√§ androidista
- dalvikista ja jitist√§
- muuten ok

@inproceedings{jeannie,
 author = {Hirzel, Martin and Grimm, Robert},
 title = {Jeannie: granting {Java} native interface developers their wishes},
 booktitle = {Proceedings of the 22nd annual ACM SIGPLAN
 conference on Object-oriented programming systems
 and applications},
 series = {OOPSLA '07},
 year = 2007,
 isbn = {978-1-59593-786-5},
 location = {Montreal, Quebec, Canada},
 pages = {19--38},
 numpages = 20,
 url = {http://doi.acm.org/10.1145/1297027.1297030},
 doi = {10.1145/1297027.1297030},
 acmid = 1297030,
 publisher = {ACM},
 address = {New York, NY, USA},
 file = {p19-hirzel.pdf},
 keywords = {C, JNI, foreign function interface, java, modular
 syntax, programming language composition, rats!,
 xtc},
}
@article{Hirzel:2007:JGJ:1297105.1297030,
 author = {Hirzel, Martin and Grimm, Robert},
 title = {Jeannie: granting java native interface developers their wishes},
 journal = {ACM SIGPLAN Notices},
 issue_date = {October 2007},
 volume = 42,
 number = 10,
 month = oct,
 year = 2007,
 issn = {0362-1340},
 pages = {19--38},
 numpages = 20,
 url = {http://doi.acm.org/10.1145/1297105.1297030},
 doi = {10.1145/1297105.1297030},
 acmid = 1297030,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {C, JNI, foreign function interface, java, modular
 syntax, programming language composition, rats!,
 xtc},
 file = {p19-hirzel.pdf},
}
# sivu 19
# Higher-level languages must interface with lower-level lan-
# guages, typically C, to access platform functionality, reuse
# legacy libraries, and improve efficiency. For example, most
# Java programs execute native code, since several methods
# of even class Object at the root of Java‚Äôs class hierarchy
# are written in C. Foreign-function interfaces (FFIs) accom-
# plish this task, providing access to C code and data from
# higher-level languages and vice versa. For example, a Java
# project can reuse a high-performance C library for binary
# decision diagrams (BDDs) through the Java Native Inter-
# face [38] (JNI), which is the standard FFI for Java.
# FFI designs aim for productivity, safety, portability, and
# efficiency. Unfortunately, these goals are often at odds. For
# instance, Sun‚Äôs original FFI for Java, the Native Method In-
# terface [52, 53] (NMI), directly exposed Java objects as C
# structs and thus provided simple and fast access to object
# fields. However, this is unsafe, since C code can violate Java
# types, notably by storing an object of incompatible type in a
# field. Furthermore, it constrains garbage collectors and just-
# in-time compilers, since changes to the data representation
# may break native code. In fact, NMI required a conserva-
# tive garbage collector because direct field access prevents
# the Java virtual machine (JVM) from tracking references in
# native code. Finally, native code that depends on a virtual
# machine‚Äôs object layout is hard to port to other JVMs.
# In contrast to the Native Method Interface, the Java Na-
# tive Interface is well encapsulated. As a result, C code is
# easily portable while also permitting efficient and differing
# Java virtual machine implementations. But JNI‚Äôs reflection-
# like API requires verbose boiler-plate code, which reduces
# productivity when writing and maintaining native code. Fur-
# thermore, it is still unsafe‚Äîtyping errors cannot be checked
# statically, nor does the JNI specification require dynamic
# checks. It is also less efficient than unportable FFIs that ex-
# pose language implementation details.


- jni perusl√§hde
- lainaukset
    Of course, JNI itself represents only one point in the
    design space of foreign function interfaces (FFIs). As dis-
    cussed in detail in [46], FFIs provide both mechanism and
    policy for bridging between a higher-level language and
    C. The mechanism typically entails glue code to convert
    between the different data representations and calling con-
    ventions. For example, like JNI, the FFIs for O'Caml [37]
    and SML/NJ [33] as well as the Swig FFI generator for
    scripting languages [7] rely on glue code written in C.
    However, the FFI for the Scheme-based esh shell [47], the
    Haskell FFI [17], NLFFI for SML/NJ [10], and Charon for
    Moby [21] extend the higher-level language so that glue
    code can be written in the higher-level language.

    The policy determines how to abstract C's low-level data structures
    and functions in the higher-level language. For most FFIs, this
    policy is fixed. For example, JNI enforces an object-oriented view
    of C code and data. However, FIG

** rajallisesti hy√∂dynnett√§viss√§, tueksi



@Misc{binder,
  OPTkey =       {},
  OPTauthor =    {},
  OPTtitle =     {Binder},
  OPThowpublished = {},
  OPTmonth =     {},
  OPTyear =      {},
  OPTnote =      {},
  OPTannote =    {},
 file = {binder.pdf}
}

@inproceedings{future-spe,
 author = {Woodside, Murray and Franks, Greg and Petriu, Dorina C.},
 title = {The Future of Software Performance Engineering},
 booktitle = {Future of Software Engineering},
 series = {FOSE '07},
 year = {2007},
 isbn = {0-7695-2829-5},
 pages = {171--187},
 numpages = {17},
 url = {http://dx.doi.org/10.1109/FOSE.2007.32},
 doi = {10.1109/FOSE.2007.32},
 acmid = {1254717},
 publisher = {IEEE Computer Society},
 address = {Washington, DC, USA},
 file = {04221619.pdf},
 note = {ICSE 2007-konferenssin yhteydess‰ j‰rjestetty konferenssi, Minneapolis, MN, USA, 23. --- 25.5.2007}
}

# s.172
#
# Two general approaches found in literature are
# discussed here, both under the SPE umbrella. The
# commonest approach is purely measurement-based; it
# applies testing, diagnosis and tuning late in the
# development cycle, when the system under
# development can be run and measured (see, e.g.
# [2][4][8][9]). The model-based approach, pioneered
# under the name of SPE by Smith [65][67] (see also [7]
# for a survey of modeling approaches), creates
# performance models early in the development cycle
# and uses quantitative results from these models to
# adjust the architecture and design with the purpose of
# meeting performance requirements. The SPE definition
# proposed in this paper is broader than the one given in
# [65][67], in that it also includes late-cycle
# measurement-based and model-based approaches.
#
# An analogy with other engineering disciplines
# suggests that design by early calculations (e.g., by
# models) is the way forward, but also that it must be
# integrated with measurements. In the case of SPE, this
# integration has been elusive.
#
# ---
#
#


- yleist√§ l√∂pin√§√§ jos tarvitsee t√§ytett√§
- mahdollisesti hyvi√§ l√§hteit√§: measuring vs. modeling

@book{stat,
  author    = {Trivedi, Kishor Shridharbhai.},
  title     = {Probability and statistics with reliability, queuing, and computer science applications /},
  isbn      = {0-13-711564-4},
  address   = {Englewood Cliffs (NJ) :},
  publisher = {Prentice-Hall,},
  year      = {1982.},
  note      = {Nimiˆsivulla tekij‰n nimi virheellisesti: Trived.},
  bibdate   = {20120402221746}
}

@ARTICLE{4plus1,
author={Kruchten, P.B.},
journal={Software, IEEE}, title={The 4+1 View Model of architecture},
year={1995},
month={nov},
volume={12},
number={6},
pages={42 -50},
abstract={The 4+1 View Model organizes a description of a software architecture using five concurrent views, each of which addresses a specific set of concerns. Architects capture their design decisions in four views and use the fifth view to illustrate and validate them. The logical view describes the design's object model when an object-oriented design method is used. To design an application that is very data driven, you can use an alternative approach to develop some other form of logical view, such as an entity-relationship diagram. The process view describes the design's concurrency and synchronization aspects. The physical view describes the mapping of the software onto the hardware and reflects its distributed aspect. The development view describes the software's static organization in its development environment},
keywords={4+1 View Model;concurrency;data-driven application design;design decisions;design object model;development environment;development view;distributed aspect;entity-relationship diagram;hardware;object-oriented design method;physical view;software architecture;software mapping;software static organization;synchronization;validation;distributed processing;entity-relationship modelling;object-oriented methods;software engineering;},
doi={10.1109/52.469759},
ISSN={0740-7459},
file={00469759.pdf}
}


@inproceedings{Pathak:2012:ESI:2168836.2168841,
 author = {Pathak, Abhinav and Hu, Y. Charlie and Zhang, Ming},
 title = {Where is the energy spent inside my app?: fine grained energy accounting on smartphones with Eprof},
 booktitle = {Proceedings of the 7th ACM european conference on
 Computer Systems},
 series = {EuroSys '12},
 year = 2012,
 isbn = {978-1-4503-1223-3},
 location = {Bern, Switzerland},
 pages = {29--42},
 numpages = 14,
 url = {http://doi.acm.org/10.1145/2168836.2168841},
 doi = {10.1145/2168836.2168841},
 acmid = 2168841,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Eprof, energy, mobile, smartphones},
 file = {p29-pathak.pdf},
}

- hyvin kirjoitettu, raikas!

@inproceedings{Siefers:2010:RTN:1866307.1866331,
 author = {Siefers, Joseph and Tan, Gang and Morrisett, Greg},
 title = {Robusta: taming the native beast of the JVM},
 booktitle = {Proceedings of the 17th ACM conference on Computer and communications security},
 series = {CCS '10},
 year = {2010},
 isbn = {978-1-4503-0245-6},
 location = {Chicago, Illinois, USA},
 pages = {201--211},
 numpages = {11},
 url = {http://doi.acm.org/10.1145/1866307.1866331},
 doi = {10.1145/1866307.1866331},
 acmid = {1866331},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {JNI, JVM, SFI, sandboxing},
 file = {p201-siefers.pdf}
}

- p.201: Sun's JDK 1.6 contains over 800,000 lines of C/C++ code
(compared to around two million lines of Java code).


@inproceedings{reppy,
 author = {Reppy, John and Song, Chunyan},
 title = {Application-specific foreign-interface generation},
 booktitle = {Proceedings of the 5th international conference on
 Generative programming and component engineering},
 series = {GPCE '06},
 year = 2006,
 isbn = {1-59593-237-2},
 location = {Portland, Oregon, USA},
 pages = {49--58},
 numpages = 10,
 url = {http://doi.acm.org/10.1145/1173706.1173714},
 doi = {10.1145/1173706.1173714},
 acmid = 1173714,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {foreign-interface generation, term rewriting},
 file = {p49-reppy.pdf}
}

- alussa on hyv√§√§ "teoreettista" yleiserittely√§ ffi:st√§


@article{Chiba:2008:JHP:1344834.1344880,
 author = {Chiba, Yuji},
 title = {Java heap protection for debugging native methods},
 journal = {Sci. Comput. Program.},
 issue_date = {February, 2008},
 volume = {70},
 number = {2-3},
 month = feb,
 year = {2008},
 issn = {0167-6423},
 pages = {149--167},
 numpages = {19},
 url = {http://dx.doi.org/10.1016/j.scico.2007.07.004},
 doi = {10.1016/j.scico.2007.07.004},
 acmid = {1344880},
 publisher = {Elsevier North-Holland, Inc.},
 address = {Amsterdam, The Netherlands, The Netherlands},
 keywords = {Debugging, Java, Memory protection, Protection domain},
}
@article{Chiba2008149,
 title = "Java heap protection for debugging native methods",
 journal = "Science of Computer Programming",
 volume = 70,
 number = "2-3??",
 pages = "149 - 167",
 year = 2008,
 note = "<ce:title>Special Issue on Principles and Practices
 of Programming in Java (PPPJ 2006)</ce:title>",
 issn = "0167-6423",
 doi = "10.1016/j.scico.2007.07.004",
 url =
 "http://www.sciencedirect.com/science/article/pii/S0167642307001712",
 author = "Yuji Chiba",
 keywords = "Java",
 keywords = "Memory protection",
 keywords = "Protection domain",
 keywords = "Debugging", file = {1-s2.0-S0167642307001712-main.pdf}
}


@article{Shi:2008:VMS:1328195.1328197,
 author = {Shi, Yunhe and Casey, Kevin and Ertl, M. Anton and
 Gregg, David},
 title = {Virtual machine showdown: Stack versus registers},
 journal = {ACM Transactions on Architecture and Code Optimization},
 issue_date = {January 2008},
 volume = 4,
 number = 4,
 month = jan,
 year = 2008,
 issn = {1544-3566},
 pages = {2:1--2:36},
 articleno = 2,
 numpages = 36,
 url = {http://doi.acm.org/10.1145/1328195.1328197},
 doi = {10.1145/1328195.1328197},
 acmid = 1328197,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Interpreter, register architecture, stack
 architecture, virtual machine},
 file = {a21-shi.pdf},
}

huom, showdown k√§ytt√§√§ java grandea ja sit√§ toista benchmark suitea... SPECjbb2000 :a

@article{Prechelt:1999:TOC:317665.317683,
 author = {Prechelt, Lutz},
 title = {Technical opinion: comparing Java vs. C/C++ efficiency differences to interpersonal differences},
 journal = {Commun. ACM},
 issue_date = {Oct. 1999},
 volume = 42,
 number = 10,
 month = oct,
 year = 1999,
 issn = {0001-0782},
 pages = {109--112},
 numpages = 4,
 url = {http://doi.acm.org/10.1145/317665.317683},
 doi = {10.1145/317665.317683},
 acmid = 317683,
 publisher = {ACM},
 address = {New York, NY, USA},
 file = {p109-prechelt.pdf},
}

- Anekdoottimainen tutkimus, tehokkuus: C vs Java

@inproceedings{Hazelwood:2006:DBI:1176760.1176793,
 author = {Hazelwood, Kim and Klauser, Artur},
 title = {A dynamic binary instrumentation engine for the ARM architecture},
 booktitle = {Proceedings of the 2006 international conference on
 Compilers, architecture and synthesis for embedded
 systems},
 series = {CASES '06},
 year = 2006,
 isbn = {1-59593-543-6},
 location = {Seoul, Korea},
 pages = {261--270},
 numpages = 10,
 url = {http://doi.acm.org/10.1145/1176760.1176793},
 doi = {10.1145/1176760.1176793},
 acmid = 1176793,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {binary instrumentation, dynamic translation,
 embedded architectures, pin},
 file = {p261-hazelwood.pdf}
}

- ARM-arkkitehtuuri.

@INPROCEEDINGS{824367,
author={Radhakrishnan, R. and Vijaykrishnan, N. and John, L.K. and Sivasubramaniam, A.},
booktitle={High-Performance Computer Architecture, 2000. HPCA-6. Proceedings. Sixth International Symposium on},
 title={Architectural issues in Java runtime systems},
year={2000},
month={},
volume={},
number={},
pages={387 -398},
abstract={ The Java Virtual Machine (JVM) is the cornerstone of Java
                  technology, and its efficiency in executing portable
                  Java bytecodes is crucial for the success of this
                  technology. Interpretation, just-in-time (JIT)
                  compilation and hardware realization are well-known
                  solutions for JVM, and previous research has
                  proposed optimizations for each of these
                  techniques. However, each technique has its pros and
                  cons and may not be uniformly attractive for all
                  hardware platforms. Instead, an understanding of the
                  architectural implications of JVM implementations
                  with real applications can be crucial to the
                  development of enabling technologies for efficient
                  Java runtime system development on a wide range of
                  platforms (from resource-rich servers to
                  resource-constrained hand-held/embedded
                  systems). Towards this goal, this paper examines
                  architectural issues, from both the hardware and JVM
                  implementation perspectives. It specifically
                  explores the potential of a smart JIT compiler
                  strategy that can dynamically interpret or compile
                  based on associated costs, investigates the CPU and
                  cache architectural support that would benefit JVM
                  implementations, and examines the synchronization
                  support for enhancing performance, using
                  applications from the SpecJVM98 benchmarks},
keywords={CPU architectural support;Java Virtual Machine;Java runtime
                  systems;SpecJVM98 benchmarks;cache architectural
                  support;computer
                  architecture;costs;efficiency;embedded
                  systems;enabling technologies;hand-held
                  systems;hardware
                  realization;interpretation;just-in-time
                  compilation;performance enhancement;portable Java
                  bytecodes;resource-constrained systems;resource-rich
                  servers;smart JIT compiler strategy;synchronization
                  support;Java;cache storage;computer
                  architecture;program compilers;program
                  interpreters;synchronisation;virtual machines;},
doi={10.1109/HPCA.2000.824367},
file = {00824367.pdf},
ISSN={},}

- Perustaustaa Javan suorituskyvyst√§
- nykymittauksia?


*** jni-bugit

@inproceedings{Li:2011:QFM:2093157.2093159,
 author = {Li, Du and Srisa-an, Witawas},
 title = {Quarantine: a framework to mitigate memory errors in JNI applications},
 booktitle = {Proceedings of the 9th International Conference on
 Principles and Practice of Programming in Java},
 series = {PPPJ '11},
 year = 2011,
 isbn = {978-1-4503-0935-6},
 location = {Kongens Lyngby, Denmark},
 pages = {1--10},
 numpages = 10,
 url = {http://doi.acm.org/10.1145/2093157.2093159},
 doi = {10.1145/2093157.2093159},
 acmid = 2093159,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {JNI, Java, heap protection, virtual machine},
 file = {p1-li.pdf}
}

- bugien luokittelua, hyv√§!

** hauskat

@article{runaway,
 author = {Glass, Robert L.},
 title = {Software Runaways---Some Surprising Findings},
 journal = {ACM SIGMIS Database},
 issue_date = {Summer 1997},
 volume = {28},
 number = {3},
 month = jun,
 year = {1997},
 issn = {0095-0033},
 pages = {16--19},
 numpages = {4},
 url = {http://doi.acm.org/10.1145/272657.272687},
 doi = {10.1145/272657.272687},
 acmid = {272687},
 publisher = {ACM},
 address = {New York, NY, USA},
 file={p16-glass.pdf},
}


@inproceedings{progressbar,
 author = {Harrison, Chris and Amento, Brian and Kuznetsov, Stacey and Bell, Robert},
 title = {Rethinking the progress bar},
 booktitle = {Proceedings of the 20th annual ACM symposium on User interface software and technology},
 series = {UIST '07},
 year = {2007},
 isbn = {978-1-59593-679-0},
 location = {Newport, Rhode Island, USA},
 pages = {115--118},
 numpages = {4},
 url = {http://doi.acm.org/10.1145/1294211.1294231},
 doi = {10.1145/1294211.1294231},
 acmid = {1294231},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {duration neglect, human-centric, peak-and-end, progress bar, time perception, user interface},
}

* tiedekirjastossa

@article{DBLP:journals/joop/Koenig97,
 author = {Andrew Koenig},
 title = {The Importance - and Hazards - of Performance Measurement},
 journal = {JOOP},
 volume = 9,
 number = 8,
 year = 1997,
 pages = {58-60},
 bibsource = {DBLP, http://dblp.uni-trier.de}
}

* hanki



Pelit:
http://www.scopus.com/record/display.url?eid=2-s2.0-2442591498&origin=inward&txGid=yut9Ys1m3XzYeci6W17UKbE%3a1#

A. Shaw, Reasoning about Time in Higher Level Language
Software,o IEEE Trans. Software Eng., vol. 15, no. 7, pp. 875-889,
July 1989.

Chapter in Book: Origins of Performance Engineering: Highlights and
Outstanding Problems, in Performance Engineering: State of the Art and
Current Trends, Springer-Verlag, 2001.

Software Performance and Scalability: A Quantitative Approach (Quantitative Software Engineering Series) [Hardcover]
Henry H. Liu

- ei kirjastossa

@book{glass1998software,
 title = {Software runaways: Lessons Learned from Massive Sotftware Project Failures},
 author = {Glass, Robert L.},
 isbn = 9780136734437,
 lccn = 97029566,
 url = {http://books.google.fi/books?id=w6ZQAAAAMAAJ},
 year = 1998,
 publisher = {Prentice Hall PTR}
}

- Ei l√∂ydy kirjastosta.

@book{noble2001small,
 title = {Small memory software: patterns for systems with limited memory},
 author = {Noble, J. and Weir, C.},
 isbn = 9780201596076,
 lccn = 00061846,
 series = {Software patterns series},
 url = {http://books.google.fi/books?id=Cd9QAAAAMAAJ},
 year = 2001,
 publisher = {Addison-Wesley}
}

- Ei l√∂ydy HY kirjastosta

* arvioi


http://www.cse.wustl.edu/~jain/cse567-06/ftp/sw_monitors1/index.html

** architecture, modeling, performance

@inproceedings{Goldsmith:2007:MEC:1287624.1287681,
 author = {Goldsmith, Simon F. and Aiken, Alex S. and Wilkerson, Daniel S.},
 title = {Measuring empirical computational complexity},
 booktitle = {Proceedings of the the 6th joint meeting of the European software engineering conference and the ACM SIGSOFT symposium on The foundations of software engineering},
 series = {ESEC-FSE '07},
 year = {2007},
 isbn = {978-1-59593-811-4},
 location = {Dubrovnik, Croatia},
 pages = {395--404},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/1287624.1287681},
 doi = {10.1145/1287624.1287681},
 acmid = {1287681},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {empirical computational complexity, trend-prof},
 file = {p395-goldsmith.pdf}
}

- abstraktin perusteella voisi hy√∂dynt√§√§ jni-bridgeen?

@inproceedings{Israr:2005:AGL:1071021.1071037,
 author = {Israr, Tauseef A. and Lau, Danny H. and Franks, Greg and Woodside, Murray},
 title = {Automatic generation of layered queuing software performance models from commonly available traces},
 booktitle = {Proceedings of the 5th international workshop on Software and performance},
 series = {WOSP '05},
 year = {2005},
 isbn = {1-59593-087-6},
 location = {Palma, Illes Balears, Spain},
 pages = {147--158},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/1071021.1071037},
 doi = {10.1145/1071021.1071037},
 acmid = {1071037},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {layered queuing, model building, performance engineering, software performance, tracing performance modeling},
 file = {p147-israr.pdf},
}

- lue

@incollection{sharma2,
year={2005},
isbn={978-3-540-25877-3},
booktitle={Component-Based Software Engineering},
volume={3489},
series={Lecture Notes in Computer Science},
editor={Heineman, GeorgeT. and Crnkovic, Ivica and Schmidt, HeinzW. and Stafford, JudithA. and Szyperski, Clemens and Wallnau, Kurt},
doi={10.1007/11424529_5},
title={Evaluating Performance Attributes of Layered Software Architecture},
url={http://dx.doi.org/10.1007/11424529_5},
publisher={Springer Berlin Heidelberg},
author={Sharma, VibhuSaujanya and Jalote, Pankaj and Trivedi, KishorS.},
pages={66-81},
file={layered-arch-perf-model.pdf}
}

- hyv√§√§ perusl√§pp√§√§ SPE:st√§!
- PFQN (ei hyv√§), mutta prototyyppimalli markov discrete timena

@incollection{uml-lqn,
year={2000},
isbn={978-3-540-67658-4},
booktitle={Applications of Graph Transformations with Industrial Relevance},
volume={1779},
series={Lecture Notes in Computer Science},
editor={Nagl, Manfred and Sch√ºrr, Andreas and M√ºnch, Manfred},
doi={10.1007/3-540-45104-8_4},
title={From UML Descriptions of High-Level Software Architectures to LQN Performance Models},
url={http://dx.doi.org/10.1007/3-540-45104-8_4},
publisher={Springer Berlin Heidelberg},
author={Petriu, DorinaC. and Wang, Xin},
pages={47-63},
language={English},
file={uml-arch-perf-model.pdf}
}

-- vaikuttaa hyv√§lt√§, liittyy edelliseen

@incollection{purhonen,
year={2005},
isbn={978-3-540-30644-3},
booktitle={Component-Based Software Development for Embedded Systems},
volume={3778},
series={Lecture Notes in Computer Science},
editor={Atkinson, Colin and Bunse, Christian and Gross, Hans-Gerhard and Peper, Christian},
doi={10.1007/11591962_14},
title={Performance Evaluation Approaches for Software Architects},
url={http://dx.doi.org/10.1007/11591962_14},
publisher={Springer Berlin Heidelberg},
author={Purhonen, Anu},
pages={275-295}
}


modeling conf:
http://dl.acm.org/event.cfm?id=RE313&CFID=187693783&CFTOKEN=27205712




** java vs.  c++

Przemys√°aw Bruski, ‚ÄúThe Java (not really) Faster than C++
Benchmark,‚Äù Available: http://bruscy.republika.pl/pages/przemek/
java_not_really_faster_than_cpp.html.
Christian Felde, ‚ÄúC++ vs Java performance; It's a tie!,‚Äù Available:
http://blog.cfelde.com/2010/06/c-vs-java-performance.
Lasse K√§rkk√§inen, ‚ÄúYet Another Java vs. C++ Shootout,,‚Äù Available:
http://zi.fi/shootout.
Keith, ‚ÄúThe Java is Faster than C++ and C++ Sucks Unbiased
Benchmark,‚Äù Available: http://keithlea.com/javabench.


** android ndk ieee suoria l‰hteit‰

@incollection {dba,
   author = {Batyuk, Leonid and Schmidt, Aubrey-Derrick and Schmidt, Hans-Gunther and Camtepe, Ahmet and Albayrak, Sahin},
   affiliation = {Technische Universit‰t Berlin 10587 Berlin Germany},
   title = {Developing and Benchmarking Native {Linux} Applications on {Android}},
   booktitle = {MobileWireless Middleware, Operating Systems, and Applications},
   series = {Lecture Notes of the Institute for Computer Sciences, Social Informatics and Telecommunications Engineering},
   editor = {Bonnin, Jean-Marie and Giannelli, Carlo and Magedanz, Thomas and Akan, Ozgur and Bellavista, Paolo and Cao, Jiannong and Dressler, Falko and Ferrari, Domenico and Gerla, Mario and Kobayashi, Hisashi and Palazzo, Sergio and Sahni, Sartaj and Shen, Xuemin (Sherman) and Stan, Mircea and Xiaohua, Jia and Zomaya, Albert and Coulson, Geoffrey},
   publisher = {Springer Berlin Heidelberg},
   isbn = {978-3-642-01802-2},
   keyword = {Computer Science},
   pages = {381-392},
   volume = {7},
   abstract = {Smartphones get increasingly popular where more and more smartphone platforms emerge. Special attention was gained by the open source platform Android which was presented by the Open Handset Alliance (OHA) hosting members like Google, Motorola, and HTC. Android uses a Linux kernel and a stripped-down userland with a custom Java VM set on top. The resulting system joins the advantages of both environments, while third-parties are intended to develop only Java applications at the moment. In this work, we present the benefit of using native applications in Android. Android includes a fully functional Linux, and using it for heavy computational tasks when developing applications can bring in substantional performance increase. We present how to develop native applications and software components, as well as how to let Linux applications and components communicate with Java programs. Additionally, we present performance measurements of native and Java applications executing identical tasks. The results show that native C applications can be up to 30 times as fast as an identical algorithm running in Dalvik VM. Java applications can become a speed-up of up to 10 times if utilizing JNI.},
   year = {2009},
   file = {dev-benchmark-nat-android.pdf}
}

   url = {http://dx.doi.org/10.1007/978-3-642-01802-2_28},
   note = {10.1007/978-3-642-01802-2_28},


-- hyvi‰ l‰hteit‰

@INPROCEEDINGS{leelimnotused,
author={Namseung Lee and Sung-Soo Lim},
booktitle={Embedded Systems for Real-Time Multimedia (ESTIMedia), 2011 9th IEEE Symposium on}, title={A whole layer performance analysis method for Android platforms},
year={2011},
month={oct.},
volume={},
number={},
pages={1},
abstract={ As the products based on Android platform have been widely
                  spread in consumer electronics market, the needs for
                  systematic performance analysis have significantly
                  increased. We implemented a whole layer performance
                  analysis tool set combining and integrating
                  available open source performance analysis
                  tools. Android framework layer profiling is
                  performed DDMS mechanism with a little modification
                  and the kernel layer profiling is based on
                  Ftrace. The reason why we selected Ftrace instead of
                  Oprofile as kernel layer profiler is that the
                  Oprofile often misses the important kernel events to
                  analyze since Oprofile is using purely time-based
                  sampling. While Ftrace provides accuracy in
                  performance profiling, the additional costs to
                  perform kernel events profiling are
                  significant. Therefore, minimizing the profiling
                  cost maintaining the accuracy of event logging has
                  been a primary issue in performance profiling at
                  kernel layer.},
keywords={Android framework layer profiling;Android platform;Dalvik Debug Monitor Server mechanism;Ftrace;consumer electronics market;event logging;kernel layer profiling;open source performance analysis tools;whole layer performance analysis method;consumer electronics;operating system kernels;program debugging;software performance evaluation;},
doi={10.1109/ESTIMedia.2011.6088515},
ISSN={},
file = {06088515.pdf}
}

@INPROCEEDINGS{benchmark-ndk,
author={Cheng-Min Lin and Jyh-Horng Lin and Chyi-Ren Dow and Chang-Ming Wen},
booktitle={Innovations in Bio-inspired Computing and Applications (IBICA), 2011 Second International Conference on},
title={Benchmark {Dalvik} and Native Code for {Android} System},
publisher={IEEE},
year={2011},
month={{Dec.}},
volume={},
number={},
pages={320 -323},
keywords={Android development platform;Android native development kit;Android programming;Android system;C-C++ compiling;Dalvik Java code;Google;native code;performance analysis;test program;C++ language;Java;mobile computing;operating systems (computers);program compilers;program testing;virtual machines;},
doi={10.1109/IBICA.2011.85},
ISSN={},
file={06118781.pdf}
}

- vaikuttaa hyv√§lt√§

@INPROCEEDINGS{kicheol-bad,
author={Ki-Cheol Son and Jong-Yeol Lee},
booktitle={Awareness Science and Technology (iCAST), 2011 3rd
                  International Conference on},
title={The method of {Android} application speed up by using {NDK}},
year={2011},
month={sept.},
volume={},
number={},
pages={382 -385},
abstract={The Android platform is one of the most popular used embedded OS, is mounted on robot, TVs, especially on Smart phones. Because general android applications are developed by the JAVA language, it is very slow in case which requires many calculational operations such as image processing. To overcome these defects, the Android OS is supporting JNI with the Android NDK, which makes available to use the C libraries in the android at application level. Through NDK, the Android applications can approach hardware and is able to developed high speed application. In this paper, we consider that how to enhance performance of the JAVA applications by using the Android NDK. We compared original NyARToolKit, which is augmented reality engine, with the improved NyARToolKit using the NDK. Through this experiment, we confirmed that android application programmers can make their application efficiently by using the NDK. We could increase speed of NyARToolKit by 1.869 times in our experiment. This paper presents a guideline for an effective way to use native code libraries in Android applications.},
keywords={Android NDK;Android application speed up method;C libraries;JAVA language;JNI;Java native interface;NyARToolKit;TV;augmented reality engine;embedded OS;image processing;native code libraries;native development kit;robot;smart phones;C language;Java;augmented reality;operating systems (computers);software engineering;},
doi={10.1109/ICAwST.2011.6163104},
ISSN={},
file={06163104.pdf}}

- kehno, todella kehno
- yll‰oleva poistettu l‰hteist‰

@INPROCEEDINGS{eval-android-ndk,
author={Sangchul Lee and Jae Wook Jeon},
booktitle={Control Automation and Systems (ICCAS), 2010 International Conference on},
title={Evaluating performance of {Android} platform using native {C} for embedded systems},
year={2010},
month={{Oct.}},
publisher={IEEE},
volume={},
number={},
pages={1160 -1163},
abstract={The Android platform used for mobile devices can be applied to embedded systems, such as robot control systems. Developers should create applications by using Java language provided by Android SDK for embedded systems operated via Android platforms. However, in many existing embedded systems, developers have written applications for controlling the system by using C language. Android NDK makes it possible for developers to easily reuse such legacy code written in C/C++ languages. In this paper, we show the difference in terms of performance between an Android application using native code library from C source and an Android application using the same algorithm written in Java language only. We conducted an experiment on five parts: JNI communication delay, integer calculation, floating-point calculation, memory access algorithm, and heap memory allocation algorithm. This paper presents a guideline for an effective way to use native code libraries in Android applications.},
keywords={Android NDK;Android SDK;Android platform;C language;JNI communication delay;Java language;embedded systems;floating-point calculation;heap memory allocation algorithm;integer calculation;memory access algorithm;mobile devices;C language;Java;embedded systems;mobile computing;},
doi={},
ISSN={},
file={05669738.pdf}
}

- todo lue tm√§
- vaikuttaa hyv√§lt√§!

@INPROCEEDINGS{5718811,
author={Kundu, T.K. and Paul, K.},
booktitle={VLSI Design (VLSI Design), 2011 24th International Conference on}, title={Improving Android Performance and Energy Efficiency},
year={2011},
month={jan.},
volume={},
number={},
pages={256 -261},
abstract={Mobile devices and embedded devices need more processing power but energy consumption should be less to save battery power. Google has released an open source platform Android for mobile devices. Android uses new power management framework to save power in mobile devices. Android developers are allowed to build only JAVA applications. In this work, we present benefits of using Android in low power embedded devices. We compared Android JAVA performance with popular Sun embedded JVM running on top of Angstrom linux. Our work shows that Android can be made more energy efficient by improving performance of JAVA applications. We developed a JAVA DSP framework which allows Android JAVA applications to use both ARM amp; DSP parallely and thus improves performance. We also showed, Android can be made more energy efficient by using our developed framework.},
keywords={ARM;Android operating system;Angstrom Linux kernel;Java DSP framework;Java application;Sun embedded JVM;battery power;energy consumption;energy efficiency;low power embedded device;mobile device;open source platform;power management;power saving;processing power;Java;Linux;digital signal processing chips;electronic engineering computing;embedded systems;low-power electronics;mobile radio;operating system kernels;power aware computing;power consumption;public domain software;},
doi={10.1109/VLSID.2011.63},
ISSN={1063-9667},
file={05718811.pdf}}

@INPROCEEDINGS{6163105,
author={Jae Kyu Lee and Jong Yeol Lee},
booktitle={Awareness Science and Technology (iCAST), 2011 3rd International Conference on}, title={Android programming techniques for improving performance},
year={2011},
month={sept.},
volume={},
number={},
pages={386 -389},
abstract={Android has been researched in various mobile device fields such as Smartphone and Tablet PC. In here, we should remember that mobile devices have limited storage and constrained battery life. Therefore, when developers develop applications, they should do efficient programming. In this paper, we have proposed programming guidelines for an effective way to improve performance in Android applications. We have programmed Android applications using Java and Native C, and compared the performance between the two languages. The applications are composed of five categories such as JNI delay, Integer, Floating-point, Memory access algorithm and String processing. By analyzing the results, we propose a more efficient way to program Android applications.},
keywords={Android application programming;Android programming techniques;JNI delay;Java;floating-point;integer;memory access algorithm;mobile device;native C;performance improvement;programming guidelines;smartphone;string processing;tablet PC;C language;Java;operating systems (computers);smart phones;software performance evaluation;},
doi={10.1109/ICAwST.2011.6163105},
ISSN={},
file={06163105.pdf}
}

-plagiaatti? eval-android-ndk

** ffi

@inproceedings{moby-interop-framework,
  author = {Kathleen Fisher and Riccardo Pucella and John Reppy},
  title = {A framework for interoperability},
  booktitle = {Proceedings of the First International
					 Workshop on Multi-Language Infrastructure
					 and Interoperability (BABEL'01)},
  series = {Electronic Notes in Theoretical Computer Science},
  volume = {59},
  issue = {1},
  publisher = {Elsevier Science Publishers},
  address = {New York, NY},
  editor = {Nick Benton and Andrew Kennedy},
  year = {2001},
  month = sep,
  pdf = {2001/babel-interop.pdf},
  abstract = {
    Practical implementations of high-level languages must provide access to libraries and system
    services that have APIs specified in a low-level language (usually C).  An important characteristic
    of such mechanisms is the foreign-interface policy that defines how to bridge the semantic gap
    between the high-level language and C. For example, IDL-based tools generate code to marshal
    data into and out of the high-level representation according to user annotations. The design
    space of foreign-interface policies is large and there are pros and cons to each approach. Rather
    than commit to a particular policy, we choose to focus on the problem of supporting a gamut of
    interoperability policies. In this paper, we describe a framework for language interoperability
    that is expressive enough to support very efficient implementations of a wide range of different
    foreign-interface policies. We describe two tools that implement substantially different policies
    on top of our framework and present benchmarks that demonstrate their efficiency.
  },
  topic = {moby,interop},
  file = {babel-interop.pdf}
}

** jni
ehk√§ t√§rke√§:

@INPROCEEDINGS{6393447,
author={Yeong-Jun Kim and Seong-Jin Cho and Kil-Jae Kim and Eun-Hye Hwang and Seung-Hyun Yoon and Jae-Wook Jeon},
booktitle={Control, Automation and Systems (ICCAS), 2012 12th International Conference on}, title={Benchmarking Java application using JNI and native C application on Android},
year={2012},
month={oct.},
volume={},
number={},
pages={284 -288},
abstract={Android is one of the most widely spread mobile platform. Many people are using Android mobile devices and many developers are creating Android applications at this moment. When developing applications, the differences in performance between Java and C/C++ are a well-known issue. Because this is also true in Android, many Android application developers prefer to use the Android NDK along with Java compared to using only Java language. However, there are certain performance gaps in not only using different programming languages but also in using glibc of a native cross-compiler and bionic libc of the Android NDK. In this paper, we show the difference in performance between Android applications compiled by using a native cross-compiler for ARM and a native shared library through the JNI of the Android NDK. We used Mibench, a representative embedded benchmark suite that can be used freely with no restrictions. As a result, it was found that using the native shared library through the JNI of the Android NDK is faster compared to using the native cross-compiler for ARM in five of six cases.},
keywords={Androids;Benchmark testing;Humanoid robots;Java;Libraries;Smart phones;C++ language;Java;operating systems (computers);program compilers;software libraries;ARM;Android NDK;Android application;Android mobile device;C/C++ language;JNI;Java language;Mibench;bionic libc;embedded benchmark suite;glibc;mobile platform;native cross-compiler;native shared library;programming language;Android;JNI;NDK;benchmark;bionic;glibc;},
doi={},
ISSN={},
file={06393447.pdf}
}

@incollection {springerlink:10.1007/3-540-45591-4_74,
   author = {Murray, Paul and Smith, Todd and Srinivas, Suresh and Jacob, Matthias},
   affiliation = {Silicon Graphics, Inc. Mountain View CA},
   title = {Performance Issues for Multi-language Java Applications},
   booktitle = {Parallel and Distributed Processing},
   series = {Lecture Notes in Computer Science},
   editor = {Rolim, Jos√©},
   publisher = {Springer Berlin / Heidelberg},
   isbn = {978-3-540-67442-9},
   keyword = {Computer Science},
   pages = {544-551},
   volume = {1800},
   url = {http://dx.doi.org/10.1007/3-540-45591-4_74},
   abstract = {The Java programming environment is increasingly being used to build large-scale multi-language applications. Whether these applications combine Java with other languages for legacy reasons, to address performance concerns, or to add Java functionality to preexisting server environments, they require correct and efficient native interfaces. This paper examines current native interface implementations, presents performance results, and discusses performance improvements in our IRIX Java Virtual Machine and Just-In-Time Compiler that have sped up native interfacing by significant factors over previous releases.},
   year = {2000},
   file = {pmjava.pdf}
}

   note = {10.1007/3-540-45591-4 74},


@INPROCEEDINGS{Tan06safejava,
    author = {Gang Tan and Srimat Chakradhar and Raghunathan Srivaths and Ravi Daniel Wang},
    title = {Safe Java native interface},
    booktitle = {In Proceedings of the 2006 IEEE International Symposium on Secure Software Engineering},
    year = {2006},
    pages = {97--106},
    file = {safejni.pdf}
}

@inproceedings{Kondoh:2008:FBJ:1390630.1390645,
 author = {Kondoh, Goh and Onodera, Tamiya},
 title = {Finding bugs in java native interface programs},
 booktitle = {Proceedings of the 2008 international symposium on
 Software testing and analysis},
 series = {ISSTA '08},
 year = 2008,
 isbn = {978-1-60558-050-0},
 location = {Seattle, WA, USA},
 pages = {109--118},
 numpages = 10,
 url = {http://doi.acm.org/10.1145/1390630.1390645},
 doi = {10.1145/1390630.1390645},
 acmid = 1390645,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {java native interface, static analysis, typestate
 analysis},
 file = {p109-kondoh.pdf},
}

@inproceedings{Li:2009:FBE:1653662.1653716,
 author = {Li, Siliang and Tan, Gang},
 title = {Finding bugs in exceptional situations of JNI programs},
 booktitle = {Proceedings of the 16th ACM conference on Computer
 and communications security},
 series = {CCS '09},
 year = 2009,
 isbn = {978-1-60558-894-0},
 location = {Chicago, Illinois, USA},
 pages = {442--452},
 numpages = 11,
 url = {http://doi.acm.org/10.1145/1653662.1653716},
 doi = {10.1145/1653662.1653716},
 acmid = 1653716,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {java native interface, static analysis, taint
 analysis},
 file = {p442-li.pdf}
}


** dalvik jit jne
BibTeX | EndNote | ACM Ref
@inproceedings{Perez:2012:HJC:2380403.2380418,
 author = {Perez, Guillermo A. and Kao, Chung-Min and Chung, Yeh-Ching and Hsu, Wei-Chung},
 title = {A hybrid just-in-time compiler for android: comparing JIT types and the result of cooperation},
 booktitle = {Proceedings of the 2012 international conference on Compilers, architectures and synthesis for embedded systems},
 series = {CASES '12},
 year = {2012},
 isbn = {978-1-4503-1424-4},
 location = {Tampere, Finland},
 pages = {41--50},
 numpages = {10},
 url = {http://doi.acm.org/10.1145/2380403.2380418},
 doi = {10.1145/2380403.2380418},
 acmid = {2380418},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {android, dalvik vm, jit, method-based, trace-based},
 file = {p41-perez.pdf}
}

** energiankulutus


@inproceedings{Furusho:2012:PEP:2307636.2307712,
 author = {Furusho, Hiroki and Hisazumi, Kenji and Kamiyama,
 Takeshi and Inamura, Hiroshi and Nakanishi, Tsuneo
 and Fukuda, Akira},
 title = {Poster: an energy profiler for android applications used in the real world},
 booktitle = {Proceedings of the 10th international conference on
 Mobile systems, applications, and services},
 series = {MobiSys '12},
 year = 2012,
 isbn = {978-1-4503-1301-8},
 location = {Low Wood Bay, Lake District, UK},
 pages = {517--518},
 numpages = 2,
 url = {http://doi.acm.org/10.1145/2307636.2307712},
 doi = {10.1145/2307636.2307712},
 acmid = 2307712,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {energy consumption},
 file = {p517-furusho.pdf},
}

** profilointi

@article{dunlavey,
 author = {Dunlavey, Michael},
 title = {Performance tuning with instruction-level cost derived from call-stack sampling},
 journal = {ACM SIGPLAN Notices},
 issue_date = {August 2007},
 volume = {42},
 number = {8},
 month = aug,
 year = {2007},
 issn = {0362-1340},
 pages = {4--8},
 numpages = {5},
 url = {http://doi.acm.org/10.1145/1294297.1294298},
 doi = {10.1145/1294297.1294298},
 acmid = {1294298},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {bottleneck, call stack sampling, instrumentation, optimization, performance analysis, profiling, software development},
 file = {p4-dunlavey.pdf}
}

@inproceedings{Ansaloni:2010:RDE:1712605.1712616,
 author = {Ansaloni, Danilo and Binder, Walter and
 Villaz\'{o}n, Alex and Moret, Philippe},
 title = {Rapid development of extensible profilers for the
 Java virtual machine with aspect-oriented programming},
 booktitle = {Proceedings of the first joint WOSP/SIPEW
 international conference on Performance engineering},
 series = {WOSP/SIPEW '10},
 year = 2010,
 isbn = {978-1-60558-563-5},
 location = {San Jose, California, USA},
 pages = {57--62},
 numpages = 6,
 url = {http://doi.acm.org/10.1145/1712605.1712616},
 doi = {10.1145/1712605.1712616},
 acmid = 1712616,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {aspect-oriented programming, bytecode
 instrumentation, calling context tree, concurrency,
 java, profiling},
 file = {p57-ansaloni.pdf}
}

-- oleellinen!


@inproceedings{ammons,
 author = {Ammons, Glenn and Ball, Thomas and Larus, James R.},
 title = {Exploiting hardware performance counters with flow and context sensitive profiling},
 booktitle = {Proceedings of the ACM SIGPLAN 1997 conference on Programming language design and implementation},
 series = {PLDI '97},
 year = {1997},
 isbn = {0-89791-907-6},
 location = {Las Vegas, Nevada, USA},
 pages = {85--96},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/258915.258924},
 doi = {10.1145/258915.258924},
 acmid = {258924},
 publisher = {ACM},
 address = {New York, NY, USA},
 file = {p85-ammons.pdf}
}

- ehk√§?



@inproceedings{java-acc,
 author = {Mytkowicz, Todd and Diwan, Amer and Hauswirth,
 Matthias and Sweeney, Peter F.},
 title = {Evaluating the accuracy of {Java} profilers},
 booktitle = {Proceedings of the 2010 ACM SIGPLAN conference on
 Programming language design and implementation},
 series = {PLDI '10},
 year = 2010,
 isbn = {978-1-4503-0019-3},
 location = {Toronto, Ontario, Canada},
 pages = {187--197},
 numpages = 11,
 url = {http://doi.acm.org/10.1145/1806596.1806618},
 doi = {10.1145/1806596.1806618},
 acmid = 1806618,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {bias, observer effect, profiling},
 file = {p187-mytkowicz.pdf}
}


@article{Zhang:2012:SRJ:2365864.2151035,
 author = {Zhang, Yuan and Yang, Min and Zhou, Bo and Yang,
 Zhemin and Zhang, Weihua and Zang, Binyu},
 title = {Swift: a register-based JIT compiler for embedded JVMs},
 journal = {ACM SIGPLAN Notices},
 issue_date = {July 2012},
 volume = 47,
 number = 7,
 month = mar,
 year = 2012,
 issn = {0362-1340},
 pages = {63--74},
 numpages = 12,
 url = {http://doi.acm.org/10.1145/2365864.2151035},
 doi = {10.1145/2365864.2151035},
 acmid = 2151035,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {android, embedded jvm, just-in-time compiler,
 register-based bytecode},
}

@inproceedings{Zhang:2012:SRJ:2151024.2151035,
 author = {Zhang, Yuan and Yang, Min and Zhou, Bo and Yang,
 Zhemin and Zhang, Weihua and Zang, Binyu},
 title = {Swift: a register-based JIT compiler for embedded JVMs},
 booktitle = {Proceedings of the 8th ACM SIGPLAN/SIGOPS conference
 on Virtual Execution Environments},
 series = {VEE '12},
 year = 2012,
 isbn = {978-1-4503-1176-2},
 location = {London, England, UK},
 pages = {63--74},
 numpages = 12,
 url = {http://doi.acm.org/10.1145/2151024.2151035},
 doi = {10.1145/2151024.2151035},
 acmid = 2151035,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {android, embedded jvm, just-in-time compiler,
 register-based bytecode},
 file = {p63-zhang.pdf}
}

@inproceedings{Moret:2011:PBI:1960275.1960292,
 author = {Moret, Philippe and Binder, Walter and Tanter,
 \'{E}ric},
 title = {Polymorphic bytecode instrumentation},
 booktitle = {Proceedings of the tenth international conference on
 Aspect-oriented software development},
 series = {AOSD '11},
 year = 2011,
 isbn = {978-1-4503-0605-8},
 location = {Porto de Galinhas, Brazil},
 pages = {129--140},
 numpages = 12,
 url = {http://doi.acm.org/10.1145/1960275.1960292},
 doi = {10.1145/1960275.1960292},
 acmid = 1960292,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {aspect-oriented programming, bytecode
 instrumentation, dynamic program analysis, java
 virtual machine, mixin layers, modularity
 constructs},
 file = {p129-moret.pdf}
}

@inproceedings{Williams:2002:PSM:584369.584397,
 author = {Williams, Lloyd G. and Smith, Connie U.},
 title = {PASASM: a method for the performance assessment of software architectures},
 booktitle = {Proceedings of the 3rd international workshop on
 Software and performance},
 series = {WOSP '02},
 year = 2002,
 isbn = {1-58113-563-7},
 location = {Rome, Italy},
 pages = {179--189},
 numpages = 11,
 url = {http://doi.acm.org/10.1145/584369.584397},
 doi = {10.1145/584369.584397},
 acmid = 584397,
 publisher = {ACM},
 address = {New York, NY, USA},
 file = {p179-williams.pdf}
}


@article{Husaini:1997:UJN:332100.332105,
 author = {Husaini, S. Fouzi},
 title = {Using the Java Native Interface},
 journal = {Crossroads},
 issue_date = {December 1997},
 volume = 4,
 number = 2,
 month = nov,
 year = 1997,
 issn = {1528-4972},
 pages = {18--23},
 numpages = 6,
 url = {http://doi.acm.org/10.1145/332100.332105},
 doi = {10.1145/332100.332105},
 acmid = 332105,
 publisher = {ACM},
 address = {New York, NY, USA},
 file = {p4-husaini.pdf},
}

@article{Lee:2010:JSD:1809028.1806601,
 author = {Lee, Byeongcheol and Wiedermann, Ben and Hirzel,
 Martin and Grimm, Robert and McKinley, Kathryn S.},
 title = {Jinn: synthesizing dynamic bug detectors for foreign language interfaces},
 journal = {ACM SIGPLAN Notices},
 issue_date = {June 2010},
 volume = 45,
 number = 6,
 month = jun,
 year = 2010,
 issn = {0362-1340},
 pages = {36--49},
 numpages = 14,
 url = {http://doi.acm.org/10.1145/1809028.1806601},
 doi = {10.1145/1809028.1806601},
 acmid = 1806601,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {dynamic analysis, ffi bugs, foreign function interfaces (FFI), java native interface (jni), multilingual programs, python/C, specification, specification generation},
 file = {p36-lee.pdf}
}

@inproceedings{Lee:2010:JSD:1806596.1806601,
 author = {Lee, Byeongcheol and Wiedermann, Ben and Hirzel,
 Martin and Grimm, Robert and McKinley, Kathryn S.},
 title = {Jinn: synthesizing dynamic bug detectors for foreign language interfaces},
 booktitle = {Proceedings of the 2010 ACM SIGPLAN conference on
 Programming language design and implementation},
 series = {PLDI '10},
 year = 2010,
 isbn = {978-1-4503-0019-3},
 location = {Toronto, Ontario, Canada},
 pages = {36--49},
 numpages = 14,
 url = {http://doi.acm.org/10.1145/1806596.1806601},
 doi = {10.1145/1806596.1806601},
 acmid = 1806601,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {dynamic analysis, ffi bugs, foreign function
 interfaces (FFI), java native interface (jni),
 multilingual programs, python/C, specification,
 specification generation},
}

@article{Furr:2008:CTS:1377492.1377493,
 author = {Furr, Michael and Foster, Jeffrey S.},
 title = {Checking type safety of foreign function calls},
 journal = {ACM Trans. Program. Lang. Syst.},
 issue_date = {July 2008},
 volume = 30,
 number = 4,
 month = aug,
 year = 2008,
 issn = {0164-0925},
 pages = {18:1--18:63},
 articleno = 18,
 numpages = 63,
 url = {http://doi.acm.org/10.1145/1377492.1377493},
 doi = {10.1145/1377492.1377493},
 acmid = 1377493,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {FFI, Foreign function interface, JNI, Java, Java
 Native Interface, OCaml, dataflow analysis,
 flow-sensitive type system, foreign function calls,
 multilingual type inference, multilingual type
 system, representational type},
 file = {a18-furr.pdf}
}

@inproceedings{Makelainen:2008:EIJ:1434790.1434797,
 author = {M\"{a}kel\"{a}inen, Raine and Di Flora, Cristiano
 and Mikkonen, Tommi},
 title = {Enhanced integration of Java to symbian OS using smart pointers},
 booktitle = {Proceedings of the 6th international workshop on
 Java technologies for real-time and embedded
 systems},
 series = {JTRES '08},
 year = 2008,
 isbn = {978-1-60558-337-2},
 location = {Santa Clara, California},
 pages = {38--47},
 numpages = 10,
 url = {http://doi.acm.org/10.1145/1434790.1434797},
 doi = {10.1145/1434790.1434797},
 acmid = 1434797,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {J2ME, Java native interface, Symbian OS, mobile Java
 integration, mobile devices programming},
 file = {p38-makelainen.pdf}
}

@inproceedings{Tan:2007:IIA:1297027.1297031,
 author = {Tan, Gang and Morrisett, Greg},
 title = {Ilea: inter-language analysis across java and c},
 booktitle = {Proceedings of the 22nd annual ACM SIGPLAN
 conference on Object-oriented programming systems
 and applications},
 series = {OOPSLA '07},
 year = 2007,
 isbn = {978-1-59593-786-5},
 location = {Montreal, Quebec, Canada},
 pages = {39--56},
 numpages = 18,
 url = {http://doi.acm.org/10.1145/1297027.1297031},
 doi = {10.1145/1297027.1297031},
 acmid = 1297031,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {JNI, JVML, inter-language analysis, java native
 interface, specification extraction},
}
[download]

@article{Tan:2007:IIA:1297105.1297031,
 author = {Tan, Gang and Morrisett, Greg},
 title = {Ilea: inter-language analysis across java and c},
 journal = {ACM SIGPLAN Notices},
 issue_date = {October 2007},
 volume = 42,
 number = 10,
 month = oct,
 year = 2007,
 issn = {0362-1340},
 pages = {39--56},
 numpages = 18,
 url = {http://doi.acm.org/10.1145/1297105.1297031},
 doi = {10.1145/1297105.1297031},
 acmid = 1297031,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {JNI, JVML, inter-language analysis, java native
 interface, specification extraction},
 file = {p39-tan.pdf}
}

* tilastotiede

@book{probability,
  author    = {Trivedi, Kishor Shridharbhai.},
  title     = {Probability and statistics with reliability, queuing, and computer science applications},
  isbn      = {0-13-711564-4},
  address   = {Englewood Cliffs (NJ)},
  publisher = {Prentice-Hall},
  year      = {1982},
  bibdate   = {20120402221746}
}

@book{sampling,
  author    = {Cochran, William G.},
  title     = {Sampling techniques},
  address   = {New York (NY)},
  publisher = {Wiley},
  year      = {1963},
  annote    = {Keywords: otanta},
  annote    = {Keywords: tilastomenetelm√§t - otanta},
  annote    = {Keywords: tutkimusmenetelm√§t - otanta},
  annote    = {Keywords: todenn√§k√∂isyyslaskenta - otanta},
  annote    = {Keywords: matemaattinen tilastotiede},
  bibdate   = {20120718165924}
}


* erityistarpeisiin


@article{freqscaling,
 author = {Chang, Yu-Ming and Hsiu, Pi-Cheng and Chang, Yuan-Hao and Chang, Che-Wei},
 title = {A Resource-driven {DVFS} Scheme for Smart Handheld Devices},
 journal = {ACM Transactions on Embedded Computing Systems},
 issue_date = {December 2013},
 volume = {13},
 number = {3},
 month = dec,
 year = {2013},
 issn = {1539-9087},
 pages = {53:1--53:22},
 articleno = {53},
 numpages = {22},
 url = {http://doi.acm.org.libproxy.helsinki.fi/10.1145/2539036.2539049},
 doi = {10.1145/2539036.2539049},
 acmid = {2539049},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Android, Energy savings, dynamic voltage/frequency scaling, resource-driven state machines, smart handheld devices},
} 


@www-manual(perfwiki,
 author={Misc.},
 title={Linux kernel profiling with perf},
 year={2016},
 month={elokuu},
 day={17},
 url={https://perf.wiki.kernel.org/index.php/Tutorial},
 valid={20.8.2016}
)


@INPROCEEDINGS{androscope,
author={Myeongjin Cho and Seok Joong Hwang and Ho Jin Lee and Minseong Kim and Seon Wook Kim},
booktitle={Consumer Electronics (ICCE), 2012 IEEE International Conference on}, title={AndroScope for detailed performance study of the {Android} platform and its applications},
year={2012},
month={jan.},
volume={},
number={},
pages={408 -409},
abstract={This paper presents a performance analysis tool for the Android platform and its applications, called AndroScope, which collects performance data from both Dalvik VM and native libraries and provides GUI integrated with the Android SDK.},
keywords={Androids;Humanoid robots;Libraries;graphical user interfaces;mobile computing;operating systems (computers);software libraries;software performance evaluation;AndroScope;Android SDK;Android platform;Dalvik VM;GUI;native libraries;performance analysis tool;performance data collection;virtual machine;},
doi={10.1109/ICCE.2012.6161796},
ISSN={2158-3994},
file = {06161796.pdf}
}


@inproceedings{valgrind,
 author = {Nethercote, Nicholas and Seward, Julian},
 title = {Valgrind: a framework for heavyweight dynamic binary instrumentation},
 booktitle = {Proceedings of the 2007 ACM SIGPLAN conference on Programming language design and implementation},
 series = {PLDI '07},
 year = {2007},
 isbn = {978-1-59593-633-2},
 location = {San Diego, California, USA},
 pages = {89--100},
 numpages = {12},
 url = {http://doi.acm.org/10.1145/1250734.1250746},
 doi = {10.1145/1250734.1250746},
 acmid = {1250746},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Memcheck, Valgrind, dynamic binary analysis, dynamic binary instrumentation, shadow values},
}


@article{showdown,
 author = {Shi, Yunhe and Casey, Kevin and Ertl, M. Anton and Gregg, David},
 title = {Virtual machine showdown: Stack versus registers},
 journal = {ACM Transactions on Architecture and Code Optimization},
 issue_date = {January 2008},
 volume = {4},
 number = {4},
 month = jan,
 year = {2008},
 issn = {1544-3566},
 pages = {2:1--2:36},
 articleno = {2},
 numpages = {36},
 url = {http://doi.acm.org/10.1145/1328195.1328197},
 doi = {10.1145/1328195.1328197},
 acmid = {1328197},
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {Interpreter, register architecture, stack architecture, virtual machine},
}


@www-manual{ios,
  title =        {iOS App Programming Guide},
  OPTkey =       {},
  author =    {{Apple Inc.}},
  OPTorganization = {},
  OPTaddress =   {},
  OPTedition =   {},
  year =      {2016},
  url = {http://developer.apple.com/library/ios/#documentation/iphone/conceptual/iphoneosprogrammingguide/Introduction/Introduction.html},
  OPTnote =      {},
  OPTannote =    {},
  valid = {20.8.2016}
}

todo siisti


* tsekattu, ei niin oleelliset?

@inproceedings{Thakkar:2008:FMB:1383559.1383567,
 author = {Thakkar, Dharmesh and Hassan, Ahmed E. and Hamann,
 Gilbert and Flora, Parminder},
 title = {A framework for measurement based performance modeling},
 booktitle = {Proceedings of the 7th international workshop on
 Software and performance},
 series = {WOSP '08},
 year = 2008,
 isbn = {978-1-59593-873-2},
 location = {Princeton, NJ, USA},
 pages = {55--66},
 numpages = 12,
 url = {http://doi.acm.org/10.1145/1383559.1383567},
 doi = {10.1145/1383559.1383567},
 acmid = 1383567,
 publisher = {ACM},
 address = {New York, NY, USA},
 keywords = {framework, measurement, modeling, performance},
 file = {p55-thakkar.pdf}
}

- pari ok l√§hdett√§, modeling-anti aika pieni

@ARTICLE{970569,
 author = {Liu, Y.A. and Gomez, G.},
 journal = {Computers, IEEE Transactions on},
 title = {Automatic accurate cost-bound analysis for high-level languages},
 year = 2001,
 month = {dec},
 volume = 50,
 number = 12,
 pages = {1295 -1309},
 abstract = {Not available},
 doi = {10.1109/TC.2001.970569},
 ISSN = {0018-9340},
 file = {00970569.pdf},
}


** Journal of Object-Oriented Programming


Library:	 Kumpulan kampuskirjasto, lehdet, ei kotilainaan
Call Number:	 Hs 1A:67-86 Journal of object-oriented programming

Vol. 12, no. 6: Performance: myths, measurements, and morals; Part 1: myths
Vol. 12, no. 7: Performance: myths, measurements, and morals; Part 2: Even easy measurements are hard
Vol. 12, no. 8: Performance: myths, measurements, and morals; Part 3: Quadratic behavior will get you if you don't watch out!
Vol. 12, no. 9: Performance: myths, measurements, and morals; Part 4: How might we speed up a simple program?
Vol. 13, no. 1: Performance: myths, measurements, and morals; Part 5: How not to measure execution time
- puuttuu kirjastosta mutta olisi ollut paras

Vol. 13, no. 2: Performance: myths, measurements, and morals; Part 6: Useful measurements\(emfinally!
Vol. 13, no. 3: Performance: myths, measurements, and morals; Part 7: Detailed measurements of a small program

*** portability

@article{Cusumano:1999:NLC:317665.317678,
 author = {Cusumano, Michael A. and Yoffie, David B.},
 title = {What Netscape learned from cross-platform software development},
 journal = {Commun. ACM},
 issue_date = {Oct. 1999},
 volume = 42,
 number = 10,
 month = oct,
 year = 1999,
 issn = {0001-0782},
 pages = {72--78},
 numpages = 7,
 url = {http://doi.acm.org/10.1145/317665.317678},
 doi = {10.1145/317665.317678},
 file = {p72-cusumano.pdf},
 acmid = 317678,
 publisher = {ACM},
 address = {New York, NY, USA},
}

- K√§yt√§nn√∂n kokemuksia cross-platform-kehityksest√§ + varhaisesta javasta
  - ei JNI-asiaa

* ei miss√§√§n nimess√§

@MISC{Matthews07operationalsemantics,
    author = {Jacob Matthews and et al.},
    title = { Operational Semantics for Multi-Language Programs},
    year = {2007}
}

@InProceedings{effcpp,
 author = {Moss, Darren G.},
 title = {Efficient C/C++ Coding Techniques},
 booktitle = {Embedded Systems Conference Proceedings},
 year = 2001,
 file = {ESC_Boston_01_304_paper.pdf},
}

