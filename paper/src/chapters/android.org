
Kaikki Android-järjestelmään asennettavat tavalliset sovellukset
suoritetaan Dalvik-virtuaalikoneen prosessissa, vaikka ne
sisältäisivätkin natiivikomponentteja. Toki sovelluksen voisi
periaatteessa ohjelmoida vaikkapa C-kielellä komentoriviltä
käynnistettäväksi ohjelmaksi ja kääntää osaksi itse
Android-käyttöjärjestelmää, mutta tällainen sovellus jäisi Androidin
normaalien julkaisukäytäntöjen ulkopuolelle ja siten käyttäjien
ulottumattomiin.
# todo: tarkista native activity

Tehtyjen tutkimusten mukaan natiivikomponenttien käytöstä todella on
suorituskykyhyötyä joissakin tilanteissa: korkean tason kielenä Javan
suoritusmekanismi johtaa yleisrasitteisiin verrattuna suoraan
konekielellä suoritettavaan ohjelmaan. Kuinka siis korkean tason
kielestä on mahdollista siirtyä suorittamaan konekielistä ohjelmaa?
# todo tähän kerää kaikki mittaukset aiheesta

* Java Native Interface ja vieraskutsurajapinnat
/Vieraskutsurajapinta/ (/Foreign Function Interface/) on rajapinta,
jonka kautta korkean tason ohjelmointikielestä käsin voidaan kutsua
matalamman tason kielellä ohjelmoituja aliohjelmia. Java Native
Interface on tällaisen vieraskutsurajapinnan spesifikaatio. Sen avulla
Java-ohjelma voi kutsua C- tai C++-kielellä toteutettuja /natiiveja/
aliohjelmia ja vastaavasti natiiviohjelma voi kutsua Java-ohjelman
metodeita. Tässä yhteydessä kielten luokittelu matalan ja korkean
tason kieliin ei perustu kielen abstraktiomekanismien ilmaisuvoimaan
vaan kielen toteutustapaan: Java on korkean tason kieli, sillä
Java-ohjelmia suoritetaan välikielen muodossa abstraktissa
virtuaalikoneessa eikä suoraan laitteistotason konekielelle
käännettynä.

Vieraskutsurajapinnan toteutuksen on aina huolehdittava seuraavista
tehtävistä:
- kielten erilaisten kutsukäytäntöjen yhteensovittamisesta,
- kutsuparametrien sekä palautusarvojen muuntamisesta lähdekielen
  tyypeistä kohdekielen hyödynnettävissä olevaan muotoon.

# todo: mainitse java-c-spesifit tehtävät vielä toisessa listassa

Lisäksi JNI tarjoaa natiiviohjelmoijalle takaisinkutsurajapinnan,
jonka avulla natiiviohjelmasta voi kutsua Java-ohjelman metodeita ja
lukea Javan tietorakenteita, esimerkiksi olioiden
kenttiä. Ei-primitiivisten tietorakenteiden kuten merkkijonojen ja
taulukoiden käsittelyyn natiiviohjelmassa JNI tarjoaa omat
apufunktionsa.
# lähteet jeannie ja reppy
# vaihtoehdot jni:lle androidissa?

** Natiivirajapinnan suunnitteluperiaatteet
Javan natiivirajapinnan määrittelyssä on tavoiteltu tasapainoa kahden
keskenään ristiriitaisen vaatimuksen kanssa. Toinen on
/binääriyhteensopivuus/: saman binäärimuotoisen natiivikirjaston tulee
toimia eri virtuaalikoneiden kanssa ilman uudelleenkääntämistä.
Tämän vuoksi JNI ei voi tehdä mitään oletuksia virtuaalikoneen
sisäisestä toteutuksesta @@jnibook(145). Periaate on tärkeä ennen
kaikkea siksi, että virtuaalikoneen on aina kyettävä järjestämään
uudelleen omia tietorakenteitaan esimerkiksi automaattisen
muistinhallinnan, JIT-kääntämisen ja erilaisten optimointien
toteuttamiseksi. JNI:tä edeltänyt varhainen Javan
natiivirajapintatoteutus oli suoraviivaisempi ja asettikin rajoituksia
virtuaalikoneen roskienkeruualgoritmeille.

Yhteensopivuuden vaatimus on ristiriidassa toisen keskeisen
vaatimuksen, /hyvän suorituskyvyn/ kanssa. Yhteensopivuus on
mahdollista saavuttaa ainoastaan piilottamalla natiiviohjelman pääsy
virtuaalikoneen tietorakenteisiin abstraktin rajapinnan taakse. Sen
sijaan, että C-kieliselle natiiviohjelmalle välitettäisiin esimerkiksi
osoitin muistialueelle, jonne Java-taulukon alkiot on tallennettu,
natiiviohjelma lukee taulukon alkioita aina natiivirajapinnan
apufunktioiden kautta. Suhteellisen yksinkertaisen
taulukkotietorakenteenkin käsittely natiivikoodissa edellyttää siis
pahimmillaan useita epäsuoria kutsuja JNI:n tarjoaman rajapinnan
ylitse.

Javan natiivirajapinta ei kykene piilottamaan synkronointiongelmia
tilanteessa, jossa virtuaalikoneen ja natiivikomponentin käyttävät eri
säietoteutuksia. Onnistunut rajapinnan ylittävä säikeiden koordinointi
edellyttääkin, että virtuaalikoneen säikeet käyttävät perustanaan
natiivialustan säikeitä. Dalvikin tapauksessa näin onkin; kannattaa
huomata, että natiivimetodit suoritetaan aina
virtuaalikoneenprosessissa ja säikeessä joka natiivikutsun suorittaa.
# todo tarkista vielä lähteestä

** Muistinhallinta natiiviohjelmoinnissa
Yhteensopivuuden takaaminen edellyttää natiivi- ja Java-koodin
erilaisten muistinhallintamenetelmien
yhteensovittamista. Java-komponentti hyödyntää virtuaalikoneen
automaattista roskienkeruuta kun taas natiivikomponentin
muistinhallinta on manuaalista. Tämä aiheuttaisi ongelmia, jos
toisella puolella rajapintaa allokoidun tietorakenteen rajallinen
elinkaari estäisi toisella puolella tapahtuvan rakenteen käsittelyn.

Primitiivityyppiset muuttujat välitetään arvoina rajapinnan yli, joten
ongelmaksi jäävät viitteet allokoituihin rakenteisiin. Kuten mainittu,
viitetyyppiset parametrit kuten taulukot ja olioinstanssit välitetään
natiivikomponentille epäsuorien viitteiden muodossa. Jos
natiivipuolelle välitettyyn olioon ei jää viitteitä Java-puolelle,
saattaisi virtuaalikoneen roskienkeräys poistaa olion. JNI:ssä tämä on
estetty: oletuksena olion olemassaolo taataan natiivimetodin
elinkaaren ajaksi. Pidempiaikaiset viittaukset edellyttävät
natiiviohjelmoijalta eksplisiittistä globaalien viitteiden luomista ja
vapauttamista natiivirajapinnan funktioiden avulla.

Jos taas natiivimetodeita sisältävä Java-luokka määrittelee
/edustaolion/ natiivikomponentin allokoimille tietorakenteille,
edellyttää tämä käytännössä manuaalisen muistinhallinnan käyttämistä
myös Java-ohjelmassa: muistinvarauksen voi kytkeä edustaolion
konstruktoriin, mutta muistin vapauttaminen vaatii Java-luokaltakin
eksplisiittisesti kutsuttavan lopetusmetodin [fn:nativestruct].
# todo: onko finalize  tarpeen joskus?

[fn:nativestruct] JNI ei tarjoa automaattista tukea edustaluokkien
tekemiseen natiivitietorakenteille, vaan ohjelmoijan on itse
määriteltävä sidonnat Java-luokan metodeihin -- aliohjelma eli
natiivimetodi on siis natiivikomponentin ainoa ilmentymä
Java-ohjelmassa.
# huom, vielä ei ole määritelty natiivimetodia

Koska JNI:n määrittely ei ota kantaa virtuaalikoneen sisäiseen
toteutukseen, se ei myöskään määrittele, miten virtuaalikoneen
tarjoama natiivien viitteiden hallinta
toteutetaan. Dalvik-virtuaalikoneen muistinhallinta tukee allokoitujen
kohteiden /kiinnikytkemistä/ (/pinning/) eli niiden roskienkeruun
estämistä, mutta JNI sallii virtuaalikoneelle myös mahdollisuuden
/kopioida/ roskienkerääjän kohtaaman kohteen arvo natiivikomponenttia
varten. Tästä seuraisi merkittäviä suorituskykyrasitteita, mitä
kysymystä tutkimme myöhemmässä vaiheessa.
# todo: huom ! tämän takia yksittäiset olioviitteet pitää yksitellen poimia
# taulukoista

# todo : allokointi suomeksi?


# entäs threadit?

Seuraavaksi käyn yksityiskohtaisemmin läpi, miten natiivirajapinnan
palveluita käytetään ja kommentoin alustavasti palveluiden
potentiaalisia suorituskykyrasitteita.

** Natiivirajapinnan käyttöönotto
Javan natiivirajapinta tukee kahdenlaista integraatiota
natiivikomponentin ja virtuaalikoneen välillä. Ensimmäisessä
vaihtoehdossa suorituksen kontrolli on Java-kielisellä sovelluksella
joka kutsuu silloin tällöin /natiivikirjaston/ tarjoamia palveluita
@@jnibook(5). Toisessa vaihtoehdossa pääsovellus toteutetaan matalan
tason kielellä, ja sovellukseen /upotetaan/ Java-virtuaalikone, jonka
avulla sovellus voi suorittaa Java-kielisiä ohjelmia.

Android-sovellusohjelmat ovat aina lähtökohtaisesti Java-kielellä
toteutettuja, joten ainoastaan ensimmäinen integraatiomekanismi on
käytettävissä. Käytännössä nativiikirjasto otetaan Java-sovelluksen
käyttöön seuraavasti.
# lähde embedded

Natiiivimetodi esitellään Java-kielessä luokan sisällä, kuten
tavallista, mutta sen määreeksi lisätään varattu sana
~native~. Esittely riittää, eikä metodille anneta toteutusta
Java-luokan sisällä. Seuraava esimerkki kuvaa tilannetta
@@jnibook(13).

#+begin_src java -n -r
class HelloWorld {
    private native void print(int num); (ref:nativedecl)
    public static void main(String[] args) {
        new HelloWorld().print(5);
    }
    static {
        System.loadLibrary("HelloWorld"); (ref:loadlib)
    }
}
#+end_src
Natiivin metodin ~print~ (rivi [[(nativedecl)]]) toteutus on osa
kirjastoa, joka on ladattava erillisellä ~System.loadLibrary~
-kutsulla rivillä [[(loadlib)]]. Tässä lataaminen tapahtuu /staattisessa
alustuslohkossa/ ennen luokan ~HelloWorld~ lataamista.

Javan käännöstyökalut tulostavat natiivimetodeja sisältävän
luokkamäärittelyn perusteella C-otsaketiedoston, joka sisältää
natiivimetodia vastaavan C-kielisen funktion esittelyn. Tästä
huolehtii komento ~javah -jni HelloWorld~, joka ottaa syötteekseen
luokkatiedoston. Rivin [[(nativedecl) ]] natiivimetodia vastaavan funktion
esittely otsaketiedostossa näyttää seuraavalta.

#+begin_src c 
JNIEXPORT void JNICALL
Java_HelloWorld_print (JNIEnv *, jobject, jint);
#+end_src

Ensimmäinen ~JNIEnv~ -tyyppinen parametri on mukana kaikissa
natiivimetodeissa. Se on natiivirajapinnan suorituskontekstia edustava
tietue, jonka kautta natiivirajapinnan palveluita kutsutaan. Tyyppi
~jobject~ on viite ~HelloWorld~-olioon -- kyseessä on ilmentymämetodi,
joka saattaa käyttää ilmentymän palveluita. Luokkametodin tapauksessa
natiivifunktio saisi vastaavasti luokkaa edustavan ~jclass~-tyyppisen
parametrin. Loput funktion parametreista noudattavat natiivimetodille
määriteltyjä kutsuparametreja: ~jint~ vastaa Javan primitiivityyppiä
~int~.

Tässä vaiheessa natiivifunktiolle on vielä kirjoitettava toteutus
C-kielellä ja käännettävä se osaksi dynaamisesti ladattavaa
kirjastoa. Androidin tapauksessa tämä käännösvaihe edellyttää
/ristiinkääntämistä/, koska kohdearkkitehtuurin ARM-arkkitehtuuri ja
suoritusympäristö eroavat kehitysympäristön vastaavista. Käännösvaiheen
yksityiskohdista huolehtivat Androidin Native Development Kit
-työkalut yhdellä komentorivikäskyllä ~ndk-build~.
# todo käännös ristiinkääntäminen? parempi käännös?
# todo: lisää tähän c++-eroavaisuudet
# todo: mainitse Android.mk?
# todo: mainitse jni.h, ym.

Lopputuloksena on Java-ohjelma, joka voi kutsua natiivimetodia aivan
kuin se olisi tavallinen Java-metodi. Kutsun toteuttamisesta ja sen
edellyttämistä argumenttien muunnoksista vastaa virtuaalikoneen
toteutus. Seuraavaksi esitellään oleelliset tietotyypit ja palvelut,
joita JNI-ohjelmoinnissa käytetään.

** Tietotyypit



** Rajapintaoperaatiot

