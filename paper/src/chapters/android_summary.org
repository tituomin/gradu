
Annan aluksi lyhyen yleiskuvauksen Android-järjestelmästä ennen
siirtymistä tutkielman varsinaiseen aiheeseen, suorituskyvyn
mittaamiseen ja mallintamiseen sekä Androidin Java-natiivirajapintaan [fn:version].

[fn:version] Tämä tutkielma perustuu Androidin versioon 4.1.2.

Android on mobiilikäyttöjärjestelmä, johon kuuluu oma versionsa
Linux-käyttö\-jär\-jes\-tel\-mä\-y\-ti\-mes\-tä. Siinä on mukana
joitakin mobiililaitteille räätälöityjä ominaisuuksia, jotka
esimerkiksi vähentävät muistin- ja virrankulutusta.

Kokonaisuutena Android ei muistuta tyypillistä Linux-pohjais\-ta
työpöytä- tai palvelinkäyttöjärjestelmää. Se on läheisempää sukua
riisutummille /upotetuille/ Linux-järjestelmille, mutta eroaa
niistäkin. Ensinnäkin merkittävä osa sovelluksista ja koko
järjestelmästä on ohjelmoitu Javalla ja suoritetaan
virtuaalikoneessa. Järjestelmän rakenne ei muutenkaan noudata
esimerkiksi POSIX-standardia vaan perustuu hajautettuun
komponenttiarkkitehtuuriin, joka on nimeltään /Binder/.
Binder-arkkitehtuurin infrastruktuuri, Dalvik-virtuaalikone sekä suuri
osa järjestelmän matalamman tason palveluista on toteutettu
C++-kielellä.

Seuraava kuva esittää Android-järjestelmän perusosia.

# todo tähän kaavio luultavasti embedded androidista
# todo määrittele upotettu

Kuvan arkkitehtuurikerroksista ylimmät ovat lähimpänä käyttäjää ja
sovellusohjelmoijaa. Suurin osa Android-sovelluksista ohjelmoidaan
Javalla Androidin sovelluskehyksen ohjelmointirajapintaa
käyttäen. Ohjelmointirajapinnan ~android~-nimiavaruuden paketit ovat
varta vasten Androidia varten rakennettuja. Ne päästävät ohjelmoijan
käsiksi käyttöjärjestelmän ja laitteiston palveluihin. Nimiavaruuden
~java~ ohjelmointirajapinta on osajoukko /Java Standard Edition/
-rajapinnasta (Java SE), ja on peräisin /Apache Harmony/ -projektista.
# todo ei sisällä koko SE:tä (lähde: embedded?)

Kaikki Java-ohjelmakoodi käännetään Androidia varten ensin normaaliksi
tavukoodiksi ja siitä Androidin omaksi rekisteripohjaiseksi
~dex~-tavukoodiksi, jota suorittaa Dalvik-virtuaalikone. Dalvikissa
suoritetaan sekä sovellusohjelmat että järjestelmän sisäiset
komponentit -- siltä osin kun ne on toteutettu Javalla.

Android on alusta lähtien suunniteltu tukemaan moniajoa. Jokaista
Android-sovellusta suoritetaan omassa virtuaalikoneessaan ja jokaista
virtuaalikonetta omassa Linux-prosessissaan. Tällä tavoin sovellukset
on eristetty omiin hiekkalaatikoihinsa, ja esimerkiksi sovellusten
käyttöoikeuksista voidaan pitää kirjaa prosessitasolla.

Android-ohjelmointirajapinnan luokat antavat sovellusohjelmoijalle
yksinkertaisen näkymän käyttöjärjestelmän palveluihin. Valtaosa
palveluiden varsinaisesta toteutuksesta kuuluu kuitenkin Androidin
/järjestelmäpalveluihin/ (/system services/), komponentteihin joita
järjestelmä suorittaa omissa palvelinprosesseissaan. Yleensä
sovellusohjelmoija ei kutsu näitä tukipalveluita suoraan, vaan
Android-ohjelmointirajapintojen sisäiset toteutukset kutsuvat niitä
Binderin tarjoaman prosessienvälisen kutsumekanismin avulla
sovelluksen prosessista käsin.

Osa Androidin järjestelmäpalveluista on toteutettu Java-kielellä ja
osa C++-kielellä. Javan natiivirajapinta JNI onkin laajasti käytössä
eri tasoilla Androidin arkkitehtuurissa. JNI esitellään tarkemmin
luvussa 3. Voimme kuitenkin jo nyt havaita, että JNI:tä käytetään
yleisesti järjestelmän sisäisessä toteutuksessa, kun Java-koodista on
kutsuttava matalamman arkkitehtuuritason natiiveja kirjastoja.
Esimerkiksi Binder-kutsumekanismin toteutus on C++-kielinen, mutta
Android sisältää myös Java-rajapinnat Binderin käyttöön. Sisäisesti
nämä Javan Binder-sidonnat on toteutettu Javan natiivirajapinnan
avulla. Niin ikään monet Javalla toteutetut järjestelmäpalvelut
kutsuvat itse natiivikirjastoja JNI:n kautta. Lisäksi jotkut
Android-ohjelmointirajapinnan luokat kutsuvat natiivikirjastoja
suoraan JNI:n avulla ohittaen järjestelmäpalvelutason: esimerkiksi
~Log~-luokka kutsuu suoraan ~liblog~-natiivikirjastoa.
# lähde: binder.pdf
# todo sisäinen viite

Järjestelmäpalveluita matalammalla olevia arkkitehtuuritasoja,
mukaanlukien dynaamisesti ladattavia natiivikirjastoja, en käsittele
sen tarkemmin. Mainittakoon kuitenkin, että Androidin Native
Development Kit -työkalut sisältävät rajapinnat pieneen osajoukkoon
natiivikirjastojen toiminnoista tavallisten C- ja C++
-otsaketiedostojen kautta. Näitä dynaamisesti linkitettyjä
natiivikirjastoja voi siis kutsua suoraan tavallisilla
aliohjelmakutsuilla natiiviohjelmasta käsin, ohittaen
järjestelmäpalvelukerroksen. Androidin Binderiin perustuvaan
komponenttiarkkitehtuuriin ei natiiviohjelmoija pääse
käsiksi. Natiivityökalujen ulottumattomiin jääkin suurin osa Androidin
laajasta toiminnallisuudesta, mutta esimerkiksi peliohjelmointia
varten NDK:n natiivirajapinnat ovat riittäviä. Ne sisältävät muun
muassa tuen OpenGL- ja bittikarttagrafiikalle, ääni- ja
multimediatoimintoja sekä valmiudet laitteen sensorien lukemiseen.

# todo check C - *ja* C++??
# todo check dynamic linking
# emvbedded system services

# Tiivistetysti voidaan sanoa, että Android on Linux-ytimen päälle
# rakennettu hajautettuihin olioparadigmaa noudattaviin komponentteihin
# perustuva käyttöjärjestelmä. Järjestelmän toiminnoista valtaosa on
# toteutettu järjestelmäpalveluina ja sidottu toisiinsa sekä
# sovelluksiin Binder-kutsumekanismilla. Muut käyttöjärjestelmän osat
# toimivat tukena tälle suurelta osin Java-ympäristöön perustuvalle
# järjestelmälle.

# mainitse ndk:n stable apit??

#Java-writ­ten sys­tem ser­vices, for in­stance, very often use JNI to
#com­mu­ni­cate with match­ing na­tive code that in­ter­faces with a
#given ser­vice's cor­re­spond­ing hard­ware.
# lähteestä embedded android

# binder : jokainen jvm omassa prosessissaan!
# system services
# jni
# tsekkaa toimiiko system server omassa yhdessä dalvikissa

