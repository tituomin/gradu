Tässä luvussa esitellään kerätyt mittaustulokset ja koostetaan niistä
alustavat havainnot. Myös mittausten ulkopuolelle jätetyt operaatiot
mainitaan perusteluineen.

# TODO metodisignaturet lisää alle?

Tämän luokittelun lähtökohtana ovat JNI-rajapinnan tarjoamat
funktiot /natiiviohjelmalle/. Kaikkia näitä funktioita kutsutaan
funktiokutsulla, jolla on seuraava C-kielinen rakenne:
\verb|(*env)->|\phi\verb|(*env,| \alpha\verb|);|. Kutsussa \phi
korvataan JNI-funktion nimellä ja \alpha vaadituilla argumenteilla.
~env~ on osoitinmuuttuja JNI-ympäristöön.

Luokittelussa kerrotaan myös, mitä vertauskohtaa kyseiselle
operaatiolle mahdollisesti on käytetty lähtö- ja kohdekielien eri
permutaatiossa.

* Metodien ja funktioiden kutsuminen
Mittausten kannalta keskiössä ovat JNI-natiivirajapinnan kautta
tehtävät aliohjelmakutsut erityyppisillä parametreilla.

Operaatiot suunnassa C \rightarrow Java ovat
1. \verb|Call|\tau\verb|Method|,
2. \verb|CallNonVirtual|\tau\verb|Method| ja
3. \verb|CallStatic|\tau\verb|Method|.

Operaatioista (1) huomioi olion luokkahierarkian eli kutsu sidotaan
oikeaan luokkaan dynaamisesti kuten Javan metodikutsussa. Sen sijaan
(2) kutsuu aina eksplisiittisesti määritellyn luokan metodia. (3)
kutsuu staattista metodia. Variaatioita (1)-(3) vertaillaan
mittauksissa.

Metodien kutsuminen edellyttää aina metoditunnuksen noutamista
~GetMethodID~- ja ~GetStaticMethodID~-kutsuilla. Kuten suositeltu,
palveluita ei mittauksissa kutsuta joka kerta jokaisen metodikutsun
yhteydessä vaan kerran koko mittausta käynnistettäessä (ks. kohta
\label{ref:get-method-id-efficiency}). {{{TODO}}} Metoditunnusten
noudon rasite käsitellään erikseen kohdassa. {{{TODO}}}

Vastinpari suunnassa Java \rightarrow C on ~native~ -metodin
kutsuminen Javasta eli C-ohjelmassa olevan funktion
kutsuminen. Variaatioille (1)--(2) ei ole vastinetta C-kielessä, mutta
~native~-metodin voi merkitä staattiseksi (3). Vastinpari suunnassa
Java \rightarrow Java on normaali metodikutsu. Vastinpari suunnassa C
\rightarrow C on normaali funktiokutsu.

{{{plot(basic-call-int-fit)}}}
{{{plot(basic-call-Object-fit)}}}

Kaikissa tuloksissa ja kaikissa permutaatioissa /vasteaika on
lineaarisesti riippuvainen parametrien määrästä/. Kuitenkin
/viitetyyppisillä parametreilla riippuvuuden kulmakerroin on
suurempi/, eli viitetyyppisen parametrin käsittely näkyy tuloksissa
keskeisenä suorituskykyrasitteena. Tätä havainnollistavat kuvat
\ref{fig:basic-call-int-fit} ja \ref{fig:basic-call-Object-fit},
joissa parametrityyppeinä on ~int~ ja ~Object~.

Kuvissa näkyvät kaikki kutsusuuntien permutaatiot, joten niistä voi
myös hahmottaa eri kutsusuuntien vasteaikojen suhteellisia
eroja. Kuten kohdassa \label{ref:jni-book-estimate} arvioitiin,
Dalvikissakin /kutsut suunnassa {{{permu(Java,C)}}} ovat selvästi
päinvastaista suuntaa nopeampia/: edellisten vasteajat suhteessa
jälkimmäisten aikoihin ovat noin 2--3 -kertaisia. Tämä pätee kaikilla
parametrityypeillä.

Sen sijaan suuntien {{{permu(Java,Java)}}} {{{permu(C,C)}}}
keskinäisestä erosta ei tämän mittauksen perusteella voi tehdä
pitkälle meneviä johtopäätöksiä muun muassa siksi, että
mittausteknisistä syistä Java-lähtösilmukoihin on jouduttu lisäämään
sivuvaikutuksellisia operaatioita, joita ei C-kielisissä silmukoissa
tarvita: C-kääntäjästä on kytketty tarpeettoman koodin optimointi pois
päältä. Kuvista \ref{fig:basic-call-all-types-j-j-fit} ja
\ref{fig:basic-call-all-types-c-c-fit} nähdään kuitenkin näissäkin
kutsusuunnissa lineaarinen riippuvuus, vaikka näin pienillä
vasteajoilla mittaushäiriöt ovat suhteellisesti jo
merkittäviä. Lineaarisen riippuvuuden perusteella Java-kääntäjä tai
Dalvikin JIT-kääntäjä ei ole onnistunut optimoimaan pois tyhjän
metodin kutsua Java-koodista -- juuri ylimääräisen sivuvaikutuksen
takia.

{{{plot(basic-call-all-types-j-j-fit)}}}

{{{plot(basic-call-all-types-c-c-fit)}}}

Kuviin \ref{fig:basic-call-all-types-c-j} ja \ref{fig:basic-call-all-types-j-c} on koostettu eri
parametrityypit suunnissa {{{permu(C,Java)}}} ja {{{permu(Java,C)}}}.
Primitiivi- ja viitetyyppien ryhmittyminen näkyy kuvissa selvästi.

{{{plot(basic-call-all-types-c-j)}}}

{{{plot(basic-call-all-types-j-c)}}}

Yksikielisissä permutaatioissa (kuvat \ref{fig:basic-call-all-types-j-j-fit} ja
\ref{fig:basic-call-all-types-c-c-fit}) ei vastaavaa eroa näy, mutta mielenkiintoisena
yksityiskohtana niissä voidaan havaita 64-bittisten parametrityyppien
~long~ ja ~double~ suurempi rasite 32-bittisessä prosessorissa.

Vasteajat riippuvat siis lineaarisesti parametrien määrästä, mutta
eivät esimerkiksi parametrina välitettävän taulukon koosta, mikä
olisikin odottamatonta koska taulukot välitetään
viiteparametrina. Tämä näkyy esimerkiksi kuvassa \ref{fig:variable-argument-size-j-c}.

{{{plot(variable-argument-size-j-c)}}}

Kutsuprofiilien avulla saadaan lisävalaistusta viiteparametrien
aiheuttamaan suurempaan rasitteeseen sekä JNI-kutsusuuntien
keskinäisiin eroihin.

* Merkkijonojen käsittely

Java-merkkijonojen sisältöä käsitellään natiivikomponentista seuraavilla
operaatioilla. Osoittimen palauttavat operaatiot ovat

1. ~GetStringChars~ ja ~ReleaseStringChars~,
2. ~GetStringCritical~ ja ~ReleaseStringUTFChars~ sekä
3. ~GetStringUTFChars~ ja ~ReleaseStringCritical~.

Kopioivat operaatiot ovat
1. ~GetStringRegion~ ja
2. ~GetStringUTFRegion~.

Tukioperaatiot
1. ~GetStringLength~
2. ~GetStringUTFLength~

Operaatioille ei ole mittauksissa varsinaisia vastinpareja, sillä
kyseessä ovat operaatiot, joita on kutsuttava sen /lisäksi/ että
merkkijonoa varsinaisesti käsitellään natiivikoodissa. Siten
natiivimerkkijonojen käsittely C-kielessä ei vaadi mitään vastaavaa
ylimääräistä operaatiota kuten ei myöskään Java-merkkijonojen
käsittely Java-koodissa vaan kyseessä on nimenomaan

C-merkkijonojen eli ~char~-taulukoiden käsittely
~java.nio.CharBuffer~-olioina Java-koodissa sen sijaan on mahdollista
~Non-blocking IO~-API:n kautta (ks. kohta
\ref{sec:measurement-classification-nio}), jos ~CharBuffer~-olio
luodaan Java-komponentissa ja välitetään JNI:n kautta
natiivikomponentille. Tällöin JNI:n merkkijononkäsittelyoperaatioiden
aiheuttamaa rasitetta vastaa oikeastaan yksi natiivimetodikutsu
yhdistettynä JNI:n NIO-operaatioon
\path{GetDirectBufferAddress}. ~CharBuffer~-oliossa on myös metodit
Java-merkkijonon (~String~) sisällön tehokkaaseen kopioimiseen olioon.

# TODO puuttuu sellaisenaan counterparteista (voiko komposoida?)

# #+CAPTION: Merkkijonon käsittelyn vertailukohdat
# #+LABEL: tab-string-counter
# |   | Java \rightarrow C | C \rightarrow C | Java \rightarrow Java |   |
# |---+--------------------+-----------------+-----------------------+---|
# | / | <                  |                 | >                     |   |
# | a | b                  | c               |                       |   |
# |   |                    |                 |                       |   |

# Vertailukohtia: normaalin taulukon lukeminen

# TODO: copyUTF O^2? -- mikä on arvo parametrilla 0?

Vasteaikamittauksista huomataan ensinnäkin, että osoitinoperaatiot,
jotka välittävät viittauksen suoraan virtuaalikoneen sisäiseen
Unicode-tietorakenteeseen, eivät ole riippuvaisia merkkijonon
pituudesta (ks. kuva \ref{fig:special-calls-c-j-fit}). Tämä on
odotetusten mukaista, sillä operaatiossa välitetään vain osoite
merkkijonoon. Myös Unicode-merkkijonon pituuden selvitys on
vakiollinen operaatio, oletettavasti koska merkkijonon pituus on
tallessa Java-merkkijonon sisäisessä toteutuksessa.

# {{{plot(54)}}}
{{{plot(special-calls-c-j-fit)}}}

Sen sijaan UTF-muunnoksen tekevä osoitinoperaatio on riippuvainen
kohteen koosta. Se on myös operaatio, joka johtaa Dalvikin allokoimaan
muistia muunnettua merkkijonoa varten. Näin ollen kuvan
\ref{fig:aplot-8} vasteajat on mitattu pienillä lähtösilmukan
kierrosmäärillä ja vasteaikojen suhdeluku aikaisempiin on 3:5000.

# TODO kuva puuttuu yltä

Samoin kopioivat operaatiot ovat lineaarisesti raskaampia kopioitavan
kohteen koon kasvaessa, mutta tässäkin tapauksessa Unicode \rightarrow
UTF-8 -muunnos on merkittävästi raskaampi kuin pelkkä Unicode-merkkien
kopiointi. Näin ollen kuvassa \ref{fig:special-calls-utf-c-j-fit} merkkijonon koon
selvittäminen UTF-8-koodauksessa on raskaampi operaatio kuin Unicode-
merkkijonon kopioiminen.

# todo: miten viitata alloc-plotteihin?

# {{{plot(56)}}}
{{{plot(special-calls-utf-c-j-fit)}}}

* Taulukoiden käsittely

Taulukoiden käsittely on täysin analogista merkkijonojen käsittelyn
kanssa. Osoittimen palauttavat operaatiot ovat:

1. \verb|Get|\tau\verb|ArrayElements| ja \verb|Release|\tau\verb|ArrayElements|
2. ~GetPrimitiveArrayCritical~ ja ~ReleasePrimitiveArrayCritical~

Operaatioiden nimessä \tau korvataan jollakin Javan
primitiivityypeistä. Viitetyyppisten taulukoiden elementtejä voi
käsitellä vain yksi kerrallaan operaatioilla ~GetObjectArrayElement~
ja ~SetObjectArrayElement~.

Kopioivat operaatiot ovat:

1. ~Get~\(\tau\)\verb|ArrayRegion| ja
2. \verb|Set|\(\tau\)\verb|ArrayRegion|

Suoria vertailukohtia näillekään operaatioille ei ole muissa
kutsusuunnissa kuin C \rightarrow Java, jälleen kerran
lukuunnottamatta ~NIO~-rajapintaa (kohta
\ref{sec:measurement-classification-nio}), jonka avulla natiivi- ja
Java-komponentit voivat myös käsitellä samaa muistialuetta.

* Non-blocking I/O
\label{sec:measurement-classification-nio}

Javan standardikirjaston paketin ~java.nio~ luokka ~ByteBuffer~ antaa
joitakin lisämahdollisuuksia datan siirtoon Java- ja
natiivikomponenttien välillä. ~ByteBuffer~-olio edustaa jatkuvaa
muistialuetta jota voi käsitellä tehokkaasti molemmissa komponenteissa.

Jos ~ByteBuffer~-on allokoitu /suorana/ (/direct/), virtuaalikone
yrittää taata, että natiivioperaatiot (käyttöjärjestelmän operaatiot
tai JNI-natiivikomponentin suorittamat operaatiot), joita puskurille
suoritetaan, tehdään suoraan samalle muistialueelle, jota
Java-ohjelmakin käsittelee. Sitävastoin epäsuoran puskurin sisältö
saatetaan kopioida erikseen ennen käyttöjärjestelmän
natiivi-I/O-operaatioita. JNI-rajapinta sitä paitsi tarjoaa pääsyn
ainoastaan /suoran/ ~ByteBuffer~-olion muistialueelle, jota voi
käsitellä suoraan osoittimen avulla.

# TODO tähän tarvitaan ehkä viitteitä

Eräs tutkielman päämääristä on hahmottaa, mikä on tehokkain tapa
/välittää dataa/ JNI-rajapinnan yli. Tämän takia
~java.nio.ByteBuffer~-olion käsittelyä Java- ja natiivikomponenteissa
verrataan muihin datanvälitystapoihin: kutsuargumenttien ja
paluuarvojen välitykseen sekä merkkijonojen ja taulukoiden
käsittelyyn. Mittauksen avulla yritetään tutkia esimerkiksi, onko
kokonaisrasitteen kannalta tehokkaampaa välittää rajapinnan yli viite
taulukkoon vai ~ByteBuffer~-olioon. Tässä täytyy huomioida niin
viitteen välityksen, tarvittavien tukipalveluiden kuin itse
muistialueen käsittelyn aiheuttamat rasitteet.

Tätä silmälläpitäen täytyy huomioida lisärasite, joka syntyy
seuraavista ~ByteBuffer~-olion käsittelyssä välttämättömien
JNI-palveluiden kutsumisesta. Funktiolla \path{NewDirectByteBuffer}
luodaan natiivikomponentista suora tavupuskuri /valmiiksi allokoituun
muistialueeseen/. Jos taas puskuri on luotu Java-komponentissa, sen
edustaman muistialueen saa \path{GetDirectBufferAddress}-kutsulla ja
kapasiteetin \path{GetDirectBufferCapacity}-kutsulla.

* Kenttien käsittely
** Ilmentymän kentät                                                                           :dep:
*** DONE GetFieldID                                                                         :search:
*** DONE COUNTERPOINT Get<type>Field Routines
    skip others than J target, because
    aim of measuring is to measure the jni call
    overhead, which doesn't exist for j2c, c2c
    - [X] C2J
    - [X] J2J
    - [ ] J2C
    - [ ] C2C
*** COUNTERPOINT Set<type>Field Routines
    - [X] C2J
    - [X] J2J
    - [ ] J2C
    - [ ] C2C
** Staattiset kentät                                                                           :dep:
*** DONE GetStaticFieldID                                                                   :search:
*** COUNTERPOINT GetStatic<type>Field Routines
    - [X] C2J
    - [X] J2J
    - [ ] J2C
    - [ ] C2C
*** COUNTERPOINT SetStatic<type>Field Routines
    - [X] C2J
    - [X] J2J
    - [ ] J2C
    - [ ] C2C
* Olioiden käsittely
** DONE GetObjectClass                                                                        :read:
* Muistia varaavat operaatiot
** DONE AllocObject                                                                          :alloc:
** DONE NewObject, NewObjectA, NewObjectV                                              :comp2:alloc:

** DONE NewString                                                                            :alloc:
** DONE NewStringUTF                                                                         :alloc:

** DONE NewObjectArray                                                                       :alloc:
** DONE New<PrimitiveType>Array Routines                                                     :alloc:
* Paikalliset ja globaalit viitteet
** Local References
*** DONE PushLocalFrame                                                             :comp1:allocref:
*** DONE PopLocalFrame                                                              :comp1:allocref:
* Poikkeukset
** DONE ExceptionCheck                                                                        :read:
* Luokkien käsittely                                                                 :exclude:maybe:
** DONE FindClass                                                             :exclude:maybe:search:
* Sivuutetut operaatiot
** Olioiden käsittely
*** EXCLUDE GetObjectRefType                                                                  :read:
*** EXCLUDE IsInstanceOf                                                             :read:traverse:
*** EXCLUDE IsSameObject                                                                      :read:
** Viitteet
*** Global References
**** EXCLUDE NewGlobalRef                                                                       :gc:
**** EXCLUDE DeleteGlobalRef                                                                    :gc:
*** Local References
**** EXCLUDE EnsureLocalCapacity                                                          :allocref:
**** EXCLUDE NewLocalRef                                                         :comp1:gc:allocref:
**** EXCLUDE DeleteLocalRef                                                      :comp1:gc:allocref:

*** Weak Global References                                                            :unclear:rtfm:
**** EXCLUDE NewWeakGlobalRef                                                             :allocref:
**** EXCLUDE DeleteWeakGlobalRef                                                          :allocref:

** Luokkien käsittely                                                                :exclude:maybe:
*** EXCLUDE DefineClass                                                                    :exclude:
*** EXCLUDE GetSuperclass                                                   :exclude:maybe:traverse:
*** EXCLUDE IsAssignableFrom                                                :exclude:maybe:traverse:

** Natiivimetodien rekisteröinti
*** EXCLUDE RegisterNatives                                                                :exclude:
*** EXCLUDE UnregisterNatives                                                              :exclude:
** Rinnakkaisohjelmointi
*** EXCLUDE MonitorEnter                                                                     :synch:
*** EXCLUDE MonitorExit                                                                      :synch:

** Poikkeukset
*** DONE ExceptionCheck                                                                       :read:
*** EXCLUDE Throw                                                                          :special:
*** EXCLUDE ThrowNew                                                                 :special:alloc:
*** EXCLUDE ExceptionOccurred                                                                 :read:
*** EXCLUDE ExceptionClear
*** EXCLUDE ExceptionDescribe                                                              :exclude:
*** EXCLUDE FatalError                                                                     :exclude:

** Reflektio                                                                               :exclude:
*** EXCLUDE FromReflectedMethod
*** EXCLUDE FromReflectedField
*** EXCLUDE ToReflectedMethod
*** EXCLUDE ToReflectedField
** Java VM-rajapinta                                                             :exclude:
*** EXCLUDE GetJavaVM                                                                      :exclude:
** Versiotiedot                                                                            :exclude:
*** EXCLUDE GetVersion                                                                     :exclude:
*** EXCLUDE Constants                                                                      :exclude:



   1 sivu\newline 3. 2. 2014

   Mittausten ulkopuolelle jääneet JNI-funktiot perusteluineen.
   - Natiivimetodien rekisteröinti
   - Luokkaoperaatiot
   - Reflektio
   - Virtuaalikone ja versiontarkistus


   
* Vasteaikamittaukset
   5 sivua\newline 17. 2. 2014

   Raakatulokset.

* Kutsuprofiilit
   5 sivua\newline 24. 2. 2014

   Raakatulokset.

* Yhteenveto tuloksista
   3 sivua\newline 10. 3. 2014

   Molempien mittausmenetelmien tulosten yhdistäminen.
