Tässä luvussa esitellään kerätyt mittaustulokset ja koostetaan niistä
alustavat havainnot. Myös mittausten ulkopuolelle jätetyt operaatiot
mainitaan perusteluineen.

# TODO metodisignaturet lisää alle?

Tämän luokittelun lähtökohtana ovat JNI-rajapinnan tarjoamat
funktiot /natiiviohjelmalle/. Kaikkia näitä funktioita kutsutaan
funktiokutsulla, jolla on seuraava C-kielinen rakenne:
\verb|(*env)->|\phi\verb|(*env,| \alpha\verb|);|. Kutsussa \phi
korvataan JNI-funktion nimellä ja \alpha vaadituilla argumenteilla.
~env~ on osoitinmuuttuja JNI-ympäristöön.

Luokittelussa kerrotaan myös, mitä vertauskohtaa kyseiselle
operaatiolle mahdollisesti on käytetty lähtö- ja kohdekielien eri
permutaatiossa.

* Metodien ja funktioiden kutsuminen
Mittausten kannalta keskiössä ovat JNI-natiivirajapinnan kautta
tehtävät aliohjelmakutsut erityyppisillä parametreilla.

Operaatiot suunnassa C \rightarrow Java ovat
1. \verb|Call|\tau\verb|Method|,
2. \verb|CallNonVirtual|\tau\verb|Method| ja
3. \verb|CallStatic|\tau\verb|Method|.

Operaatioista (1) huomioi olion luokkahierarkian eli kutsu sidotaan
oikeaan luokkaan dynaamisesti kuten Javan metodikutsussa. Sen sijaan
(2) kutsuu aina eksplisiittisesti määritellyn luokan metodia. (3)
kutsuu staattista metodia. Variaatioita (1)-(3) vertaillaan
mittauksissa.

Metodien kutsuminen edellyttää aina metoditunnuksen noutamista
~GetMethodID~ ja ~GetStaticMethodID~-kutsuilla. Kuten suositeltu,
palveluita ei mittauksissa kutsuta joka kerta jokaisen metodikutsun
yhteydessä vaan kerran koko mittausta käynnistettäessä (ks. kohta
\label{ref:get-method-id-efficiency}).

Vastinpari suunnassa Java \rightarrow C on ~native~ -metodin
kutsuminen Javasta eli C-ohjelmassa olevan funktion
kutsuminen. Variaatioille (1)--(2) ei ole vastinetta C-kielessä, mutta
~native~-metodin voi merkitä staattiseksi (3).

Vastinpari suunnassa Java \rightarrow Java on normaali
metodikutsu. Vastinpari suunnassa C \rightarrow C on normaali
funktiokutsu.

** Vasteajat

Kaikissa tuloksissa ja kaikissa permutaatioissa /vasteaika on
lineaarisesti riippuvainen parametrien määrästä/. Kuitenkin
/viitetyyppisillä parametreilla riippuvuuden kulmakerroin on
suurempi/, eli viitetyyppisen parametrin käsittely näkyy tuloksissa
keskeisenä suorituskykyrasitteena. Tätä havainnollistavat kuvat
\ref{fig:plot-22} ja \ref{fig:plot-18}, joissa parametrityyppeinä on
~int~ ja ~Object~.

{{{plot(22)}}}

{{{plot(18)}}}

Kuvissa näkyvät kaikki kutsusuuntien permutaatiot, joten niistä voi
myös hahmottaa eri kutsusuuntien vasteaikojen suhteellisia
eroja. Kuten kohdassa \label{ref:jni-book-estimate} arvioitiin,
Dalvikissakin /kutsut suunnassa {{{permu(Java,C)}}} ovat selvästi
päinvastaista suuntaa nopeampia/: edellisten vasteajat suhteessa
jälkimmäisten aikoihin ovat noin 2--3 -kertaisia. Tämä pätee kaikilla
parametrityypeillä.

Sen sijaan suuntien {{{permu(Java,Java)}}} {{{permu(C,C)}}}
keskinäisestä erosta ei tämän mittauksen perusteella voi tehdä
pitkälle meneviä johtopäätöksiä muun muassa siksi, että
mittausteknisistä syistä Java-lähdesilmukoihin on jouduttu lisäämään
sivuvaikutuksellisia operaatioita, joita ei C-kielisissä silmukoissa
tarvita: C-kääntäjästä on kytketty tarpeettoman koodin optimointi pois
päältä. Kuvista \ref{fig:plot-52} ja \ref{fig:plot-50} nähdään
kuitenkin näissäkin kutsusuunnissa lineaarinen riippuvuus, vaikka näin
pienillä vasteajoilla mittaushäiriöt ovat suhteellisesti jo
merkittäviä. Lineaarisen riippuvuuden perusteella Java-kääntäjä tai
Dalvikin JIT-kääntäjä ei ole onnistunut optimoimaan pois tyhjän
metodin kutsua Java-koodista.

{{{plot(52)}}}

{{{plot(50)}}}

Kuviin \ref{fig:plot-46} ja \ref{fig:plot-48} on koostettu eri
parametrityypit suunnissa {{{permu(C,Java)}}} ja {{{permu(Java,C)}}}.
Primitiivi- ja viitetyyppien ryhmittyminen näkyy kuvissa selvästi.

{{{plot(46)}}}

{{{plot(48)}}}

Yksikielisissä permutaatioissa (kuvat \ref{fig:plot-50} ja
\ref{fig:plot-52}) ei vastaavaa eroa näy, mutta sinänsä
mielenkiintoisena yksityiskohtana niissä voidaan havaita 64-bittisten
parametrityyppien ~long~ ja ~double~ suurempi rasite 32-bittisessä
prosessorissa.

{{{plot(50)}}}

{{{plot(52)}}}

Vasteajat riippuvat siis lineaarisesti parametrien määrästä, mutta
eivät esimerkiksi välitettävän taulukon koosta, mikä olisikin
odottamatonta. Tämä näkyy esimerkiksi kuvassa \ref{fig:plot-29}.

{{{plot(29)}}}

** Kutsuprofiilit



* Merkkijonojen käsittely

# {{{plot(52)}}}
{{{plot(53)}}}

Java-merkkijonojen sisältöä käsitellään natiivikomponentista seuraavilla
operaatioilla. Osoittimen palauttavat operaatiot ovat

1. ~GetStringChars~ ja ~ReleaseStringChars~,
2. ~GetStringCritical~ ja ~ReleaseStringUTFChars~ sekä
3. ~GetStringUTFChars~ ja ~ReleaseStringCritical~.

Kopioivat operaatiot ovat
1. ~GetStringRegion~ ja
2. ~GetStringUTFRegion~.

Tukioperaatiot
1. ~GetStringLength~
2. ~GetStringUTFLength~

Operaatioille ei ole mittauksissa varsinaisia vastinpareja, sillä
kyseessä on ainoa tapa käsitellä natiivikoodissa Javan
merkkijonoja. C:n merkkijonojen käsittely C-kielessä ei vaadi mitään
vastaavaa ylimääräistä operaatiota kuten ei myöskään
Java-merkkijonojen käsittely Java-koodissa.

C-merkkijonojen eli ~char~-taulukoiden käsittely
~java.nio.CharBuffer~-olioina Java-koodissa sen sijaan on mahdollista
~Non-blocking IO~-API:n kautta (ks. kohta
\ref{sec:measurement-classification-nio}), jos ~CharBuffer~-olio
luodaan Java-komponentissa ja välitetään JNI:n kautta
natiivikomponentille. Tällöin JNI:n merkkijononkäsittelyoperaatioiden
aiheuttamaa rasitetta vastaa oikeastaan yksi natiivimetodikutsu
yhdistettynä JNI:n NIO-operaatioon
\path{GetDirectBufferAddress}. ~CharBuffer~-oliossa on myös metodit
Java-merkkijonon (~String~) sisällön tehokkaaseen kopioimiseen olioon.

# TODO puuttuu sellaisenaan counterparteista (voiko komposoida?)

# #+CAPTION: Merkkijonon käsittelyn vertailukohdat
# #+LABEL: tab-string-counter
# |   | Java \rightarrow C | C \rightarrow C | Java \rightarrow Java |   |
# |---+--------------------+-----------------+-----------------------+---|
# | / | <                  |                 | >                     |   |
# | a | b                  | c               |                       |   |
# |   |                    |                 |                       |   |

# Vertailukohtia: normaalin taulukon lukeminen

# {{{plot(54)}}}
{{{plot(55)}}}

# {{{plot(56)}}}
{{{plot(57)}}}

* plots :noexport:
  {{{plot(41)}}}
  {{{plot(42)}}}
  
  {{{plot(43)}}}
  {{{plot(44)}}}
  
  {{{plot(45)}}}
  # {{{plot(46)}}}
  
  {{{plot(47)}}}
  {{{plot(48)}}}
  
  # {{{plot(05)}}}
  {{{plot(06)}}}
  
  # {{{plot(07)}}}
  {{{plot(08)}}}
  
  # {{{plot(09)}}}
  {{{plot(10)}}}
  
  # {{{plot(11)}}}
  {{{plot(12)}}}
  
  # {{{plot(13)}}}
  {{{plot(14)}}}
  
  # {{{plot(15)}}}
  {{{plot(16)}}}
  
  # {{{plot(17)}}}
  {{{plot(18)}}}
  
  \clearpage
  Some separating text.
  
  # {{{plot(19)}}}
  {{{plot(20)}}}
  
  # {{{plot(21)}}}
  {{{plot(22)}}}
  
  # {{{plot(23)}}}
  {{{plot(24)}}}
  
  {{{plot(25)}}}
  # {{{plot(26)}}}
  
  {{{plot(27)}}}
  # {{{plot(28)}}}
  
  \clearpage
  Some separating text.
  
  {{{plot(29)}}}
  # {{{plot(30)}}}
  
  {{{plot(31)}}}
  # {{{plot(32)}}}
  
  {{{plot(33)}}}
  # TODO maybe linespoints above
  # {{{plot(34)}}}
  
  {{{plot(35)}}}
  # {{{plot(36)}}}
  
  {{{plot(37)}}}
  # {{{plot(38)}}}
  
  \clearpage
  Some separating text.
  
  {{{plot(39)}}}
  # {{{plot(40)}}}
  
  \clearpage
  Some separating text.
  
  # TODO bars
  {{{plot(49)}}}


  \clearpage
  # {{{plot(50)}}}
  # explode 51 : group according to below ...?
  {{{plot(51)}}}
  \clearpage
  
  
  {{{rotated_plot(58)}}}

* Taulukoiden käsittely

Taulukoiden käsittely on täysin analogista merkkijonojen käsittelyn
kanssa. Osoittimen palauttavat operaatiot ovat:

1. \verb|Get|\tau\verb|ArrayElements| ja \verb|Release|\tau\verb|ArrayElements|
2. ~GetPrimitiveArrayCritical~ ja ~ReleasePrimitiveArrayCritical~

Yllä \tau korvataan jollakin Javan
primitiivityypeistä. Viitetyyppisten taulukoiden elementtejä voi
käsitellä vain yksi kerrallaan operaatioilla ~GetObjectArrayElement~
ja ~SetObjectArrayElement~.

Kopioivat operaatiot ovat:

1. ~Get~\(\tau\)\verb|ArrayRegion| ja
2. \verb|Set|\(\tau\)\verb|ArrayRegion|

Suoria vertailukohtia näillekään operaatioille ei ole muissa
kutsusuunnissa kuin C \rightarrow Java, jälleen kerran
lukuunnottamatta ~NIO~-rajapintaa (kohta
\ref{sec:measurement-classification-nio}), jonka avulla natiivi- ja
Java-komponentit voivat myös käsitellä samaa muistialuetta.

* Non-blocking I/O
\label{sec:measurement-classification-nio}

Javan standardikirjaston paketin ~java.nio~ luokka ~ByteBuffer~ antaa
joitakin lisämahdollisuuksia datan siirtoon Java- ja
natiivikomponenttien välillä. ~ByteBuffer~-olio edustaa jatkuvaa
muistialuetta jota voi käsitellä tehokkaasti molemmissa komponenteissa.

Jos ~ByteBuffer~-on allokoitu /suorana/ (/direct/), virtuaalikone
yrittää taata, että natiivioperaatiot (käyttöjärjestelmän operaatiot
tai JNI-natiivikomponentin suorittamat operaatiot), joita puskurille
suoritetaan, tehdään suoraan samalle muistialueelle, jota
Java-ohjelmakin käsittelee. Sitävastoin epäsuoran puskurin sisältö
saatetaan kopioida erikseen ennen käyttöjärjestelmän
natiivi-I/O-operaatioita. JNI-rajapinta sitä paitsi tarjoaa pääsyn
ainoastaan /suoran/ ~ByteBuffer~-olion muistialueelle, jota voi
käsitellä suoraan osoittimen avulla.

# TODO tähän tarvitaan ehkä viitteitä

Eräs tutkielman päämääristä on hahmottaa, mikä on tehokkain tapa
/välittää dataa/ JNI-rajapinnan yli. Tämän takia
~java.nio.ByteBuffer~-olion käsittelyä Java- ja natiivikomponenteissa
verrataan muihin datanvälitystapoihin: kutsuargumenttien ja
paluuarvojen välitykseen sekä merkkijonojen ja taulukoiden
käsittelyyn. Mittauksen avulla yritetään tutkia esimerkiksi, onko
kokonaisrasitteen kannalta tehokkaampaa välittää rajapinnan yli viite
taulukkoon vai ~ByteBuffer~-olioon. Tässä täytyy huomioida niin
viitteen välityksen, tarvittavien tukipalveluiden kuin itse
muistialueen käsittelyn aiheuttamat rasitteet.

Tätä silmälläpitäen täytyy huomioida lisärasite, joka syntyy
seuraavista ~ByteBuffer~-olion käsittelyssä välttämättömien
JNI-palveluiden kutsumisesta. Funktiolla \path{NewDirectByteBuffer}
luodaan natiivikomponentista suora tavupuskuri /valmiiksi allokoituun
muistialueeseen/. Jos taas puskuri on luotu Java-komponentissa, sen
edustaman muistialueen saa \path{GetDirectBufferAddress}-kutsulla ja
kapasiteetin \path{GetDirectBufferCapacity}-kutsulla.

* Kenttien käsittely
** Ilmentymän kentät                                                                           :dep:
*** DONE GetFieldID                                                                         :search:
*** DONE COUNTERPOINT Get<type>Field Routines
    skip others than J target, because
    aim of measuring is to measure the jni call
    overhead, which doesn't exist for j2c, c2c
    - [X] C2J
    - [X] J2J
    - [ ] J2C
    - [ ] C2C
*** COUNTERPOINT Set<type>Field Routines
    - [X] C2J
    - [X] J2J
    - [ ] J2C
    - [ ] C2C
** Staattiset kentät                                                                           :dep:
*** DONE GetStaticFieldID                                                                   :search:
*** COUNTERPOINT GetStatic<type>Field Routines
    - [X] C2J
    - [X] J2J
    - [ ] J2C
    - [ ] C2C
*** COUNTERPOINT SetStatic<type>Field Routines
    - [X] C2J
    - [X] J2J
    - [ ] J2C
    - [ ] C2C
* Olioiden käsittely
** DONE GetObjectClass                                                                        :read:
* Muistia varaavat operaatiot
** DONE AllocObject                                                                          :alloc:
** DONE NewObject, NewObjectA, NewObjectV                                              :comp2:alloc:

** DONE NewString                                                                            :alloc:
** DONE NewStringUTF                                                                         :alloc:

** DONE NewObjectArray                                                                       :alloc:
** DONE New<PrimitiveType>Array Routines                                                     :alloc:
* Paikalliset ja globaalit viitteet
** Local References
*** DONE PushLocalFrame                                                             :comp1:allocref:
*** DONE PopLocalFrame                                                              :comp1:allocref:
* Poikkeukset
** DONE ExceptionCheck                                                                        :read:
* Luokkien käsittely                                                                 :exclude:maybe:
** DONE FindClass                                                             :exclude:maybe:search:
* Sivuutetut operaatiot
** Olioiden käsittely
*** EXCLUDE GetObjectRefType                                                                  :read:
*** EXCLUDE IsInstanceOf                                                             :read:traverse:
*** EXCLUDE IsSameObject                                                                      :read:
** Viitteet
*** Global References
**** EXCLUDE NewGlobalRef                                                                       :gc:
**** EXCLUDE DeleteGlobalRef                                                                    :gc:
*** Local References
**** EXCLUDE EnsureLocalCapacity                                                          :allocref:
**** EXCLUDE NewLocalRef                                                         :comp1:gc:allocref:
**** EXCLUDE DeleteLocalRef                                                      :comp1:gc:allocref:

*** Weak Global References                                                            :unclear:rtfm:
**** EXCLUDE NewWeakGlobalRef                                                             :allocref:
**** EXCLUDE DeleteWeakGlobalRef                                                          :allocref:

** Luokkien käsittely                                                                :exclude:maybe:
*** EXCLUDE DefineClass                                                                    :exclude:
*** EXCLUDE GetSuperclass                                                   :exclude:maybe:traverse:
*** EXCLUDE IsAssignableFrom                                                :exclude:maybe:traverse:

** Natiivimetodien rekisteröinti
*** EXCLUDE RegisterNatives                                                                :exclude:
*** EXCLUDE UnregisterNatives                                                              :exclude:
** Rinnakkaisohjelmointi
*** EXCLUDE MonitorEnter                                                                     :synch:
*** EXCLUDE MonitorExit                                                                      :synch:

** Poikkeukset
*** DONE ExceptionCheck                                                                       :read:
*** EXCLUDE Throw                                                                          :special:
*** EXCLUDE ThrowNew                                                                 :special:alloc:
*** EXCLUDE ExceptionOccurred                                                                 :read:
*** EXCLUDE ExceptionClear
*** EXCLUDE ExceptionDescribe                                                              :exclude:
*** EXCLUDE FatalError                                                                     :exclude:

** Reflektio                                                                               :exclude:
*** EXCLUDE FromReflectedMethod
*** EXCLUDE FromReflectedField
*** EXCLUDE ToReflectedMethod
*** EXCLUDE ToReflectedField
** Java VM-rajapinta                                                             :exclude:
*** EXCLUDE GetJavaVM                                                                      :exclude:
** Versiotiedot                                                                            :exclude:
*** EXCLUDE GetVersion                                                                     :exclude:
*** EXCLUDE Constants                                                                      :exclude:



   1 sivu\newline 3. 2. 2014

   Mittausten ulkopuolelle jääneet JNI-funktiot perusteluineen.
   - Natiivimetodien rekisteröinti
   - Luokkaoperaatiot
   - Reflektio
   - Virtuaalikone ja versiontarkistus


   
* Vasteaikamittaukset
   5 sivua\newline 17. 2. 2014

   Raakatulokset.

* Kutsuprofiilit
   5 sivua\newline 24. 2. 2014

   Raakatulokset.

* Yhteenveto tuloksista
   3 sivua\newline 10. 3. 2014

   Molempien mittausmenetelmien tulosten yhdistäminen.
