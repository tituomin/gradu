
Riittävä suorituskyky on keskeinen laatuvaatimus mille tahansa
ohjelmistolle, mutta millä tavalla suorituskykyvaatimukset tulisi
ottaa huomioon ohjelmiston kehitysprosessissa? Ohjelmistotekniikan
kirjallisuudessa kysymykseen on vastattu hyvin eri tavoin.

* Suorituskyvyn saavuttaminen

Donald Knuthilta on peräisin tunnettu lainaus: "Ennenaikainen
optimointi on kaiken pahan alku ja juuri @@goto(268)." 
Käsitellessään *rakenteellisen* ohjelmoinnin periaatteita Knuth korostaa, ettei
# todo: mitä artikkeli itse asiassa käsittelee?
varsinaisessa ohjelmointityössä kannata käyttää aikaa suorituskykyä
parantaviin manuaalisiin optimointeihin ennen kuin ohjelman
suoritusaikaista käyttäytymistä on tutkittu ja löydetty ohjelman
osat, joiden suoritusaika on merkittävä osa ohjelman
kokonaissuoritusajasta.

Periaatteeseen on kaksi syytä. Ensinnäkin ohjelmoijan intuitio johtaa
yleensä harhaan, kun etsitään ohjelman suorituskyvyn kannalta
keskeisiä osia. Lisäksi käsityönä tehdyt optimoinnit tekevät
ohjelmakoodista vaikeammin ymmärrettävää ja ylläpidettävää, joten
niitä kannattaa välttää kaikkialla, missä niitä ei todistetusti
tarvita.

Knuthin tueksi voi nykynäkökulmasta todeta, että
laitteistoarkkitehtuurien, optimoivien kääntäjien, virtuaalikoneiden
ja suoritusympäristön yleisen monimutkaistumisen takia pelkästä
ohjelman lähdekoodista on yhä vaikeampaa suoraan päätellä ohjelman
suoritusaikaista käyttäytymistä @@vertical.

# TODO esimerkki lähteistä (java vertical profiling)
# lisää lähteitä?

Knuthin näkökulma rajottui kuitenkin yksittäisen algoritmin, ohjelman
tai komponentin /ohjelmointiin/. Laajempaa ohjelmistoa rakentaessa
otetaan kantaa myös ohjelmiston konseptuaalisiin vaatimuksiin ja
suunnitellaan ohjelmiston komponenttitason arkkitehtuuri sekä
komponenttien tarkempi rakenne. Oli ohjelmiston tuotantoprosessi miten
inkrementaalinen tahansa, monet varhaiset makrotason ratkaisut
rajoittavat myöhempiä mikrotason ratkaisuita. Merkittäviä
seurannaisvaikutuksia on esimerkiksi

- valituilla ohjelmointikielellä tai -kielillä,
- valmiiden komponenttien ja kirjastojen valinnalla,
- ohjelmiston yleisarkkitehtuurilla ja komponenttien sijoittumisesta
  suoritusympäristön eri osiin,
  
Kaikkia näitä valintoja voi toki periaatteessa muuttaa milloin
tahansa, mutta todellisten projektien rajoitusten takia se on usein
jälkikäteen mahdotonta.
  
# comment: lähde edelliseen?

Suorituskykyvaatimuksien täyttymistä ohjelmistoprosessin näkökulmasta
tavoitellaan /ohjelmistojen suorituskykytekniikan/ alalla (/Software
Performance Engineering/, /SPE/). Se on ohjelmistotekniikan osa-alue,
jossa suorituskykyvaatimukset kvantifioidaan ja otetaan huomioon
vaatimusanalyysistä lähtien aina ylläpitoon asti @@spe(1). Alan
kehittäjän Connie U. Smithin mukaan puutteelliset
suorituskykyominaisuudet ovat olleet keskeisessä osassa
epäonnistuneissa ohjelmistoprojekteissa, ja ne voitaisiin välttää
/mallintamalla/ ohjelmistoja suorituskykynäkökulmasta jo ennen
toteutusvaihetta.

* Suorituskyvyn mittaaminen

Suorituskyky on pohjimmiltaan subjektiivinen käsite, joka kuvastaa,
miten /hyvin/ ohjelmisto toteuttaa tehtävänsä @@ferrari(2). Tässä
tutkielmassa määritellään suorituskyky ohjelmiston laadulliseksi
ominaisuudeksi, joka kuvaa, miten /tehokkaasti/ ohjelmisto toimii
käyttäjän näkökulmasta: miten tyydyttävät sen vasteajat ovat ja miten
tehokkaasti se käsittelee syötedataa.

Jotta järjestelmän suorituskykyä voisi arvioida täsmällisesti, on
käsite purettava kvantitatiivisiksi /mittareiksi/.  Tällaiset mittarit
jakautuvat luokkiin sen mukaan, koskevatko ne järjestelmän
/tuottavuutta/, /responsiivisuutta/ vai valitun ohjelmisto- tai
laitteistoresurssin /käyttöastetta/ @@ferrari(12).

Tässä tutkielmassa käsitellään ensisijaisesti mobiilisovellusten
responsiivisuutta. Sitä arvioidaan mittaamalla /vasteaikaa/: aikaväliä
syötteen saamisesta siihen hetkeen kun ohjelman tai ohjelmakomponentin
tuloste on palautettu käyttäjälle tai kutsuvalle komponentille
@@ferrari(13). Vasteajan perussuure on siis aika, ja vasteaikaa voi
mitata eri kokoluokissa jopa yksittäisestä konekäskystä koko
ohjelmistoon.

Myös tuottavuutta käsitellään tutkielmassa sikäli kuin komponenttien
tuottavuus vaikuttaa käyttäjän kokemiin vasteaikoihin. Tuottavuus
tarkoittaa käsittelytehoa, jolla ohjelma suoriutuu esimerkiksi tietyn
datamäärän tai työkuorman käsittelystä, ja tuottavuusmittarit
ilmaistaan yksiköllä /kuorma aikayksikköä kohti/. Kuormalle ei yleensä
ole löydettävissä universaalia, laitteisto- tai
sovellusalueriippumatonta mittayksikköä @@ferrari(12).

Sama universaalisuusongelma koskee kaikkia suorituskykymittareita;
vaikka suorituskyvyn eri osatekijöitä voi mitata kvantitatiivisilla
mittareilla, niiden objektiivisuus on aina rajallinen. Esimerkiksi
vasteaikamittarit ovat merkityksellisiä vain suhteessa /määriteltyyn/
käyttötapaukseen ja kokonaistyömäärään -- molemmat näistä on hyvin
vaikea luetella tyhjentävästi ja yksikäsitteisesti @@ferrari(14).
Lisäksi moniajojärjestelmän, kuten Android-järjestelmän, kokonaistila
vaikuttaa yksittäisiin mitattuihin vasteaikoihin. Näistä syistä
mittariksi tulee ottaa vasteaikojen tilastollinen jakauma tietyn
ajanjakson sisällä ja tietyn käyttötapausluokan sisällä, jotta
vaihtelut molempien suhteen voidaan otetaan huomioon tilastollisesti
@@ferrari(14--15).

Objektiivisuuden puute voi vaikeuttaa tulosten tieteellistä
toistettavuutta. Käytännön kehitystyössä se ei aina ole ongelma, sillä
tiettyjä mittaustuloksia hyödynnetään aina suhteessa kulloisiinkin
/tavoitteisiin/ @@ferrari(todo: sivut).

# käsittele lyhyesti (max 2 kpl) O-algoritmianalyysi




#Näinkin rajattuna käsite on
#riippuvainen käyttäjän tarpeista ja siten ohjelmiston vaatimuksista
# @@todo(2--4).

#Tuottavuuteen liittyy
# todo 

# probleemi: subjektiivisuus vs. mitattavuus. tästä löytyy matskua. :)
# ferrari luku 5.2.3


