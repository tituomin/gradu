
Riittävä suorituskyky on keskeinen laatuvaatimus mille tahansa
ohjelmistolle, mutta miten suorituskyky tulisi ottaa huomioon
ohjelmiston kehitysprosessissa? Ohjelmistotekniikan kirjallisuudessa
kysymykseen on vastattu hyvin eri tavoin.

* Suorituskyvyn hallinta tuotantoprosessissa

Donald Knuthilta on peräisin tunnettu lainaus: "Ennenaikainen
optimointi on kaiken pahan alku ja juuri @@goto(268)."  Knuth
korostaa, ettei varsinaisessa ohjelmointityössä kannata käyttää aikaa
suorituskykyä parantaviin manuaalisiin optimointeihin, ennen kuin
ohjelman suoritusaikaista käyttäytymistä on tutkittu ja löydetty
ohjelman osat, joiden suoritusaika on merkittävä osa ohjelman
kokonaissuoritusajasta.
# todo: mitä knuthin artikkeli itse asiassa käsittelee?

Periaatteeseen on kaksi syytä. Ensinnäkin ohjelmoijan intuitio johtaa
yleensä harhaan, kun etsitään suorituskykyyn eniten vaikuttavia
ohjelman osia. Toiseksi äärimmilleen optimoitu ohjelmakoodi on
vaikeammin ymmärrettävää ja ylläpidettävää, joten on perusteltua
jättää suurin osa ohjelmakoodista selkeämmäksi suorituskyvyn
kustannuksella.

Knuthin tueksi voi nykynäkökulmasta todeta, että
laitteistoarkkitehtuurien, optimoivien kääntäjien, virtuaalikoneiden
ja suoritusympäristön yleisen monimutkaistumisen takia pelkästä
ohjelman lähdekoodista on yhä vaikeampaa suoraan päätellä ohjelman
suoritusaikaista käyttäytymistä @@vertical, @@appel.

# TODO esimerkki lähteistä (java vertical profiling)
# lisää lähteitä?

Knuthin näkökulma rajoittui kuitenkin yksittäisen algoritmin, ohjelman
tai komponentin /ohjelmointiin/. Laajaa ohjelmistoa rakentaessa
otetaan kantaa myös ohjelmiston käsitteellisiin vaatimuksiin ja
suunnitellaan ohjelmiston komponenttitason arkkitehtuuri sekä
komponenttien tarkempi rakenne. Oli ohjelmiston tuotantoprosessi miten
inkrementaalinen tahansa, varhaiset suuren mittaluokan ratkaisut
rajoittavat usein myöhempiä yksityiskohtia. Merkittäviä
seurannaisvaikutuksia on esimerkiksi käytetyillä ohjelmointikielillä,
käytetyillä valmiskomponenteilla ja ohjelmakirjastoilla sekä
ohjelmiston yleisarkkitehtuurilla. Esimerkiksi
asiakas-palvelin-arkkitehtuurissa on valittava, sijoitetaanko tietty
toiminto palvelin- vai asiakaskomponenttiin. Androidin tapauksessa
vastaava valinta koskee sitä, sijoitetaanko toiminto hallittuun
ympäristöön (Java-ohjelma virtuaalikoneessa) vai natiiviympäristöön
(natiivikirjasto).

Kaikkia näitä valintoja voi toki periaatteessa muuttaa milloin
tahansa, mutta todellisten projektien rajoitusten takia se on usein
jälkikäteen mahdotonta.

# comment: lähde edelliseen?

Suorituskykyvaatimusten täyttymistä ohjelmistoprosessin näkökulmasta
tavoitellaan /ohjelmistojen suorituskykytekniikan/ alalla (/Software
Performance Engineering/, /SPE/). Se on ohjelmistotekniikan osa-alue,
jossa suorituskykyvaatimukset kvantifioidaan ja otetaan huomioon
vaatimusanalyysistä lähtien aina ylläpitoon asti
@@spe(1). Puutteelliset suorituskykyominaisuudet ovat usein olleet
keskeisessä osassa epäonnistuneissa ohjelmistoprojekteissa @@runaway
ja suorituskykytekniikan kehittäjän Connie U. Smithin mukaan ne
voitaisiin usein välttää /mallintamalla/ ohjelmistoja
suorituskykynäkökulmasta jo ennen toteutusvaihetta.

# todo tähän skeptinen lausahdus
\todo{<<necessary-section>>}

Suorituskykyä käsittelevä kirjallisuus keskittyykin usein joko
myöhäisen vaiheen diagnosointiin mittausten avulla tai ohjelmiston
mallintamiseen varhaisessa kehitysvaiheessa
@@future-spe(172). Mittaamista voidaan tehdä vasta, kun ohjelmisto tai
sen osa on jo olemassa. Mallintamista hankaloittaa puolestaan, että
käyttökelpoiselta mallilta vaaditaan abstraktisuutta ja
yksinkertaisuutta, mutta samalla riittävää /tarkkuutta/ suhteessa
määriteltyyn syötejoukkoon sekä reunaehtoihin ollaakseen /validi/
@@ferrari(161--162).

Mittaus- ja mallintamisnäkökulmaa ei ole saatu yhdistettyä toisiinsa
riittävän yleispätevästi @@future-spe(172). Tämän tutkielman
lähestymistapana on rajata näkökulma spesifisti Java-virtuaalikoneen
ja natiivikoodin väliseen viestintään ja konstruoida yksinkertaistettu
malli natiivirajapinnasta mittausten perusteella. 

Seuraavaksi käsittelemme tutkielmassa käytettyjä
suorituskykymittareita yleisellä tasolla, ohjelmiston suorituskyvyn
mittaamiseen käytettäviä konkreettisia tekniikoita, ja lopuksi itse
mittauskohteena olevaa ohjelmistoa sekä mittausten järjestämiseen ja
tulosten tulkintaan liittyviä haasteita.

# todo kaikki 

* Suorituskykymittarit
# todo: arvioiminen &mallintaminen vs. mittaaminen/mittari
# todo: another indice: memory use!
# (kielenkäyttö)
Suorituskyky on pohjimmiltaan subjektiivinen käsite, joka ilmaisee,
miten /hyvin/ järjestelmä toteuttaa tehtävänsä @@ferrari(2). Tässä
tutkielmassa suorituskyky määritellään ohjelmiston laadulliseksi
ominaisuudeksi, joka kuvaa, miten /nopeasti/ ohjelmisto toimii
käyttäjän näkökulmasta: miten tyydyttävät sen vasteajat ovat ja miten
tehokkaasti se käsittelee syötedataa.

Ohjelmiston tehokkuus ja nopeus kuvaavat sen käyttäytymistä /ajan
suhteen/, mihin myös tutkielma keskittyy. Toinen keskeinen
suorituskykymittareiden luokka tutkii ohjelmiston /muistinkäyttöä/
@@ferrari(457). Tässä tutkielmassa aikaulottuvuus on ensisijainen ja
sitä tutkitaan kvantitatiivisesti; mobiilisovellusten muistinkulutus
on toki oleellinen suorituskykytekijä, mutta tutkimme ainoastaan sen
vaikutuksia sovelluksen ajalliseen käyttäytymiseen.

Jotta järjestelmän suorituskykyä voisi arvioida täsmällisesti, käsite
on purettava kvantitatiivisiksi /mittareiksi/. Näitä ovat järjestelmän
/tuottavuus/, /responsiivisuus/ ja /käyttöaste/
@@ferrari(12). Tutkielmassa mittari tarkoittaa suorituskyvyn
kvantitatiivisia osatekijöitä, oli ne sitten johdettu ohjelmistoa
kuvaavista malleista tai saatu todellisista mittauksista.

Tutkielmassa keskitytään mobiilisovellusten responsiivisuuteen. Sitä
arvioidaan /vasteajalla/: aikavälillä syötteen saamisesta siihen
hetkeen, kun ohjelman tai ohjelmakomponentin tuloste on palautettu
käyttäjälle tai kutsuvalle komponentille @@ferrari(13). Vasteajan
perussuure on aika. Vasteaikamittauksen mittauskohteen suuruusluokka
voi vaihdella jopa yksittäisestä konekäskystä ohjelmiston suorittamaan
pitkäkestoiseen, käyttäjälle näkyvään toimintoon.

Myös tuottavuutta käsitellään tutkielmassa, sillä komponenttien
tuottavuus vaikuttaa käyttäjän kokemiin vasteaikoihin. Tuottavuus
tarkoittaa käsittelytehoa, jolla järjestelmä suoriutuu tietyn
työkuorman (/workload/) käsittelystä, ja tuottavuusmittarit ilmaistaan
yksiköllä /kuorma aikayksikköä kohti/. Kuormalle ei yleensä ole
löydettävissä universaalia, laitteisto- tai sovellusalueriippumatonta
mittayksikköä @@ferrari(12). Työkuorman mallintaminen onkin keskeisiä
haasteita suorituskyvyn arvioinnissa @@spe(115), @@ferrari(221).
# todo oikea syntaksi monelle viitteelle?

* Mittausmenetelmät

Seuraavaksi käsittelemme ohjelmiston vasteaikojen mittaamiseen
käytettäviä konkreettisia mittausmenetelmiä, joilla saadaan mitattua
kokonaisvasteaikoja sekä vasteaikojen jakautumista ohjelmiston eri
osiin.

** Vasteajan mittaaminen

Tietyn operaation kokonaisvasteajan mittaaminen on käsitteellisesti
yksinkertaista: mitataan aikaväli syötteen saamisesta siihen hetkeen,
kun haluttu tulos on tulostettu käyttäjälle.
# lähde: ferrari alkusivut? spe-book?
Toisaalta vuorovaikutteisen sovelluksen suorittaman laskennan ja
käyttäjän syötteiden vuorottelu voi olla vilkasta. Käyttäjän toiminta
on usein samanaikaista järjestelmän laskennan kanssa. Käyttäjän
harkinta- ja reagointiviiveet eivät ole osa vasteaikaa, joten
vuorovaikutukset on mittausta varten eriteltävä riittävän
yksinkertaisiin mitattaviin yksiköihin, joissa käyttäjän ja
sovelluksen roolit on erotettavissa @@ferrari(14--16), @@spe(114).
# todo footnote mainitse että järjestelmä-käyttäjä-parin 
# tehokkuuden arviointi / käytettävyys jää tämän ulkopuolelle

Käyttöjärjestelmän erilaiset keinot mitata aikaa koskevat erilaisia
osia kokonaisvasteajasta. Järjestelmän käyttäjä voi mitata
sekuntikellolla operaatioihin objektiivisesti kuluvaa kokonaisaikaa,
/tosiaikaa/ (/real time/, /wall clock time/) @@ferrari(463),
@@advanced-unix(20). UNIX-käyttöjärjestelmissä tosiaikaa mittaa
järjestelmäkutsu =gettimeofday= @@advanced-unix(173), joka lukee
laitteiston kelloa. Jos sovellusohjelma kutsuu sitä tavallisena
käyttöjärjestelmäkutsuna, saattaa ohjelman suoritus häiriintyä
tarkkuutta vaativissa mittauksissa @@ferrari(472). Tässä tutkielmassa
kyseistä rutiinia käytetään ainoastaan niin pitkien
kokonaisvasteaikojen mittaamiseen, ettei käyttöjärjestelmäkutsujen
aiheuttamilla häiriöillä ole merkitystä. Moniajojärjestelmissä
tosiaikaa käyttävät mittaukset ovat myös riippuvaisia järjestelmän
kokonaistilasta @@ferrari(455); tutkielman mittauksissa muiden
prosessien määrä pyritään minimoimaan ja niiden vaikutus tulkitaan
mittausten satunnaisvirheeksi.

 Kvantitatiivisten mittausten rinnalla kannattaa pitää mielessä
käyttäjän subjektiivinen kokemus: käyttäjä voi kokea jopa yhtäsuuriksi
mitatut vasteajat erilaisiksi, jos esimerkiksi työn etenemistä
osoittava käyttöliittymäelementti etenee eri tavalla @@progressbar.
# todo luetaan piiriin
# todo tarkista onko androidissa tarkka userspace gettimeofday (arm)
# todo tosiaika?


# todo lue ja varmista että lähde progressbar sanoo näin ;) ^

# [fn:gettimeofday] Joissakin laitteistoissa kyseistä Linuxin palvelua
# voi kutsua vähäisellä rasitteella siirtymättä kernelin suoritustilaan.
# lähde vdso etc. sitten vasta julkiseksi todo

Tässä tutkielmassa kaikki suorituskykyä parantavat ratkaisut
tavoittelevat ohjelman /vasteaikojen lyhentämistä tosiaikana
mitattuna/. Tarkemman suorituskykyanalyysin kannalta pelkkä tosiajan
käyttäminen ei kuitenkaan aina ole riittävää. UNIX-käyttöjärjestelmät
pitävät kirjaa myös /sovellusajasta/ (/user time/) eli ajasta, jonka
sovellusprosessi viettää aktiivisesti tavallisessa suoritustilassa
käyttöjärjestelmäytimen ulkopuolella (/unprivileged mode/, /user
mode/) @@advanced-unix(20). Toinen osa sovellusprosessin
suoritusajasta, järjestelmäaika (/system time/), vietetään
käyttöjärjestelmäytimen sisällä palveluissa, joita sovellus on
eksplisiittisesti kutsunut.
# todo lähteet + lievennä Linux-spesifisyys
# todo kuvaa ferrarin termeillä?

Aika, joka kuluu erilaisia palveluita odottaessa, lasketaan tosiaikaan
muttei sovellus- tai järjestelmäaikaan. Käyttäjän kannalta esimerkiksi
I/O-operaatioiden odottelulla on selvästi suuri merkitys. Sovellus- ja
järjestelmäaika yhdessä vastaavat sovelluksen /suoritinaikaa/ (/CPU
time/), koska niihin kuuluu ainoastaan prosessin aktiivinen
suoritusaika @@advanced-unix(20). Tutkielmassa oletetaan, että
suoritinaika on natiivirajapinnan rasitteiden oleellisin osatekijä,
sillä rajapintatoteutus oleellisesti käsittelee keskusmuistissa ja
rekistereissä olevaa dataa ja tietorakenteita ja pitää niistä
kirjaa. Tosiaikaa mittaamalla varmistetaan kuitenkin, etteivät
suoritinajan ulkopuoliset merkittävät viiveet jää huomiotta.

# Kuten aina, vasteaikojen mittaamisen kohde on aina
# ohjelma--syöte -pari, joten sopivien syötteiden käyttäminen
# mittauksissa on tärkeää @@ferrari(455).

** Vasteajan jakautuminen
Kokonaisvasteajalla on merkitystä ohjelmiston käyttäjälle sekä
tulosten lopullisessa validoinnissa. Tarkempi suorituskykyanalyysi
vaatii kuitenkin tuekseen yksityiskohtaisempia mittauksia. Niiden
tavoite on purkaa vasteaika osiin ja tunnistaa ohjelman osat, joiden
suorituksella on kokonaisuuden kannalta suurin vaikutus
@@ferrari(455--456).

Yksittäisen ohjelmiston ajonaikaista käyttäytymistä on
käytännöllisintä ja järkevintä mitata ohjelmallisesti eikä
erillisillä mittaamiseen käytetyillä laitteistolla. Fyysiset
mittauslaitteet ovat tarkkoja ja häiritsevät järjestelmän toimintaa
minimaalisesti, mutta laitteiston tasolla tapahtuvien mikrotason
tapahtumien havaitseminen on käsitteellisesti kaukana ohjelmiston
sisäisestä suorituskontekstista @@ferrari(32). Käytännön
ohjelmistokehityksessä mittauslaitteiden hyödyntäminen ei usein
ole mahdollista.

Mittaustekniikat jakaantuvat menetelmiin, jotka joko /kirjaavat/
(/record/) kiinnostavia /tapahtumia/ tai /tarkkailevat/ (/monitor/)
järjestelmän tai ohjelmiston /tiloja/@@spe(328). Tapahtumien
kirjaaminen tarkoittaa, että aina kiinnostavan tapahtuman esiintyessä
oleellinen informaatio tapahtumasta kerätään ja
tallennetaan. Kirjaamistoimet käynnistetään mitattavan ohjelman omasta
toimesta, kun taas tarkkailussa mittaamisen kontrolli on ohjelman
ulkopuolella esimerkiksi käyttöjärjestelmässä tai
laitteistossa. Tarkkailumenetelmät perustuvat yleensä toistuvaan
/näytteidenottoon/: tasaisin väliajoin, satunnaisin väliajoin tai
tietyn tapahtuman sattuessa otetaan näyte ohjelmiston tilasta. 

Tyypillinen kirjaamismenetelmä on ohjelman /instrumentointi/:
suoritettava ohjelma kirjaa mittauksen kohteena olevat tapahtumat
eksplisiittisillä, ohjelmaan itseensä sisältyvillä käskyillä
@@spe(328).  Keskeinen esimerkki on ohjelman /kutsuprofiilin/
rakentaminen laskemalla jokaisen aliohjelman jokainen kutsu. Näin
tallennetun informaation avulla voidaan suorituksen jälkeen tulostaa
luettelo jokaisesta kutsutusta aliohjelmasta järjestettynä
kutsukertojen mukaan.  Tämän kaltaista instrumentointia ei välttämättä
tarvitse ohjelmoida käsin: kääntäjä voi lisätä instrumentointikäskyjä
kohdeohjelmaan tarvittaessa automaattisesti @@gprof(121).

Ohjelman profiilin käsitteen loi Donald Knuth @@fortran. Alunperin se
tarkoitti taulukkoa ohjelman jokaisen lauseen /suorituskerroista/;
nykyisessä käytössä ja tässä tutkielmassa profiloinnilla tarkoitetaan
yleisemmin sellaista ohjelman suorituskäyttäytymisen mittaamista,
jossa tuloksena on esitys mittausarvojen jakautumisesta ohjelman eri
osille, yleensä aliohjelmille. Suorituskertojen sijaan usein tutkitaan
osien suoritukseen käytettyä aikaa. Se hyödyntää usein
instrumentoinnin sijaan tai sen lisäksi näytteenottomenetelmiä ja
tutkii yleensä ohjelman suoritusaikaa aliohjelmien tarkkuudella.
# todo profile kutsu vs lausetason?  plus lähde tähän
# knuth irrallinen > siirrä myöhemmäksi

Näytteenoton tavoite on kerätä ohjelman suoritustiloista edustava
otanta kirjaamatta jokaista tilanmuutosta ohjelman sisältä käsin
@@spe(328).  Yksittäinen näyte voidaan ottaa esimerkiksi
laitteiston tosiaikakellon aiheuttaman keskeytyksen laukaisemana, ja näytteeseen
voidaan tallentaa esimerkiksi suorituksessa olleen konekäskyn osoite.

Instrumentoinnin ja näytteenoton avulla ohjelman suoritusajan
jakautumisesta aliohjelmiin tai jopa yksittäisiin konekäskyihin
voidaan siis periaatteessa saada hyvinkin tarkkoja mittauksia.
Ennenaikaista optimointia loppuun asti vältelleet ohjelmistokehittäjät
voivat näin tutkia vaikkapa, missä aliohjelmissa suoritin viettää
suurimman osan ajastaan. Algoritmeja muuttamalla, tietorakenteita
vaihtamalla tai ohjelmaa muuten muokkaamalla näitä /kuumia kohtia/
(/hot spot/) voidaan optimoida -- tai vähentää niiden kutsukohtia.

*** TODO "käsitteellisesti kaukana ohjelmiston sisäisestä suorituskontekstista" ? JV      :noexport:
    :PROPERTIES:
    :CUSTOM_ID: suorituskonteksti
    :END:
    KOODI SUORITUSKONTEKSTI: suorituskonteksti hyvä pointti mutta ferrari ei sano tuota suoraan
    mainitse että arm-prosessorissa on hardwaretukea asialle


** Mittausten toteuttaminen
Instrumentoitua ohjelmaa voi suorittaa normaalisti samassa
ympäristössä, jossa tuotantosovellukset tavallisestikin suoritetaan
eli Android-laitteessa. Täysipainoinen näytteenotto sen sijaan vaatii
käyttöjärjestelmältä tukea näytteenoton suorittamiselle tiettyjen
laitteistokeskeytysten tapahtuessa. Tämä käyttöjärjestelmän toiminto
pohjautuu laskureihin ja keskeytyksiin, jotka on varta vasten
sisäänrakennettu suorittimiin. Esimerkiksi ARM-suorittimet voi asettaa
laskemaan kuluneita suoritinsyklejä, väärin ennustettuja
suoritushaaroja, muistihakuja sekä muita tapahtumia @@cortex(3-85 -- 3-88). Kun valittu
tapahtumamäärä on ylittynyt, keskeytys käynnistää
käyttöjärjestelmäytimen mittausrutiinin.
# todo arm-lähde (virallinen dokkari)


Vaihtoehto normaalin suoritusympäristön käyttämiselle on
/virtualisointi/, jossa pelkkä sovellus tai koko ohjelmistoympäristö
käyttöjärjestelmineen suoritetaan ohjelmallisessa
virtuaalikoneessa. Tällöin virtuaalikoneeseen voi periaatteessa
ohjelmoida mitä tahansa räätälöityjä mittauksia.[fn:vm] Olen rajannut
virtualisointimenetelmät tutkielman ulkopuolelle, sillä tavallisessa
Android-laitteessa tehtävät mittaukset antavat kaikki tarvittavat
tulokset, ja virtualisoitu suoritusympäristö voi käyttäytymiseltään
erota todellisista laitteista tavoilla, joiden toteaminen kuitenkin
edellyttäisi mittauksia myös todellisessa ympäristössä. [fn:valgrind]
# todo lähde on valgrind ja kirjoita ettei se ole virtualisointia
# vaan dynaamista binääri-instrumentointia !! tärkeä top

Myös Androidin Java-virtuaalikoneessa Dalvikissa on ohjelmien
ajonaikaista käyttäytymistä kirjaavia toimintoja, joiden mittauksiin
Androidin kehitysympäristön suorituskykytyökalut perustuvat
@@aosp. Dalvik mittaa kuitenkin Java-ohjelman metodien sekä
natiivialiohjelmien suoritusaikoja @@android-tracing, @@androscope,
siinä missä tämän tutkielman tarkoituksena on tutkia Dalvikin itsensä
suorituskykyä: Javan natiivirajapinnan toteutus on osa
virtuaalikonetta.

Tutkielman mittaukset suoritetaan näytteenottotekniikalla, Linuxin
/perf/-työkalun avulla @@du(13). Android-laitteeseen on asennettu
räätälöity Linux-ydin, joka tukee suorituskykylaskurien käyttöä. Itse
mittaukset käynnistetään ja raportit tulostetaan ytimen ulkopuolisilla
/perf/-komentorivityökaluilla.

[fn:vm] Esimerkki virtualisoinnista on Androidin oma /emulaattori/,
joka perustuu QEMU-virtuaalikoneeseen. Se on emulaattori, sillä se
mallintaa Androidin laitteistoarkkitehtuuria eri laitteistolla,
tavallisella mikrotietokoneella.
# lähde !!
[fn:valgrind] Sovelluksen suorittaminen esimerkiksi
Valgrind-virtuaalikoneessa on merkittävästi normaalia hitaampaa.

** Mittaustekniikoiden valintaperusteista

Eri mittaustekniikoilla on vahvuutensa ja heikkoutensa. Instrumentointi
ei vaadi minkäänlaista erityistukea järjestelmältä, mutta edellyttää
kuitenkin instrumentoitavien ohjelmien uudelleen kääntämistä ja usein
myös niiden muokkaamista käsin. Käsin tai metaohjelmoinnin avulla
lisätyllä instrumentoinnilla saadaan kirjattua yksityiskohtaisinta
tietoa ohjelmiston sisäisestä tilasta ja sovellusaluekohtaisesta
informaatiosta: esimerkiksi siitä, minkä tyyppiset parametrit ovat
yleisimpiä tietyissä kutsuissa tai mihin käyttötapaukseen mitattu
tapahtuma liittyy @@spe(334). Pelkällä kääntäjän lisäämällä
ei-sovelluskohtaisella instrumentaatiolla saadaan myös tietoa, jota ei
muilla tekniikoilla tavoita: jokaisen aliohjelman kutsujen määrä ja
jokaisen kutsun vasteaika.

Instrumentaatio on tavallaan kattavin mittausmenetelmä, sillä
jokaisesta mielenkiintoisesta tapahtumasta saadaan periaatteessa
kirjattua tarvittava informaatio. Erityisesti vasteaikojen suhteen
ongelmaksi kuitenkin muodostuu se, että instrumentointi aina
/häiritsee/ enemmän tai vähemmän suoritettavan ohjelman toimintaa
@@ferrari(44). Toisin sanoen mittauskohteena onkin instrumentoitu eikä
alkuperäinen ohjelma. Jos vasteaikoja mitataan tihein väliajoin
käyttöjärjestelmäkutsulla, joka palauttaa järjestelmän kellon arvon,
saattaa tämä kutsu ja sen aiheuttama prosessin tilamuutos vaikuttaa
ohjelman käyttäytymiseen, vaikka kutsujen suorittamiseen kuluvan ajan
vähentäisikin tuloksista.
# pertrubation problem
# lähteitä ferrari, smith, java vertical profiling?

Toisaalta, jos ohjelmiston suorituskyvyn seuraaminen katsotaan osaksi
sen normaalia toimintaa ja jos instrumentointikäskyt ovat oleellinen osa
tuotantokäytössä suoritettavaa ohjelmistoa, häirinnän ongelma
katoaa. Tämä lienee käytännöllisintä laajoissa palvelinohjelmistoissa
tai käyttöjärjestelmissä -- yksittäisten käyttäjien mobiililaitteissa
suoritettavien sovellusohjelmien jatkuva suorituskykyseuranta ei usein
tule kyseeseen, vaan mahdolliset instrumentointikäskyt poistetaan
tuotantoversiota rakennettaessa.

Häirinnän ongelma on vähäisempi näytteenottotekniikoissa
@@ferrari(478), sillä käyttöjärjestelmä keskeyttää ohjelman toiminnan
suhteellisen harvoin, ja näytteenoton aiheuttama häirintä jää
tilastollisesti pieneksi. Näytteenotossa tutkittavan ohjelmiston tilaa
pitää kuitenkin tulkita ohjelmiston itsensä ulkopuolelta, joten
käytännössä analyysin pohjana on suorittimen tila
näytteenottohetkellä: erityisesti käskyosoittimen (/program counter/)
sekä pinon sisällöt @@du(3), @@dunlavey(4).

Pelkän käskyosoittimen käyttöä suorituskykyanalyysin perustana on
kritisoitu \linebreak@@dunlavey, @@ammons. Käskyosoitinnäytteiden
avulla saadaan kyllä selville, missä ohjelman osassa suoritin viettää
eniten aikaa. Näin on kuitenkin vaikea hahmottaa laajempaa
suorituskontekstia, joka selittäisi, mistä eniten suoritusaikaa
käyttävää aliohjelmaa on kutsuttu. Suorituskykypullonkaulojen syiden
merkityksellisempi analyysi vaatii lähtökohdakseen oikean
abstraktiotason. 

# dunlavey

Tämän vuoksi käyttökelpoinen näytteenotto vaatii kutsupinon
uudelleenrakentamista pinon sisällöstä otetuista raakanäytteistä.  Nyt
aliohjelman /A/ kustannuksiin voidaan laskea mukaan kaikki näytteet,
joiden kutsupinoissa /A/ esiintyy, vaikka näytteen aikana suoritin
olikin suorittamassa toista aliohjelmaa /C/. Proseduraalisessa
ohjelmointiparadigmassa on nimittäin usein mielekästä nähdä
aliohjelman /A/ ilmentämä abstraktio myös sellaisen laskennan syynä,
joka tapahtuu aliohjelmassa /C/ esimerkiksi kutsuketjun /((A, B), (B,
C))/ välityksellä. Yksinkertaisessa yksisäikeisessä ohjelmassa
pääohjelman kontolle laskettaisiin siis /kaikki/ suoritus. Käytännössä
mielekäs abstraktiotaso näytteiden analyysille löytyy
tilannekohtaisesti jostakin pääohjelman ja suoritettavan kohdan
väliltä kutsupinosta.

Profilointityökaluissa aliohjelman suoritusaikaa kutsutaan usein
/inklusiiviseksi/ \label{sec-profiling-inclusive}, jos siihen lasketaan mukaan myös aliohjelman
kutsumien muiden aliohjelmien ajat @@android-tracing. Pelkkään
käskyosoittimeen perustuva raaka suoritusaika on tässä tutkielmassa
/eksklusiivinen/ suoritusaika, jota usein kutsutaan nimellä /self time/.

# gprof, oprofile, etc.

Näytteenotto ei ole mittausmenetelmänä kytketty tarkalleen tiettyihin
ohjelmakohtiin.  Suorittimen keskeytyksen laukeamisen jälkeen ohjelman
suoritus saattaa edetä joitakin konekäskyjä ennen näytteen ottamista
@@perfwiki. Vaikka periaatteessa työkalut saattavat raportoida jopa
yksittäisten konekäskyjen suhteelliset kustannukset, kannattaa näihin
suhtautua pienellä varauksella. Tällä epätarkkuudella ei ole käytännön
vaikutusta, jos mittauksen kohteena on suurempien kokonaisuuksien kuten
kokonaisten aliohjelmien inklusiiviset suoritusajat.

# oprofile

\todo{<<fix-benchmarking>>}

Tutkielmassa mittauksiin käytetään lähinnä /perf/-työkalun
näytteenottotekniikkaa, sillä siinä mittauskohteena on mahdollisimman
paljon tuotantoversiota vastaava sovellus. Näytteenoton avulla ei
saada selville aliohjelmakutsujen /määriä/, mutta niitä kontrolloidaan
benchmark-mittauksissa mitattavan ohjelmakoodin tasolla.

** Näytteenoton tilastollinen edustavuus
Kaikenlaisessa näytteenotossa on varmistettava, että otanta on
/tilastollisesti edustava/: rajattua /otosta/ tutkimalla on voitava
tehdä päätelmiä koko /perusjoukosta/ @@probability(469). Tässä
tapauksessa haluamme päätellä rajallisesta joukosta ajanhetkiä (otos),
miten käskyosoittimen ja kutsupinon arvot jakautuvat ohjelman koko
suoritusajalle (perusjoukko). Tämä varmistetaan suoritinsyklien
laskemiseen perustuvassa näytteenotossa /systemaattisen otannan/
@@sampling(206) menetelmällä. Siinä jokaisella ajanhetkellä on sama
todennäköisyys tulla valituksi otantaan, sillä näyte otetaan
systemaattisesti tasaisin väliajoin, ja mittaus aloitetaan
satunnaisella ajanhetkellä. Tällöin eri ajanhetkien mittausarvoja ei
tarvitse painottaa suhteessa toisiinsa.
# todo: lue tilastotieteen perusteet ja kirjoita em. kappale paremmin
# ferrari 57-59

Systemaattisen ja jaksollisen näytteenotton suunnittelussa saattaa
kuitenkin sattua erilaisia virheitä, joiden seurauksena tietyt
ajanhetket valitaan otokseen todennäköisemmin kuin toiset. Jos
tutkittavassa prosessissa on jokin jaksollisesti toistuva ilmiö, jonka
kanssa näytteenoton jakso sattuu synkronoitumaan, tulokset
vääristyvät. Esimerkiksi tutkittavassa järjestelmässä saattaa olla
käytössä järjestelmän kelloon perustuvia keskeytyksiä, jotka
laukaisevat tiettyjä toimintoja @@ferrari(58). Huonosti valitulla
näytteenottojaksolla nämä toiminnot yli- tai alikorostuvat
mittauksissa.

# todo selvennä että samplaamme suorittimen tilaa kaikilla
# sykleillä, emme jatkuvassa ajassa

Näytteenoton toteutustavassa saattaa myös olla sisäänrakennettuja
seurausvaikutuksia, joiden takia mittaus jo lähtökohtaisesti painottaa
tiettyjä ajanhetkiä. Koska haluamme tutkia suorittimen tilaa
/tosiajassa/, on varmistuttava, että näytteet jakautuvat tasaisesti
tosiajan suhteen. Esimerkiksi monet yleisesti käytetyt Java-profilointityökalut
kykenevät saamaan näytteitä ainoastaan ohjelman ns. luovutuskohdista
(/yield point/), eivät mistä tahansa suorituskohdasta @@java-acc(193).

Tutkielman mittauksissa näytteenotto tapahtuu aina, kun ARM-suorittimen
kellosyklejä on tapahtunut ennalta valittu määrä (tapahtuma /cycle
count/ @@cortex(3:86)). Tietokoneen suorittimen kellotaajuus (syklien
määrä sekunnissa) ei kuitenkaan tyypillisesti ole vakio, vaan mukautuu
laskentatarpeeseen @@freqscaling @@cortex-programmer(20:7). Mittauksissa on siis erikseen
asetettava suorittimen kellotaajuus vakioksi, etteivät suuren
kellotaajuuden ajanhetket ylikorostuisi.
# 5 tehdä tilaa, väistyä (liikenteessä)
# yield up
# 1 luovuttaa, luopua
# liitä viite arm-dokkariin

Kannattaa huomata, ettei otannan tarvitse olla satunnainen:
systemaattinen jaksollinen otanta riittää, kunhan on varmistuttu
siitä, ettei perusjoukko sisällä jaksollisia ilmiöitä
@@ferrari(58). Oletamme tässä tutkielmassa, ettei mitattava
järjestelmä sisällä jaksollisia ilmiöitä, joiden jakson pituudella
olisi yhteisiä tekijöitä /n/ suoritinsyklin kuluttaman ajanjakson
kanssa. Varmistumme tästä suorittamalla useita mittauksia, joista
jokainen alkaa satunnaisella ajanhetkellä, ja vaihtelemme jakson
pituutta syklimäärässä.
# todo: analysoi linuxin timeria ja schedulointia..
# todo: onko dalvikissa ym. muissa komponenteissa jaksollisia ilmiöitä?
\newpage
* Mittauskohteen edustavuus ja tulosten yleistettävyys
\label{performance:representativeness-generalization}

Vaikka suorituskyvyn eri osatekijöitä voi arvioida ja mitata
näennäisen tarkoilla kvantitatiivisilla mittareilla, tulosten
objektiivisuus, toistettavuus ja erityisesti yleistettävyys vaatii
mittausjärjestelyn tarkkaa suunnittelua ja tulosten
tulkintaa. Yksittäinen suoritusaikamittaus tuottaa mittausarvon
tietylle /ohjelma--syöte/-parille tietyllä laitteistolla
@@ferrari(455), muttei sinänsä kerro mitään yleistä esimerkiksi juuri
monikielisten Android-ohjelmien ominaisuuksista. Yksittäisen
mittaustulokseen eniten vaikuttavat kausaaliset syyt saattavat olla
kulloisenkin ohjelman, laitteiston tai syötteen sattumanvaraisia
ominaispiirteitä ja toteutusyksityiskohtia.

Esimerkiksi vasteaika ilmaisee aina tietyn operaation vasteajan
tietyllä syötteellä eli kuormituksella, jota on hyvin vaikea
spesifioida tavalla, joka olisi riippumaton käsiteltävän järjestelmän
ominaisuuksista @@ferrari(14).

Nämä seikat vähentävät yksittäisten mittaustulosten
hyötyä. Tarkoistakin mittauksista on vaikeaa tehdä sellaisia päätelmiä
tulosten syistä, jotka voisi yleistää koskemaan muitakin kuin
täsmälleen itse mittaustilanteen kaltaisia tapauksia @@saavedra(69).

\todo{<<käyttötapaus>>}

\todo{<<benchmark>>}
# todo selvennä yllä ja myös alle sama selvennys

Lisäksi moniajojärjestelmän, kuten Android-järjestelmän, kokonaistila
vaikuttaa yksittäisiin mitattuihin vasteaikoihin. Näistä syistä
mittariksi tulee ottaa vasteaikojen tilastollinen jakauma tietyn
ajanjakson sisällä, jotta ympäristöstä aiheutuvat satunnaisvirheet
voidaan ottaa huomioon tilastollisesti @@ferrari(14--15). Silloinkin
ohjelman suoritusaikaan perustuvat mittarit ovat riippuvaisia
järjestelmästä ja laitteistoalustasta, esimerkiksi
mobiililaitemallista ja Android-versiosta @@ferrari(454).

\todo{<<ajattele-uudelleen>>}

# viite: android moniajo
# mainitse vielä mittaus vs. mallinnus

# todo: käsittelee oikeastaan /mittaamisen/ tavoitteita
Yleispätevyyden puute voi vaikeuttaa mittausten ja arvioiden
tieteellistä arvoa. Käytännön kehitystyössä tämä ei välttämättä ole
ongelma, jos tuloksista vedetään vain rajallisia johtopäätöksiä. Kun
tavoitteena on tietyn järjestelmän suorituskyvyn /parantaminen/,
riittää että mittauksista löydetään suorituskyvyn kannalta
ongelmalliset suorituskohdat ja lopullinen
suorituskykyparannus /validoidaan/ vertailemalla alkuperäistä ja muokattua
järjestelmää @@ferrari(336).

# ferrari 224: arvioidaan kriteereitä (workload-) malleille

Jos tavoitteena on uuden ohjelmistojärjestelmän tuottaminen
suorituskykytekniikan menetelmillä, mittauksia käytetään validoimaan
suorituskykyarvioita, jotka on johdettu määrittely- ja
suunnitteluvaiheiden malleista @@spe(18). Ohjelmistoprosessissa näitä
validoituja malleja verrataan lopulta alkuperäisiin
suorituskykyvaatimuksiin, joita niitäkin voidaan joskus jopa muuttaa
@@spe(18). Siten kvantifioidutkin mallit ja mittaukset täytyy lopulta
suhteuttaa ohjelmiston suorituskykyvaatimuksiin ja viime kädessä
käyttäjien subjektiivisiin kokemuksiin.

\todo{<<outo kommentti>>}
# vihavaiselta

# todo: varmista lopuksi että tämä on näin

** Vakioidut mittaukset


Eräs tapa saavuttaa astetta yleispätevämpiä tuloksia
suorituskykymittauksista on laatia mitattavalle järjestelmälle sarja
ennalta laadittuja syötteitä, jotka on suunniteltu edustamaan
todellisuudessa kohdattavia syötteitä tai ovat peräisin todellisista
työkuormista, ja mitata järjestelmän suoriutumista
syötteistä. Kutsumme tätä yleistä menetelmää /vakioiduksi
mittaamiseksi/ (/benchmarking/) @@dependability-benchmarking(69-71),
@@curnow, @@saavedra. Menetelmää voi hyödyntää, kun tutkittava
järjestelmä toteuttaa jonkin spesifikaation tai rajapinnan, joka
mahdollistaa samojen testisyötteiden käytön useiden toteutusten
kanssa. Tällöin järjestelmän tuloksia voi /verrata/ toisten sellaisten
järjestelmien tuloksiin, jotka toteuttavat saman
spesifikaation. Menetelmää käytetään muidenkin kuin
suorituskykyominaisuuksien arvioimiseen. Lisäksi järjestelmien erot
erilaisilla syötteillä tulevat näkyviin ja eroista voi päätellä,
minkälaisia syötteitä mikäkin järjestelmä prosessoi tehokkaasti.

Esimerkiksi tietyn ohjelmointikielen kääntäjille laadittu vakioitu
mittaussarja koostuisi erilaisista tarkkaan valituista käännettävistä
ohjelmista. Vastaavalla menetelmällä voisi tutkia joukkoa
virtuaalikoneita, esimerkiksi eri JVM-toteutusten suoriutumista
JNI-rajapintaa hyödyntävien sovellusten ajamisesta.

Tämän tutkielman kannalta mahdollinen koeasetelma olisi verrata
samankaltaisen sovellusohjelman vaihtoehtoisia versioita, jotka kaikki
toteuttavat saman spesifikaation eli prosessoivat samanmuotoista
dataa. Yksi versio hyödyntäisi laajasti JNI-rajapintaa, toinen olisi
puhdas natiiviohjelma ja kolmas puhdas Java-ohjelma. Asetelman etuna
olisi ohjelmien realistisuus ja testien kokonaisvaltaisuus - toisaalta
esimerkiksi eri tavalla JNI:tä hyödyntävien versioiden tekeminen olisi
hyvin työlästä ei-triviaaleille ohjelmille, ja tulokset saattaisivat
kertoa enemmän käsillä olevien toteutusten ominaispiirteistä kuin
yleispätevästi JNI-rajapinnan käytön vaikutuksesta. Koeasetelma olisi
tavallaan analyyttinen: valmiiden kokonaisten ohjelmien
suorituskykyominaisuudet analysoitaisiin kokonaisuudesta tehtyjen
mittausten perusteella.

** Alkeisoperaatioiden mittaaminen

Toinen, tutkielmassa käytetty lähtökohta JNI:n
suorituskykyominaisuuksien tutkimiseen on ikään kuin synteettinen:
yritämme tutkia JNI-rajapinnan yksittäisten operaatioiden
suorituskykyominaisuuksia ja päätellä niistä, miten osista rakennettu
kokonaisuus mahdollisesti toimisi. Kutsun /alkeisoperaatioiden
mittaamiseksi/ (/microbenchmarking/) tällaista menetelmää, jossa
verrataan kielen tai järjestelmän yksittäisten perusoperaatioiden
rasitteita toisiinsa @@saavedra(347). Menetelmän etuna on, että
mittaustuloksista saadaan periaatteessa suuri määrä suoraviivaisesti
tulkittavaa dataa siitä, mitkä operaatiot ovat suhteessa erityisen
raskaita ohjelmistoissa käytettäviksi. Lähestymistavassa on kuitenkin
myös vakavia puutteita @@goetz-benchmark.

Koska kielen tai järjestelmän alkeisoperaatioiden suoritusaika on
minimaalinen, käytännössä niiden suorituskykyä mitataan toistamalla
operaatioita pitkäkestoisessa silmukassa. Alkeisoperaatioiden
mittaaminen (microbenchmarking) on siis vakioitua mittaamista
(benchmarking), jossa työkuormana on yhtä operaatiota toistava
ohjelma. Koska vakioitujen mittausten työkuormat tulisi suunnitella
edustamaan todellisuudessa kohdattavia ohjelmia
@@dependability-benchmarking(69), ei alkeisoperaatioita mittaamalla
tavoitetta selvästikään saavuteta.

Mittaustavan ongelma johtuu siitä, ettei nykyaikaisessa
suoritusympäristössä alkeisosista c_0 ... c_i koostuvan ohjelman
kokonaissuoritusaikaa voi laskea deterministisesti osien suoritusajan
perusteella @@wilhelm-wcet(5-6). Todellisuudessa suoritusaika riippuu
myös suorittimen sekä ohjelmallisen suoritusympäristön kuten
virtuaalikoneen tiloista.

Suorittimessa tämän epädeterministisyyden aiheuttavat välimuistit,
käskyliukuhihnat (/pipelines/) sekä kontrollivuon ennustaminen
(/branch prediction/) @@cpu-influence(1038),
@@wilhelm-wcet(5-6). Suorittimen välimuistissa olevan datan käyttö on
merkittävästi nopeampaa kuin keskusmuistissa olevan. Se, miten
optimaalisesti suoritin onnistuu välimuistiaan täyttämään, riippuu
kuitenkin järjestelmän toiminnasta kokonaisuudessaan eikä irrallisista
ohjelman osista. Suorittimen käskyliukuhihnat taas mahdollistavat
useamman konekäskyn rinnakkaisen suorittamisen -- menetelmä edellyttää
ohjelman suoritushaarojen ennustamista ja käskyjen aikataulutusta,
mitkä toimivat todennäköisesti eri tavalla todellisessa ohjelmassa
kuin alkeisoperaatiota mittaavassa silmukassa.

Lisää haasteita kohdataan, kun siirrytään astetta korkeammalle,
tarkastelemaan matalan tason kielen kääntäjää. Tyypillisesti
mitattavalla alkeisoperaatiolla ei välttämättä ole sivuvaikutuksia,
joten kääntäjä saattaa optimointina poistaa mitattavan operaation
@@goetz-benchmark. Ratkaisuna on poistaa optimoinnit käytöstä
mittauksia varten -- Java-kääntäjän tapauksessa tämä ei yleensä
kuitenkaan ole yksinkertaista, jolloin mitattavaan koodiin on joskus
keinotekoisesti lisättävä sivuvaikutuksia.

Korkean tason kielellä tehtävät vakioidutkin mittaukset ovat erityisen
virhealttiita, sillä niitä monimutkaistavat /automaattinen
muistinhallinta/, /dynaamisen optimoinnin/ aiheuttama epädeterminismi
sekä /järjestelmän lämmitysviiveet/, jotka johtuvat luokkien
lataamisesta ja JIT-kääntämisestä @@coffee(83). Näiden hallitsemiseksi
on omat mittausmenetelmänsä sekä tilastolliset työkalunsa, joita
käsittelemme tarkemmin luvussa \ref{sec-measurement-setup}.

Tutkielmassa mitataan Dalvik-virtuaalikoneen
Java-natiivirajapintatoteutuksen eri osien suorituskykyrasituksia
suhteessa toisiinsa ja vastaaviin alkeisoperaatioihin Java- ja
C-kielisessä ohjelmassa. Esimerkiksi JNI:n läpi tehtäviä metodikutsuja
verrataan tavallisiin metodikutsuihin Java- ja C-kielissä. Tuloksista
johdetaan tilastollinen malli, joka ennustaa ohjelmiston
JNI-operaatioista aiheutuvia rasitteita eri tilanteissa. Mallin
parametreina ovat kutsuttu JNI-funktio sekä kutsuissa käytettyjen
parametrien määrät ja tyypit.

JNI- ja Java-kutsujen rasitteiden keskinäisestä vertailusta on hyötyä
mille tahansa natiivikomponentteja sisältävälle sovellukselle, koska
sen avulla voidaan välttää tunnettuja ongelmakohtia komponenttien
välisessä kommunikaatiossa. Kysymys, onko natiivirajapinnan käytöstä
ylipäätään etua tietyn sovelluksen suorituskyvylle, saa puolestaan
lisävalaistusta vasta, kun natiivirajapinnasta koituvat kustannukset
suhteutetaan siihen hyötyyn, joka natiivikomponentin käytöstä on
verrattuna vastaavaan Java-komponenttiin.

Tutkielman koeasetelma pyrkii parhaansa mukaan ottamaan huomioon
Java-ym\-pä\-ris\-tös\-sä tapahtuvan mittaamisen haasteet, mutta
jättää osittain lisätutkimuksen aiheeksi, missä määrin mainitut
prosessoriarkkitehtuurin ominaisuudet vähentävät tulosten relevanssia
todellisten sovellusten näkökulmasta. Tulokset ovat siis suuntaa
antavia, mutta lisätukea tulosten oikeellisuudelle antavat kuitenkin
seuraavat huomiot.

1. Pääasiallisena mittauskohteena on C++-kielellä ja konekielellä
   toteutetun Dalvik-virtuaalikoneen sisäiset osat, joihin
   virtuaalikoneen kääntäjän suorittamat optimoinnit eivät ulotu.
   Erityisesti kääntäjä ei voi optimoida JNI-kutsuja pois Java-koodista,
   koska sillä ei ole tietoa natiivikomponentin mahdollisesti
   aiheuttamista sivuvaikutuksista. Vertailukohteena mitattavan puhtaan
   Java-koodin oikeellisuus pyritään tarkistamaan virtuaalikoneen
   kääntäjän välimuistin konekäskyjä tutkimalla.
2. Koska JNI:tä käyttävät ohjelmakohdat rasittavat käytännössä
   pelkästään pienehköä käskyaluetta eli Dalvikin JNI-toteutusta, voidaan
   arvioida, että suorittimen välimuistien ja ennakoivan heuristiikan
   kannalta käyttötapaukset edustavat JNI:n käyttöä tehokkaimmillaan, sillä
   koodin ja datan lokaalisuus on suuri. Saadut tulokset voidaan
   JNI:n osalta tulkita optimistisiksi, mikä huomioidaan tulosten
   arvioinnissa.
3. Koska mittauksissa yhdistetään kokonaisvasteaikojen mittaaminen
   profilointiin, saadaan JNI-toteutuksen suoritusaikaisesta
   käyttäytymisestä yksityiskohtaista tietoa mallien pohjaksi, jolloin
   voimme päätellä, mitkä JNI:n osat ovat suorituskyvyn kannalta kriittisimpiä.
4. Mittauksissa alkeisoperaatioille annettavia mahdollisia parametreja
   varioidaan hallitusti. Yksittäisten epävarmojen vasteaika-arvojen
   sijaan saamme kuvaajia, joissa vasteaika vaihtelee halutun
   muuttujan funktiona. Regressioanalyysin avulla saamme varmistusta
   mittausten oikeellisuudelle, sikäli kuin mittauksissa on näkyvissä
   selviä esimerkiksi lineaarisia korrelaatioita. Yhdistettynä
   profilointiin menetelmillä saadaan joka tapauksessa
   mielenkiintoista tietoa JNI-rajapinnan toiminnasta vähintäänkin
   kvalitatiivisella tasolla, vaikka numeeristen mittausarvojen
   relevanssi jää epävarmaksi.

Tutkielman analyysivaiheessa esitämme ehdotuksia täydentävistä
mittauksista ja vaihtoehtoisista tavoista saada luotettavampia tuloksia
tutkimuskohteesta.




* Arkkitehtuurin mallintaminen :noexport:
# todo OHJELMISTON mallintaminen vai arkkitehtuurin?

# todo vanhaa tekstiä tästä alaspäin ---------===========----
# Suoritusajan analysoimiseksi ohjelma on jaettava joukkoon erillisiä
# /tiloja/, joista ohjelman suoritus on yksikäsitteisesti yhdessä
# tilassa kerrallaan @@ferrari(456--458). Ohjelman kokonaissuoritusta
# kuvaa /tila--suoritusaika/ -pareista koostuva
# jono. Kokonaissuoritusaika on jonon alkioiden suoritusaikojen summa.

# Tilajako on mielivaltainen, mutta siitä on mielenkiintoinen
# erikoistapaus, joka vastaa lähes suoraan Androidin ja monien muiden
# ympäristöjen ohjelmointityökalujen mittaamia tuloksia: jos jokainen
# ohjelman lause tai konekäskys tulkitaan omaksi tilakseen, niin näistä
# suoritustiloista koostuvaa jonoa kutsutaan ohjelman /suoritusjäljeksi/
# (/program trace/) @@ferrari(458). Luettelo kustakin lauseesta
# kokonaissuorituskertoineen on ohjelman /profiili/ @@fortran(todo
# sivu).

# Performance depends largely upon the
# volume and complexity of the inter-component com-
# munication and coordination, especially if the compo-
# nents are physically distributed processes
#
# todo älä kirjoita tällaisia lainauksia ilman lähdeviitteitä

# lisää tähän selitys ferrarin 4-luvusta deterministinen
# vs. probabilistinen malli.

Monet ohjelmistojen suorituskykyongelmat johtuvat varhaisen
suunnitteluvaiheen arkkitehtuuriratkaisuista @@perf-arch(164);
suorituskyky riippuu pitkälti komponenttien välisestä kommunikaatiosta
ja koordinoinnista esimerkiksi fyysisesti hajautetuissa prosesseissa
@@arch(2).

Tässä tutkielmassa keskitytään kuitenkin sovelluksiin, joissa
suoritetaan laskentaa /paikallisesti/ yksittäisessä
mobiililaitteessa. Kun osaa sovelluksesta suoritetaan virtuaalikoneen
välityksellä ja toista konekielisenä suoraan prosessorissa, näiden
osien sijoittelu ja niiden välinen kommunikaatio on kuitenkin edelleen
oleellinen suorituskykytekijä.

Jotta arkkitehtuuriratkaisuiden suorituskykyä voisi arvioida
varhaisessa suunnitteluvaiheessa, tulee ohjelmiston arkkitehtuuri
/mallintaa/ @@perf-arch(165--166). Varhaiset mallit voivat olla melko
yksinkertaisiakin, sikäli kuin niiden niiden tavoitteena on karkeasti
arvioida ohjelmiston keskimääräiset, parhaat ja huonoimmat vasteajat
suhteessa vaatimuksiin.

# 4+1
# logical
# process
# physical
# development
# + use case

# todo selvennä 4+1 vihavaiselle alla

Mallit voivat perustua esimerkiksi 4+1-arkkitehtuurimallien kehikkoon
@@4plus1 ja UML-malleihin täydennettynä suorituskykyyn liittyvillä
laajennuksilla. Toisaalta UML-mallit ja monet ohjelmistoprosessissa
käytetyt mallit on kehitetty ohjelmiston /suunnittelun/ tueksi. Kun
halutaan /analysoida/ ohjelmiston ei-funktionaalisia ominaisuuksia,
kuten suorituskykyä, käytetään usein kvantitatiiviseen analyysiin
paremmin sopivia malleja @@rethink(2--3). On tärkeää, että mallin ja
lopullisen ohjelmiston välillä säilyy yhteys, jotta todellisessa
käytössä tehdyt mittaukset voivat korjata mallien oletuksia, kun
ohjelmistoa kehitetään jatkuvasti vähittäisin muutoksin
@@rethink(3).

Varhaisvaiheen suorituskykymallit sijoittuvat kolmeen päätyyppiin
@@rethink(6):

# todo: queuing vs queuing network
# todo suomennos qnm

1. jonotusmallit (queuing models),
2. Markov-mallit sekä
3. simulaatiomallit.

Tässä tutkielmassa käytetään Markov-malleja sijoittamaan käytännön
mittauksista saatavat tulokset laajempaan käsitteelliseen
kehikkoon. Markov-malleja on hyödynnetty ohjelmistojen mallintamiseen
kirjallisuudessa: @@sharma, @@sharma2, @@beizer.

Ohjelmistojen suorituskykytekniikan metodeissa käytetään usein
jonotusmalleja (/Queing Network Models/). Ne soveltuvat
rinnakkaislaskentaa hyödyntäviin tilanteisiin, joissa esimerkiksi
yksittäisen palvelimen resursseista kilpailee monta asiakasta
@@spe(227--228).

Tämän tutkielman keskiössä ovat kuitenkin suhteellisen pienen
mittakaavan \linebreak Android-sovellukset. Vaikka Android on
moniajokäyttöjärjestelmä, se on tyypillisesti yhden käyttäjän käytössä
kerrallaan. Tässä tutkielmassa tehdäänkin yksinkertaistava oletus,
etteivät muut käynnissä olevat prosessit oleellisesti vaikuta
mitattavan prosessin JNI-operaatioiden suorituskykyyn. Lisäksi, koska
jokaisella prosessilla on oma Dalvik-virtuaalikoneensa, ei
jonotusmalli ole luonteva tapa hahmottaa samanaikaistenkaan prosessien
toimintaa virtuaalikoneen tasolla. Käytännön mittauksissa
Android-laitteeseen ei ole asennettu ylimääräisiä sovelluksia ja
muiden prosessien toiminta tulkitaan satunnaisiksi mittaushäiriöiksi,
jotka huomioidaan tilastollisesti.


Simulaatiomallit ovat /suoritettavia/ malleja järjestelmästä, usein
karkeammalla tasolla kuin lopullinen järjestelmä.

Oman mainintansa ansaitsevat tietojenkäsittelytieteen perinteisen
ydinalueen, algoritmien ja tietorakenteiden tutkimuksen formaalit
tavat mallintaa algoritmeja @@art-programming. Algoritmien
asymptoottisen käyttäytymisen tuntemisesta on toki hyötyä
suorituskyvyn mallintamisessa -- tällainen analyysi tukee yksittäisten
algoritmien ja tietorakenteiden valintaa.  Käytännön
ohjelmistokehitykselle merkittävä puute on kuitenkin, että
asymptoottinen analyysi pelkistää ohjelman käyttäytymistä liiaksi
jättäen huomiotta yksittäisten operaatioiden vakiolliset kustannukset,
joilla on merkitystä todellisen suorituskyvyn kannalta @@spe(215).
Todellisessa suorituksessa ohjelman käyttäytyminen saattaa esimerkiksi
sopia huonosti yhteen suorittimen haarautumista ennustavan
heuristiikan kanssa @@showdown(21:5). Hyödynnän kuitenkin
asymptoottisen analyysin kaltaista menetelmää ekstrapoloidessani
JNI-operaatioiden käyttäytymistä vaihtelevilla syöteparametreilla.
# todo lähde


# Tutkielmassa
# hyödynnetään rajatusti simulaatiota siinä mielessä, että
# Android-kehitystyökalujen /Android-emulaattori/ simuloi todellista
# Android-laitetta ARM-käskyjen tasolla.[fn:emulator] Emulaattoria
# hyödynnetään joidenkin mittaustulosten osalta.
# todo: lähde
# [fn:emulator] Emulaattori-käsitteen syntyaikana @@emu puhtaan
# ohjelmallisesti toteutettua vieraan suoritusympäristön täydellistä
# toisinnosta kutsuttiin simulaattoriksi. Emulaattori perustui
# laitteistotukeen. Android-emulaattori on esimerkki nykykäytöstä, jossa
# ohjelmallistakin toisintamista usein kutsutaan emuloinniksi.

# TODO: uncomment? v 
# Myös simulaatiomalleja hyödynnetään rajatusti, sillä
# Android-ohjelmia suoritetaan 

Tutkielman hypoteesi on, että erilaiset arkkitehtuuriratkaisut johtavat
erilaisiin suoritusaikoihin sovelluksissa, jotka on toteutettu Java- ja
C-kieliä yhdistämällä, vaikka sovellukset suorittaisivat saman
tehtävän. Tutkielma rajataan sovelluksiin, joiden suoritusaikaa
määrittää oleellisesti sovelluksen prosessointi keskusyksikössä sekä
keskusmuistihaut, eivät esimerkiksi I/O-operaatiot
@@ferrari(168). Tällöin analyysin kohteeksi tuleekin, /mihin/
Android-sovellus kuluttaa suoritusaikansa.  Tätä mallinnetaan
Markov-ketjuilla.
# todo tarkista että em. pitää paikkansa lopulta
# todo onko tämä nyt se keskeinen hypoteesi? ehkä mutta tsekkaa lopuksi

** Vasteaikojen mallintaminen Markov-ketjuilla
\todo{<<Markov>>}

Hyödynnän Beizerin @@beizer esittelemää yksinkertaista Markov-mallia,
jolla ohjelman kokonaisvasteajan saa laskettua sen osien
suoritusajoista @@ferrari. Mallinnustavan etuna on yksinkertaisuuden
lisäksi se, että mittaustuloksina saatavat vasteaikojen jakautumat voi
helposti kytkeä mallin osaksi.
# todo ferrari sivut

Mallissa ohjelma jaetaan suoritustiloihin halutulla karkeusasteella --
tutkielmassa jako noudattaa lähinnä profilointityökaluissa esiintyvien
aliohjelmien rajoja, yhdistellen tarvittaessa aliohjelmia suuremmiksi
loogisiksi kokonaisuuksiksi. Malli on /verkko/, jonka nimetyt /solmut/
vastaavat hetkellisiä diskreettejä suoritustiloja, ja solmujen väliset
/kaaret/ vastaavat siirtymiä tilasta toiseen sekä myös laskentaa joka
siirtymässä tapahtuu. Yhdestä tilasta voi lähteä ja siihen voi saapua
monta kaarta, ja kaariin kytketyt todennäköisyydet ilmaisevat
todennäköisyyttä, että kyseinen siirtymä tapahtuu.

\begin{figure}[h!]
\centerline{
\includegraphics[scale=1]{figures/beizer_example.pdf}
}\caption{Ohjelman mallinnus Markov-prosessina \cite{beizer}}\label{fig:beizer}
\end{figure}

Mallinnustavan erikoisuutena laskenta ei sijoitu solmuihin vaan
kaariin, joihin liittyy todennäköisyyden lisäksi keskimääräinen
suoritusaika sekä suoritusajan varianssi (jotka vastaavat
mittauksia). Kuvassa \ref{fig:beizer} tilojen /i/ ja /k/ välisen
siirtymän suoritusaika on \mu_ik, todennäköisyys p_ik ja suoritusajan
varianssi \lambda_ik.  Muutoin kyseessä on perinteinen Markov-malli, joka on
/historiaton/: /Markov-oletuksen/ mukaisesti eri siirtymien
todennäköisyydet riippuvat ainoastaan kulloisestakin tilasta eikä
prosessin aikaisemmista tiloista. Oletus on tietenkin epärealistinen,
mutta mallin tarkkuus paranee tilojen ja siirtymien tarkkuuden
parantuessa @@rethink(17). Kuten mittauksetkin, mallin arvot ovat
vahvasti riippuvaisia ohjelmiston syötteistä; lähestymistapana tässä
tutkielmassa on parametrisoida mallin vasteaika-arvot JNI-rajapintaan
kohdistuvilla työkuormilla.

Ohjelmiston kokonaisvasteaika ratkaistaan Beizerin mallinnustavassa
algoritmilla, joka eliminoi verkosta yhden solmun
kerrallaan. Algoritmissa on eri yhtälöt /sarjaan/ ja /rinnan/
kytkettyjen solmujen sekä /silmukoiden/ poistoon @@beizer(521--522).

1. Valitaan poistettava solmu.
2. Poistetaan solmu käyttämällä /sarjaan/ kytkettyjen solmujen
   poistomenetelmää. Kaarien määrä lisääntyy.
3. Yhdistetään /rinnakkaiset/ kaaret.
4. Poistetaan /silmukat/.
5. Palataan kohtaan 1.

# todo kuvat

Jokaisella algoritmin kierroksella malli yksinkertaistuu, ja tuloksena
syntyvien kaarien arvot on laskennallisesti yhdistetty poistoja
edeltäneiden kaarien arvoista. Lopulta mallissa on ainoastaan yksi
solmu, mutta mahdollisesti useita eri lähtö- ja lopputiloja kuvaavia
kaaria. Redusoidusta mallista nähdään ohjelman kokonaisvasteajat
jokaiselle mahdolliselle lähtö- ja lopputilojen yhdistelmälle. Jos
käytetty malli on tarpeeksi totuudenmukainen, saadaan yksinkertaiselle
yhden käyttäjän ohjelmalle arvioitua keskimääräinen suoritusaika
varianssineen jo ennen ohjelman laatimista.



* Tehtäviä                                                         :noexport:
** DONE [#A] mainitse tilavaativuus
** DONE [#B] käsittele lyhyesti (max 2 kpl) O-algoritmianalyysi?
** TODO CPU time vs. other time: viittaa mittausten yhteydessä
** TODO mahdollista profilointi-sanan käyttö nykykäytön mukaisesti
** TODO oikeastaan mittausten avulla mallinnetaan aika lailla /työkuormaa/
** Aliluvut
*** Työkuorman mallintaminen                                       :noexport:
    tämä on vähän hankalampi, katotaan myöhemmin


