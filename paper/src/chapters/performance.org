
Riittävä suorituskyky on keskeinen laatuvaatimus mille tahansa
ohjelmistolle, mutta millä tavalla suorituskykyvaatimukset tulisi
ottaa huomioon ohjelmiston kehitysprosessissa? Ohjelmistotekniikan
kirjallisuudessa kysymykseen on vastattu hyvin eri tavoin.

* Suorituskyvyn saavuttaminen

Donald Knuthilta on peräisin tunnettu lainaus: "Ennenaikainen
optimointi on kaiken pahan alku ja juuri @@goto(268)."  Knuth
korostaa, ettei varsinaisessa ohjelmointityössä kannata käyttää aikaa
suorituskykyä parantaviin manuaalisiin optimointeihin ennen kuin
ohjelman suoritusaikaista käyttäytymistä on tutkittu ja löydetty
ohjelman osat, joiden suoritusaika on merkittävä osa ohjelman
kokonaissuoritusajasta.
# todo: mitä knuthin artikkeli itse asiassa käsittelee?



Periaatteeseen on kaksi syytä. Ensinnäkin ohjelmoijan intuitio johtaa
yleensä harhaan, kun etsitään ohjelman suorituskyvyn kannalta
keskeisiä osia. Lisäksi käsityönä tehdyt optimoinnit tekevät
ohjelmakoodista vaikeammin ymmärrettävää ja ylläpidettävää, joten
niitä kannattaa välttää aina kun niitä ei todistetusti tarvita.

Knuthin tueksi voi nykynäkökulmasta todeta, että
laitteistoarkkitehtuurien, optimoivien kääntäjien, virtuaalikoneiden
ja suoritusympäristön yleisen monimutkaistumisen takia pelkästä
ohjelman lähdekoodista on yhä vaikeampaa suoraan päätellä ohjelman
suoritusaikaista käyttäytymistä @@vertical.

# TODO esimerkki lähteistä (java vertical profiling)
# lisää lähteitä?

Knuthin näkökulma rajottui kuitenkin yksittäisen algoritmin, ohjelman
tai komponentin /ohjelmointiin/. Laajempaa ohjelmistoa rakentaessa
otetaan kantaa myös ohjelmiston konseptuaalisiin vaatimuksiin ja
suunnitellaan ohjelmiston komponenttitason arkkitehtuuri sekä
komponenttien tarkempi rakenne. Oli ohjelmiston tuotantoprosessi miten
inkrementaalinen tahansa, varhaiset makrotason ratkaisut rajoittavat
usein myöhempiä mikrotason ratkaisuita. Merkittäviä
seurannaisvaikutuksia on esimerkiksi

- käytetyillä ohjelmointikielillä,
- käytetyillä valmiilla komponenteilla ja ohjelmakirjastoilla,
- komponenttien toteutuskielillä sekä
- ohjelmiston yleisarkkitehtuurilla ja komponenttien sijoittumisesta
  suoritusympäristön eri osiin.
  
Kaikkia näitä valintoja voi toki periaatteessa muuttaa milloin
tahansa, mutta todellisten projektien rajoitusten takia se on usein
jälkikäteen mahdotonta.
  
# comment: lähde edelliseen?

Suorituskykyvaatimuksien täyttymistä ohjelmistoprosessin näkökulmasta
tavoitellaan /ohjelmistojen suorituskykytekniikan/ alalla (/Software
Performance Engineering/, /SPE/). Se on ohjelmistotekniikan osa-alue,
jossa suorituskykyvaatimukset kvantifioidaan ja otetaan huomioon
vaatimusanalyysistä lähtien aina ylläpitoon asti @@spe(1). Alan
kehittäjän Connie U. Smithin mukaan puutteelliset
suorituskykyominaisuudet ovat olleet keskeisessä osassa
epäonnistuneissa ohjelmistoprojekteissa, ja ne voitaisiin välttää
/mallintamalla/ ohjelmistoja suorituskykynäkökulmasta jo ennen
toteutusvaihetta.

* Suorituskyvyn arvioiminen
# todo: arvioiminen &mallintaminen vs. mittaaminen/mittari
# (kielenkäyttö)
Suorituskyky on pohjimmiltaan subjektiivinen käsite, joka ilmaisee
miten /hyvin/ järjestelmä toteuttaa tehtävänsä @@ferrari(2). Tässä
tutkielmassa määritellään suorituskyky ohjelmiston laadulliseksi
ominaisuudeksi, joka kuvaa, miten /nopeasti/ ohjelmisto toimii
käyttäjän näkökulmasta: miten tyydyttävät sen vasteajat ovat ja miten
tehokkaasti se käsittelee syötedataa.

Jotta järjestelmän suorituskykyä voisi arvioida täsmällisesti, käsite
on purettava kvantitatiivisiksi /mittareiksi/.  Ne arvioivat
järjestelmän /tuottavuutta/ tai /responsiivisuutta/, tai valitun
ohjelmisto- tai laitteistoresurssin /käyttöastetta/ @@ferrari(12).
Käytän mittarin käsitettä kuvaamaan suorituskyvyn kvantitatiivisia
osatekijöitä, oli ne sitten johdettu ohjelmistoa kuvaavista malleista
tai saatu todellisista mittauksista.

Tässä tutkielmassa käsitellään ensisijaisesti mobiilisovellusten
responsiivisuutta. Sitä arvioidaan /vasteajalla/: aikavälillä syötteen
saamisesta siihen hetkeen kun ohjelman tai ohjelmakomponentin tuloste
on palautettu käyttäjälle tai kutsuvalle komponentille
@@ferrari(13). Vasteajan perussuure on aika, ja vasteaikaa voi
arvioida eri kokoluokissa jopa yksittäisestä konekäskystä koko
ohjelmistoon.

Myös tuottavuutta käsitellään tutkielmassa sikäli kuin komponenttien
tuottavuus vaikuttaa käyttäjän kokemiin vasteaikoihin. Tuottavuus
tarkoittaa käsittelytehoa, jolla ohjelma suoriutuu tietyn työkuorman
käsittelystä, ja tuottavuusmittarit ilmaistaan yksiköllä /kuorma
aikayksikköä kohti/. Kuormalle ei yleensä ole löydettävissä
universaalia, laitteisto- tai sovellusalueriippumatonta mittayksikköä
@@ferrari(12). Työkuorman mallintaminen onkin keskeisiä haasteita
suorituskyvyn arvioinnissa @@spe(115), @@ferrari(221).
#todo oikea syntaksi monelle viitteelle?

Sama universaalisuusongelma koskee kaikkia suorituskykymittareita.
Vaikka suorituskyvyn eri osatekijöitä voi arvioida kvantitatiivisilla
mittareilla, tulosten objektiivisuus on aina rajallinen. Esimerkiksi
vasteaikamittarit ovat merkityksellisiä vain suhteessa kulloiseenkin
käyttötapaukseen ja kokonaistyömäärään, joista molemmat on hyvin
vaikea kuvata tyhjentävästi ja järjestelmäriippumattomasti
@@ferrari(14). Varsinaiset suoritusaikamittaukset puolestaan koskevat
aina /ohjelma--syöte/-pareja, eivät puhtaasti ohjelmaa sellaisenaan
@@ferrari(455).

Lisäksi moniajojärjestelmän, kuten Android-järjestelmän, kokonaistila
vaikuttaa yksittäisiin mitattuihin vasteaikoihin. Näistä syistä
mittariksi tulee ottaa vasteaikojen tilastollinen jakauma tietyn
ajanjakson sisällä ja tietyn käyttötapausluokan sisällä, jotta
vaihtelut molempien suhteen voidaan ottaa huomioon tilastollisesti
@@ferrari(14--15). Silloinkin ohjelman suoritusaikaan perustuvat
mittarit ovat riippuvaisia järjestelmästä ja laitteistoalustasta,
esimerkiksi mobiililaitemallista ja Android-versiosta
@@ferrari(454).

#viite: android moniajo
# mainitse vielä mittaus vs. mallinnus

* Arvioimisen yleispätevyys ja tavoitteet
# todo: käsittelee oikeastaan /mittaamisen/ tavoitteita
Objektiivisuuden puute voi vaikeuttaa mittausten tieteellistä
toistettavuutta. Käytännön kehitystyössä se ei aina ole ongelma, jos
tuloksista vedetään vain rajallisia johtopäätöksiä. Jos tavoitteena on
tietyn järjestelmän suorituskyvyn /parantaminen/, riittää että
mittauksia voi käyttää hypoteettisen suorituskykyparannuksen
/validointiin/ alkuperäistä ja muokattua järjestelmää vertailemalla
@@ferrari(336).

Jos tavoitteena on uuden ohjelmistojärjestelmän tuottaminen,
mittauksia käytetään validoimaan suorituskykyarvioita, jotka on
johdettu määrittely- ja suunnitteluvaiheiden malleista
@@spe(18). Ohjelmistoprosessissa näitä validoituja malleja verrataan
lopulta alkuperäisiin suorituskykyvaatimuksiin, joita niitäkin voidaan
joskus jopa tarkistaa @@spe(18). Siten kvantifioidutkin mallit ja
mittaukset ovat lopulta alisteisia ohjelmiston käyttäjien
subjektiiviselle kokemukselle [fn:bar].

[fn:bar] Jopa yhtäsuuret vasteajat voivat näyttäytyä käyttäjälle
erilaisina, jos työn etenemistä osoittava käyttöliittymäelementti
etenee eri tavalla @@progressbar.
# todo lue ja varmista että lähde sanoo näin ;)

# todo: varmista lopuksi että tämä on näin
Tässä tutkielmassa mitataan Dalvik-virtuaalikoneen
Java-natiivirajapinnan eri osien suorituskykyrasituksia suhteessa
toisiinsa ja suhteessa vastaaviin operaatioihin Java-kielisessä
ohjelmassa.  Tuloksista johdetaan tilastollinen malli, joka ennustaa
ohjelmiston JNI-operaatioista aiheutuvia ylimääräisiä
rasitteita. Mallin parametreinä on käytettyjen JNI-kutsujen määrä,
tyyppi, sekä niissä käytettyjen kutsuparametrien määrät ja tyypit.

Pelkästään JNI- ja Java-kutsujen rasitteiden keskinäisestä vertailusta
on hyötyä.
# todo: here i am on fire
# end todo

Seuraavaksi käyn läpi arkkitehtuurin vaikutuksia ohjelmiston
suorituskykyyn ja ohjelmiston mallintamista tästä näkökulmasta.
Mallintamisesta edetään mittaustekniikoihin ja periaatteisiin, joilla
saadaan malleja vastaavia mittaustuloksia.

* Arkkitehtuurin mallintaminen

# Performance depends largely upon the
# volume and complexity of the inter-component com-
# munication and coordination, especially if the compo-
# nents are physically distributed processes

Monet ohjelmistojen suorituskykyongelmat johtuvat varhaisen
suunnitteluvaiheen arkkitehtuuriratkaisuista @@perf-arch(164);
suorituskyky riippuu pitkälti komponenttien välisen kommunikaation ja
koordinoinnin mittaluokista erityisesti fyysisesti hajautetuissa
prosesseissa @@arch(2). Android-ohjelmoinnissa tällaista hajauttamista
hyödynnetään mobiilisovelluksissa, jotka kommunikoivat verkkoyhteyden
välityksellä palvelinprosessien kanssa.
# todo mittaluokista ??

Tässä tutkielmassa keskitytään kuitenkin sovelluksiin, joissa
suoritetaan laskentaa /paikallisesti/ yksittäisessä
mobiilaitteessa. Kun osaa sovelluksesta suoritetaan virtuaalikoneen
välityksellä ja toista konekielisenä suoraan prosessorissa, näiden
osien välinen kommunikaatio ja niiden sijoittelu on tällöinkin
oleellinen suorituskykytekijä.

Jotta arkkitehtuuriratkaisuiden suorituskykyä voisi arvioida
varhaisessa suunnitteluvaiheessa, tulee ohjelmiston arkkitehtuuri
/mallintaa/ @@perf-arch(165--166). Varhaiset mallit voivat olla melko
yksinkertaisiakin, sikäli kuin niiden niiden tavoitteena on karkeasti
arvioida ohjelmiston keskimääräiset, parhaat ja huonoimmat vasteajat
suhteessa vaatimuksiin.

# 4+1
# logical
# process
# physical
# development
# + use case

Mallit voivat perustua esimerkiksi 4+1-arkkitehtuurimallien kehikkoon
@@4plus1 ja UML-malleihin täydennettynä suorituskykyyn liittyvillä
laajennuksilla. Toisaalta UML-mallit ja monet ohjelmistoprosessissa
käytetyt mallit on kehitetty ohjelmiston /suunnittelun/ tueksi. Kun
halutaan /analysoida/ ohjelmiston ei-funktionaalisia ominaisuuksia,
kuten suorituskykyä, käytetään usein analyysiin paremmin sopivia
malleja @@rethink(2--3). On tärkeää, että mallin ja todellisen
lopullisen ohjelmiston välillä säilyy yhteys, jotta ohjelmistosta
todellisessa käytössä tehdyt mittaukset voivat korjata mallien
oletuksia kun ohjelmistoa kehitetään inkrementaalisesti ja
evoluutiivisesti.

Varhaisvaiheen suorituskykymallit sijoittuvat kolmeen päätyyppiin
@@rethink(6):

# todo: queuing vs queuing network
# todo suomennos qnm

1. jonotusmallit (queuing models),
2. Markov-mallit sekä
3. simulaatiomallit.

Tässä tutkielmassa käytetään Markov-malleja sijoittamaan käytännön
mittauksista saatavat tulokset laajempaan käsitteelliseen
kehikkoon. Markov-mallit sopivat luontevasti käytössä olevien
mittausmenetelmien pariksi, mitä käsitellään tarkemmin luvussa
. Markov-malleja on hyödynnetty arkkitehtuurin mallintamiseen
kirjallisuudessa
#todo sisäinen viite, lähteet

Ohjelmistojen suorituskykytekniikan metodeissa käytetään usein
jonotusmalleja (/Queing Network Models/). Ne soveltuvat
rinnakkaislaskentaa hyödyntäviin tilanteisiin, joissa esimerkiksi
yksittäisen palvelimen resursseista kilpailee monta asiakasta
@@spe(227--228). Tämän tutkielman keskiössä ovat suhteellisen pienen
mittakaavan Android-sovellukset. Vaikka Android on
moniajokäyttöjärjestelmä, yksi mobiililaite on tyypillisesti yhden
käyttäjän käytössä kerrallaan, ja optimitilanteessa käyttöjärjestelmä
rajoittaa samanaikaisesti suoritettavien prosessien määrää.

Simulaatiomallit ovat /suoritettavia/ malleja järjestelmästä, usein
karkeammalla tasolla kuin lopullinen järjestelmä. Tutkielmassa
hyödynnetään rajatusti simulaatiota siinä mielessä, että
Android-kehitystyökalujen /Android-emulaattori/ simuloi todellista
Android-laitetta ARM-käskyjen tasolla [fn:emulator]. Emulaattoria
hyödynnetään joidenkin mittaustulosten osalta.
#todo: lähde

[fn:emulator] Emulaattori-käsitteen syntyaikana @@emu puhtaan
ohjelmallisesti toteutettua vieraan suoritusympäristön täydellistä
toisinnosta kutsuttiin simulaattoriksi. Emulaattori perustui
laitteistotukeen. Android-emulaattori on esimerkki nykykäytöstä, jossa
ohjelmallistakin toisintamista usein kutsutaan emuloinniksi.

# TODO: uncomment? v 
#Myös simulaatiomalleja hyödynnetään rajatusti, sillä
#Android-ohjelmia suoritetaan 

Tutkielman hypoteesi on, että Java- ja C-kieliä yhdistävän sovelluksen
erilaiset arkkitehtuuriratkaisut johtavat erilaisiin suoritusaikoihin,
vaikka sovellukset suorittaisivat saman tehtävän.  Tutkielma rajataan
sovelluksiin, joiden suoritusaikaa määrittää oleellisesti sovelluksen
prosessointi keskusyksikössä sekä keskusmuistihaut, eivät esimerkiksi
I/O-operaatiot @@ferrari(168). Tällöin analyysin kohteeksi tuleekin,
/mihin/ Android-sovellus kuluttaa suoritusaikansa.  Tätä mallinnetaan
Markov-ketjuilla.
# todo tarkista että em. pitää paikkansa lopulta

* Mallintamisesta mittauksiin
# todo markovoi tämä!!

Suoritusajan analysoimiseksi ohjelma on jaettava joukkoon erillisiä
/tiloja/, joista ohjelman suoritus on yksikäsitteisesti yhdessä
tilassa kerrallaan @@ferrari(456--458). Ohjelman kokonaissuoritusta
kuvaa /tila--suoritusaika/ -pareista koostuva
jono. Kokonaissuoritusaika on jonon alkioiden suoritusaikojen summa.

Tilajako on mielivaltainen, mutta siitä on mielenkiintoinen
erikoistapaus, joka vastaa lähes suoraan Androidin ja monien muiden
ympäristöjen ohjelmointityökalujen mittaamia tuloksia: jos jokainen
ohjelman lause tai konekäskys tulkitaan omaksi tilakseen, niin näistä
suoritustiloista koostuvaa jonoa kutsutaan ohjelman /suoritusjäljeksi/
(/program trace/) @@ferrari(458). Luettelo kustakin lauseesta
kokonaissuorituskertoineen on ohjelman /profiili/ @@fortran(todo
sivu).

Jos tilajako on karkeampi, ja yksittäinen tila vastaa esimerkiksi
ohjelmiston komponenttia, tulee ohjelmisto /mallintaa/ käyttäen
valittua formalismia.


* Tehtäviä                                                         :noexport:
** TODO CPU time vs. other time: viittaa mittausten yhteydessäa
** TODO käsittele lyhyesti (max 2 kpl) O-algoritmianalyysi?
** TODO ferrari luku 5.2.3 objektiivisuus?? mikä tämä oli
** Aliluvut
*** Työkuorman mallintaminen                                       :noexport:
    tämä on vähän hankalampi, katotaan myöhemmin


