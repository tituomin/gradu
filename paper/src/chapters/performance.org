
Riittävä suorituskyky on keskeinen laatuvaatimus mille tahansa
ohjelmistolle, mutta millä tavalla suorituskykyvaatimukset tulisi
ottaa huomioon ohjelmiston kehitysprosessissa? Ohjelmistotekniikan
kirjallisuudessa kysymykseen on vastattu hyvin eri tavoin.

* Suorituskyvyn saavuttaminen

Donald Knuthilta on peräisin tunnettu lainaus: "Ennenaikainen
optimointi on kaiken pahan alku ja juuri @@goto(268)." 
Käsitellessään *rakenteellisen* ohjelmoinnin periaatteita Knuth korostaa, ettei
# todo: mitä artikkeli itse asiassa käsittelee?
varsinaisessa ohjelmointityössä kannata käyttää aikaa suorituskykyä
parantaviin manuaalisiin optimointeihin ennen kuin ohjelman
suoritusaikaista käyttäytymistä on tutkittu ja löydetty ohjelman
osat, joiden suoritusaika on merkittävä osa ohjelman
kokonaissuoritusajasta.

Periaatteeseen on kaksi syytä. Ensinnäkin ohjelmoijan intuitio johtaa
yleensä harhaan, kun etsitään ohjelman suorituskyvyn kannalta
keskeisiä osia. Lisäksi käsityönä tehdyt optimoinnit tekevät
ohjelmakoodista vaikeammin ymmärrettävää ja ylläpidettävää, joten
niitä kannattaa välttää kaikkialla, missä niitä ei todistetusti
tarvita.

Knuthin tueksi voi nykynäkökulmasta todeta, että
laitteistoarkkitehtuurien, optimoivien kääntäjien, virtuaalikoneiden
ja suoritusympäristön yleisen monimutkaistumisen takia pelkästä
ohjelman lähdekoodista on yhä vaikeampaa suoraan päätellä ohjelman
suoritusaikaista käyttäytymistä @@vertical.

# TODO esimerkki lähteistä (java vertical profiling)
# lisää lähteitä?

Knuthin näkökulma rajottui kuitenkin yksittäisen algoritmin, ohjelman
tai komponentin /ohjelmointiin/. Laajempaa ohjelmistoa rakentaessa
otetaan kantaa myös ohjelmiston konseptuaalisiin vaatimuksiin ja
suunnitellaan ohjelmiston komponenttitason arkkitehtuuri sekä
komponenttien tarkempi rakenne. Oli ohjelmiston tuotantoprosessi miten
inkrementaalinen tahansa, monet varhaiset makrotason ratkaisut
rajoittavat myöhempiä mikrotason ratkaisuita. Merkittäviä
seurannaisvaikutuksia on esimerkiksi

- valituilla ohjelmointikielellä tai -kielillä,
- valmiiden komponenttien ja kirjastojen valinnalla,
- ohjelmiston yleisarkkitehtuurilla ja komponenttien sijoittumisesta
  suoritusympäristön eri osiin,
  
Kaikkia näitä valintoja voi toki periaatteessa muuttaa milloin
tahansa, mutta todellisten projektien rajoitusten takia se on usein
jälkikäteen mahdotonta.
  
# comment: lähde edelliseen?

Suorituskykyvaatimuksien täyttymistä ohjelmistoprosessin näkökulmasta
tavoitellaan /ohjelmistojen suorituskykytekniikan/ alalla (/Software
Performance Engineering/, /SPE/). Se on ohjelmistotekniikan osa-alue,
jossa suorituskykyvaatimukset kvantifioidaan ja otetaan huomioon
vaatimusanalyysistä lähtien aina ylläpitoon asti @@spe(1). Alan
kehittäjän Connie U. Smithin mukaan puutteelliset
suorituskykyominaisuudet ovat olleet keskeisessä osassa
epäonnistuneissa ohjelmistoprojekteissa, ja ne voitaisiin välttää
/mallintamalla/ ohjelmistoja suorituskykynäkökulmasta jo ennen
toteutusvaihetta.

* Suorituskyvyn arvioiminen

Suorituskyky on pohjimmiltaan subjektiivinen käsite, joka kuvastaa,
miten /hyvin/ järjestelmä toteuttaa tehtävänsä @@ferrari(2). Tässä
tutkielmassa määritellään suorituskyky ohjelmiston laadulliseksi
ominaisuudeksi, joka kuvaa, miten /nopeasti/ ohjelmisto toimii
käyttäjän näkökulmasta: miten tyydyttävät sen vasteajat ovat ja miten
tehokkaasti se käsittelee syötedataa.

Jotta järjestelmän suorituskykyä voisi arvioida täsmällisesti, on
käsite purettava kvantitatiivisiksi /mittareiksi/.  Ne mittaavat
järjestelmän /tuottavuutta/ tai /responsiivisuutta/, tai valitun
ohjelmisto- tai laitteistoresurssin /käyttöastetta/ @@ferrari(12).

Tässä tutkielmassa käsitellään ensisijaisesti mobiilisovellusten
responsiivisuutta. Sitä arvioidaan mittaamalla /vasteaikaa/: aikaväliä
syötteen saamisesta siihen hetkeen kun ohjelman tai ohjelmakomponentin
tuloste on palautettu käyttäjälle tai kutsuvalle komponentille
@@ferrari(13). Vasteajan perussuure on siis aika, ja vasteaikaa voi
mitata eri kokoluokissa jopa yksittäisestä konekäskystä koko
ohjelmistoon.

Myös tuottavuutta käsitellään tutkielmassa sikäli kuin komponenttien
tuottavuus vaikuttaa käyttäjän kokemiin vasteaikoihin. Tuottavuus
tarkoittaa käsittelytehoa, jolla ohjelma suoriutuu tietyn työkuorman
käsittelystä, ja tuottavuusmittarit ilmaistaan yksiköllä /kuorma
aikayksikköä kohti/. Kuormalle ei yleensä ole löydettävissä
universaalia, laitteisto- tai sovellusalueriippumatonta mittayksikköä
@@ferrari(12). Työkuorman mallintaminen onkin keskeisiä haasteita
suorituskyvyn mittaamisessa ja arvioinnissa @@spe(115), @@ferrari(221).
#todo oikea syntaksi monelle viitteelle?

Sama universaalisuusongelma koskee kaikkia suorituskykymittareita.
Vaikka suorituskyvyn eri osatekijöitä voi mitata kvantitatiivisilla
mittareilla, niiden objektiivisuus on aina rajallinen. Esimerkiksi
vasteaikamittarit ovat merkityksellisiä vain suhteessa kulloiseenkin
käyttötapaukseen ja kokonaistyömäärään, joista molemmat on hyvin
vaikea kuvata tyhjentävästi @@ferrari(14).

Lisäksi moniajojärjestelmän, kuten Android-järjestelmän, kokonaistila
vaikuttaa yksittäisiin mitattuihin vasteaikoihin. Näistä syistä
mittariksi tulee ottaa vasteaikojen tilastollinen jakauma tietyn
ajanjakson sisällä ja tietyn käyttötapausluokan sisällä, jotta
vaihtelut molempien suhteen voidaan ottaa huomioon tilastollisesti
@@ferrari(14--15). Silloinkin ohjelman suoritusaikaan perustuvat
mittarit ovat riippuvaisia järjestelmästä ja laitteistoalustasta,
esimerkiksi mobiililaitemallista ja Android-versiosta
@@ferrari(454). Suoritusaika koskee aina /ohjelma--syöte/-pareja, eikä
puhtaasti ohjelmaa @@ferrari(455).

#viite: android moniajo

* Arvioimisen tavoitteista

Objektiivisuuden puute voi vaikeuttaa tulosten tieteellistä
toistettavuutta. Käytännön kehitystyössä se ei aina ole ongelma, jos
tuloksista vedetään vain rajallisia johtopäätöksiä. Jos tavoitteena
on tietyn järjestelmän suorituskyvyn /parantaminen/, riittää että
mittauksia voi käyttää alkuperäisen ja muokatun järjestelmän
vertailuun, tarkemmin sanottuna hypoteettisen suorituskykyparannuksen
/validointiin/ @@ferrari(336). Jos tavoitteena on uuden
ohjelmistojärjestelmän tuottaminen, mittauksia käytetään validoimaan
suorituskykyarvioita, joita on sisällytetty määrittely- ja
suunnitteluvaiheiden malleihin.  @@spe(18). Ohjelmistoprosessissa
näitä validoituja malleja verrataan lopulta alkuperäisiin
suorituskykyvaatimuksiin, joita niitäkin voidaan joskus jopa muuttaa
@@spe(18). Siten kvantifioidutkin mallit ja mittaukset ovat lopulta
alisteisia ohjelmiston käyttäjien subjektiiviselle kokemukselle [fn:bar].

[fn:bar] Jopa yhtäsuuret mitatut vasteajat voivat näyttäytyä
käyttäjälle erilaisina, jos työn etenemistä osoittava
käyttöliittymäelementti etenee eri tavalla @@progressbar.
# todo lue ja varmista että lähde sanoo näin ;)

# todo : tästä alkaa versio 1
Tutkielman hypoteesina on, että Java- ja C-kieliä yhdistävän
sovelluksen erilaiset arkkitehtuuriratkaisut johtavat erilaisiin
suoritusaikoihin, vaikka sovellukset suorittaisivat saman tehtävän.
Tutkielma rajataan sovelluksiin, joiden suoritusaikaa määrittää
oleellisesti sovelluksen prosessointi keskusyksikössä sekä muistihaut,
eivät esimerkiksi I/O-operaatiot @@ferrari(168). Tällöin analyysin
kohteeksi tuleekin, /mihin/ Android-sovellus kuluttaa suoritusaikansa.

# todo tarkista että em. pitää paikkansa lopulta

* Suoritusajan analysointi ja ohjelman mallinnus

Suoritusajan analysoimiseksi ohjelma on jaettava joukkoon erillisiä
/tiloja/, joista ohjelman suoritus on yksikäsitteisesti yhdessä
tilassa kerrallaan @@ferrari(456--458). Ohjelman kokonaissuoritusta
kuvaa /tila--suoritusaika/ -pareista koostuva
jono. Kokonaissuoritusaika on jonon alkioiden suoritusaikojen summa.

Tilajako on mielivaltainen, mutta siitä on mielenkiintoinen
erikoistapaus, joka vastaa lähes suoraan Androidin ja monien muiden
ympäristöjen ohjelmointityökalujen mittaamia tuloksia: jos jokainen
ohjelman lause tulkitaan omaksi tilakseen, niin näistä
suoritustiloista koostuvaa jonoa kutsutaan ohjelman /suoritusjäljeksi/
(/program trace/) @@ferrari(458). Luettelo kustakin lauseesta
kokonaissuorituskertoineen on ohjelman /profiili/ @@fortran(todo
sivu).

Jos tilajako on karkeampi, ja yksittäinen tila vastaa esimerkiksi
ohjelmiston komponenttia, tulee ohjelmisto /mallintaa/ käyttäen
valittua formalismia. 

# todo: CPU time vs. other time: viittaa mittausten yhteydessäa

#+LATEX: \newpage

* Ohjelmiston suorituskyvyn mallintaminen
# markov


* Ohjelmiston mittaustekniikat

# aasinsilta sitten android-internaaleihin
#todo: tähän loppuu versio 1 ja alkaa 2
Ennen kuin käsittelemme tarkemmin suorituskyvyn mittaamisen
periaatteita, käymme läpi ohjelmiston arkkitehtuurin vaikutuksia
suorituskykyyn ja ohjelmiston mallintamista tästä näkökulmasta.
# todo käsitteleMME

* Arkkitehtuurin mallintaminen

# Performance depends largely upon the
# volume and complexity of the inter-component com-
# munication and coordination, especially if the compo-
# nents are physically distributed processes

Monet ohjelmistojen suorituskykyongelmat johtuvat varhaisen
suunnitteluvaiheen arkkitehtuuriratkaisuista @@perf-arch(164);
suorituskyky riippuu pitkälti komponenttien välisen kommunikaation ja
koordinoinnin laajuudesta ja monimutkaisuudesta erityisesti fyysisesti
hajautetuissa prosesseissa @@arch(2). Android-ohjelmoinnissa tällaista
hajauttamista hyödynnetään mobiilisovelluksissa, jotka kommunikoivat
verkkoyhteyden välityksellä palvelinresurssien kanssa.

Tässä tutkielmassa keskitytään kuitenkin sovelluksiin, joissa tehdään
vaativaa laskentaa /paikallisesti/ yksittäisessä mobiilaitteessa. Kun
osia sovelluksesta suorittaa Dalvik-virtuaalikone ja toisia suoraan
laitteen prosessori, eri komponenttien välinen kommunikaatio ja niiden
sijoittelu on tällöinkin oleellinen suorituskykytekijä.

Jotta arkkitehtuuriratkaisuiden suorituskykyä voisi arvioida
varhaisessa suunnitteluvaiheessa, tulee ohjelmiston arkkitehtuuri
/mallintaa/ @@perf-arch(165--166). Varhaiset mallit voivat olla melko
yksinkertaisiakin, sikäli kuin niiden niiden tavoitteena on arvioida,
ohjelmiston keskimääräiset, parhaat ja huonoimmat vasteajat suhteessa
vaatimuksiin.

Mallit voivat perustua esimerkiksi 4+1-arkkitehtuurimallien kehikkoon
@@4plus1 ja UML-malleihin täydennettynä suorituskykyyn liittyvillä
laajennuksilla. Toisaalta UML-mallit ja monet ohjelmistokehityksessä
perinteisesti käytetyt mallit on kehitetty ohjelmiston /suunnittelun/
tueksi. Kun halutaan /analysoida/ ohjelmiston ei-funktionaalisia
ominaisuuksia, kuten suorituskykyä, käytetään usein erityyppisiä
malleja @@rethink(2--3). On tärkeää, että mallin ja todellisen
lopullisen ohjelmiston välillä säilyy yhteys, jotta ohjelmistosta
todellisessa käytössä tehdyt mittaukset voivat korjata mallien
oletuksia kun ohjelmistoa kehitetään inkrementaalisesti ja
evoluutiivisesti.

# logical
# process
# physical
# development
# + use case

Tutkielman keskiössä on suhteellisen pienen mittakaavan
Android-sovellukset. Vaikka Android on moniajokäyttöjärjestelmä, yksi
mobiililaite on tyypillisesti yhden käyttäjän käytössä kerrallaan, ja
optimitilanteessa käyttöjärjestelmä rajoittaa samanaikaisesti
suoritettavien prosessien määrää. Siksi sivuutan jotkin massiivisempaa
rinnakkaiskäyttöä kuvaavat mallinnustavat, kuten ohjelmistojen
suoritustekniikassa korostetut /jonotusmallit/ (/Queing Network
Models/). Ne soveltuvat tilanteisiin, joissa esimerkiksi yksittäisen
palvelinympäristön resursseista kilpailee monta asiakasta
@@spe(227--228).
# todo suomennos qnm

# todo here



* Ohjelmiston mallintaminen (Markov)
# todo: tähän loppuu versio 2



* Työkuorman mallintaminen
# todo, tämä on vähän hankalampi, katotaan myöhemmin




# käsittele lyhyesti (max 2 kpl) O-algoritmianalyysi




#Näinkin rajattuna käsite on
#riippuvainen käyttäjän tarpeista ja siten ohjelmiston vaatimuksista
# @@todo(2--4).

#Tuottavuuteen liittyy
# todo 

# probleemi: subjektiivisuus vs. mitattavuus. tästä löytyy matskua. :)
# ferrari luku 5.2.3


