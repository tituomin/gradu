
Riittävä suorituskyky on keskeinen laatuvaatimus mille tahansa
ohjelmistolle, mutta millä tavalla suorituskyky tulisi ottaa huomioon
ohjelmiston kehitysprosessissa? Ohjelmistotekniikan kirjallisuudessa
kysymykseen on vastattu hyvin eri tavoin.

* Suorituskyvyn saavuttaminen

Donald Knuthilta on peräisin tunnettu lainaus: "Ennenaikainen
optimointi on kaiken pahan alku ja juuri @@goto(268)."  Knuth
korostaa, ettei varsinaisessa ohjelmointityössä kannata käyttää aikaa
suorituskykyä parantaviin manuaalisiin optimointeihin ennen kuin
ohjelman suoritusaikaista käyttäytymistä on tutkittu ja löydetty
ohjelman osat, joiden suoritusaika on merkittävä osa ohjelman
kokonaissuoritusajasta.
# todo: mitä knuthin artikkeli itse asiassa käsittelee?



Periaatteeseen on kaksi syytä. Ensinnäkin ohjelmoijan intuitio johtaa
yleensä harhaan, kun etsitään ohjelman suorituskyvyn kannalta
keskeisiä osia. Lisäksi käsityönä tehdyt optimoinnit tekevät
ohjelmakoodista vaikeammin ymmärrettävää ja ylläpidettävää, joten
niitä kannattaa välttää aina kun niitä ei todistetusti tarvita.

Knuthin tueksi voi nykynäkökulmasta todeta, että
laitteistoarkkitehtuurien, optimoivien kääntäjien, virtuaalikoneiden
ja suoritusympäristön yleisen monimutkaistumisen takia pelkästä
ohjelman lähdekoodista on yhä vaikeampaa suoraan päätellä ohjelman
suoritusaikaista käyttäytymistä @@vertical.

# TODO esimerkki lähteistä (java vertical profiling)
# lisää lähteitä?

Knuthin näkökulma rajottui kuitenkin yksittäisen algoritmin, ohjelman
tai komponentin /ohjelmointiin/. Laajempaa ohjelmistoa rakentaessa
otetaan kantaa myös ohjelmiston käsitteellisiin vaatimuksiin ja
suunnitellaan ohjelmiston komponenttitason arkkitehtuuri sekä
komponenttien tarkempi rakenne. Oli ohjelmiston tuotantoprosessi miten
inkrementaalinen tahansa, varhaiset makrotason ratkaisut rajoittavat
usein myöhempiä mikrotason ratkaisuita. Merkittäviä
seurannaisvaikutuksia on esimerkiksi

- käytetyillä ohjelmointikielillä,
- käytetyillä valmiskomponenteilla ja ohjelmakirjastoilla,
- komponenttien toteutuskielillä sekä
- ohjelmiston yleisarkkitehtuurilla ja komponenttien sijoittumisesta
  suoritusympäristön eri osiin.
  
Kaikkia näitä valintoja voi toki periaatteessa muuttaa milloin
tahansa, mutta todellisten projektien rajoitusten takia se on usein
jälkikäteen mahdotonta.
  
# comment: lähde edelliseen?

Suorituskykyvaatimuksien täyttymistä ohjelmistoprosessin näkökulmasta
tavoitellaan /ohjelmistojen suorituskykytekniikan/ alalla (/Software
Performance Engineering/, /SPE/). Se on ohjelmistotekniikan osa-alue,
jossa suorituskykyvaatimukset kvantifioidaan ja otetaan huomioon
vaatimusanalyysistä lähtien aina ylläpitoon asti @@spe(1). Alan
kehittäjän Connie U. Smithin mukaan puutteelliset
suorituskykyominaisuudet ovat olleet keskeisessä osassa
epäonnistuneissa ohjelmistoprojekteissa, ja ne voitaisiin välttää
/mallintamalla/ ohjelmistoja suorituskykynäkökulmasta jo ennen
toteutusvaihetta.

* Suorituskyvyn arvioiminen
# todo: arvioiminen &mallintaminen vs. mittaaminen/mittari
# todo: another indice: memory use!
# (kielenkäyttö)
Suorituskyky on pohjimmiltaan subjektiivinen käsite, joka ilmaisee
miten /hyvin/ järjestelmä toteuttaa tehtävänsä @@ferrari(2). Tässä
tutkielmassa määritellään suorituskyky ohjelmiston laadulliseksi
ominaisuudeksi, joka kuvaa, miten /nopeasti/ ohjelmisto toimii
käyttäjän näkökulmasta: miten tyydyttävät sen vasteajat ovat ja miten
tehokkaasti se käsittelee syötedataa.

Jotta järjestelmän suorituskykyä voisi arvioida täsmällisesti, käsite
on purettava kvantitatiivisiksi /mittareiksi/.  Ne arvioivat
järjestelmän /tuottavuutta/ tai /responsiivisuutta/, tai valitun
ohjelmisto- tai laitteistoresurssin /käyttöastetta/ @@ferrari(12).
Käytän mittarin käsitettä kuvaamaan suorituskyvyn kvantitatiivisia
osatekijöitä, oli ne sitten johdettu ohjelmistoa kuvaavista malleista
tai saatu todellisista mittauksista.

Tässä tutkielmassa käsitellään ensisijaisesti mobiilisovellusten
responsiivisuutta. Sitä arvioidaan /vasteajalla/: aikavälillä syötteen
saamisesta siihen hetkeen kun ohjelman tai ohjelmakomponentin tuloste
on palautettu käyttäjälle tai kutsuvalle komponentille
@@ferrari(13). Vasteajan perussuure on aika, ja vasteaikaa voi
arvioida eri kokoluokissa jopa yksittäisestä konekäskystä koko
ohjelmistoon.

Myös tuottavuutta käsitellään tutkielmassa sikäli kuin komponenttien
tuottavuus vaikuttaa käyttäjän kokemiin vasteaikoihin. Tuottavuus
tarkoittaa käsittelytehoa, jolla ohjelma suoriutuu tietyn työkuorman
käsittelystä, ja tuottavuusmittarit ilmaistaan yksiköllä /kuorma
aikayksikköä kohti/. Kuormalle ei yleensä ole löydettävissä
universaalia, laitteisto- tai sovellusalueriippumatonta mittayksikköä
@@ferrari(12). Työkuorman mallintaminen onkin keskeisiä haasteita
suorituskyvyn arvioinnissa @@spe(115), @@ferrari(221).
#todo oikea syntaksi monelle viitteelle?

Sama universaalisuusongelma koskee kaikkia suorituskykymittareita.
Vaikka suorituskyvyn eri osatekijöitä voi arvioida kvantitatiivisilla
mittareilla, tulosten objektiivisuus on aina rajallinen. Esimerkiksi
vasteaikamittarit ovat merkityksellisiä vain suhteessa kulloiseenkin
käyttötapaukseen ja kokonaistyömäärään, joista molemmat on hyvin
vaikea kuvata tyhjentävästi ja järjestelmäriippumattomasti
@@ferrari(14). Varsinaiset suoritusaikamittaukset puolestaan koskevat
aina /ohjelma--syöte/-pareja, eivät puhtaasti ohjelmaa sellaisenaan
@@ferrari(455).

Lisäksi moniajojärjestelmän, kuten Android-järjestelmän, kokonaistila
vaikuttaa yksittäisiin mitattuihin vasteaikoihin. Näistä syistä
mittariksi tulee ottaa vasteaikojen tilastollinen jakauma tietyn
ajanjakson sisällä ja tietyn käyttötapausluokan sisällä, jotta
vaihtelut molempien suhteen voidaan ottaa huomioon tilastollisesti
@@ferrari(14--15). Silloinkin ohjelman suoritusaikaan perustuvat
mittarit ovat riippuvaisia järjestelmästä ja laitteistoalustasta,
esimerkiksi mobiililaitemallista ja Android-versiosta
@@ferrari(454).

#viite: android moniajo
# mainitse vielä mittaus vs. mallinnus

* Arvioimisen yleispätevyys ja tavoitteet
# todo: käsittelee oikeastaan /mittaamisen/ tavoitteita
Objektiivisuuden puute voi vaikeuttaa mittausten tieteellistä
toistettavuutta. Käytännön kehitystyössä se ei aina ole ongelma, jos
tuloksista vedetään vain rajallisia johtopäätöksiä. Jos tavoitteena on
tietyn järjestelmän suorituskyvyn /parantaminen/, riittää että
mittauksista löydetään suorituskyvyn kannalta ongelmalliset
suorituskohdat ja /validoidaan/ lopullinen suorituskykyparannus
vertailemalla alkuperäistä ja muokattua järjestelmää @@ferrari(336).

# ferrari 224: arvioidaan kriteereitä (workload-) malleille

Jos tavoitteena on uuden ohjelmistojärjestelmän tuottaminen,
mittauksia käytetään validoimaan suorituskykyarvioita, jotka on
johdettu määrittely- ja suunnitteluvaiheiden malleista
@@spe(18). Ohjelmistoprosessissa näitä validoituja malleja verrataan
lopulta alkuperäisiin suorituskykyvaatimuksiin, joita niitäkin voidaan
joskus jopa tarkistaa @@spe(18). Siten kvantifioidutkin mallit ja
mittaukset ovat lopulta alisteisia ohjelmistolle asetetuille
vaatimuksille ja viime kädessä käyttäjien subjektiiviselle kokemukselle.

# todo: varmista lopuksi että tämä on näin
Tässä tutkielmassa mitataan Dalvik-virtuaalikoneen
Java-natiivirajapintatoteutuksen eri osien suorituskykyrasituksia
suhteessa toisiinsa ja suhteessa vastaaviin operaatioihin
Java-kielisessä ohjelmassa. Tuloksista johdetaan tilastollinen malli,
joka ennustaa ohjelmiston JNI-operaatioista aiheutuvia rasitteita eri
tilanteissa. Mallin parametreinä on käytettyjen JNI-kutsujen määrä,
tyyppi, sekä niissä käytettyjen kutsuparametrien määrät ja tyypit.

JNI- ja Java-kutsujen rasitteiden keskinäisestä vertailusta on hyötyä
mille tahansa natiivikomponentteja hyödyntävälle sovellukselle, koska
sen avulla voidaan välttää tunnettuja ongelmakohtia komponenttien
välisessä kommunikaatiossa. Kysymys, onko natiivirajapinnan käytöstä
ylipäätään etua tietyn sovelluksen suorituskyvylle, saa
lisävalaistusta vasta kun natiivirajapinnan ylimääräisiä rasitteita
verrataan natiivikomponentin ja vastaavan Java-komponentin
vasteaikojen erotukseen.
# end todo

* Mittaamisesta mallintamiseen
Suorituskykyä käsittelevä kirjallisuus keskittyy usein joko myöhäisen
vaiheen diagnosointiin /mittausten/ avulla tai ohjelmiston
/mallintamiseen/ varhaisessa kehitysvaiheessa @@future-spe(172). Tämä
heijastelee johdannossa hahmoteltua näkemyseroa. Mittaamista voidaan
tehdä vasta, kun ohjelmisto tai sen osa on jo olemassa. Mallintamista
hankaloittaa puolestaan, että käyttökelpoiselta mallilta vaaditaan
abstraktisuutta ja yksinkertaisuutta, mutta samalla riittävää
/tarkkuutta/ suhteessa määriteltyyn syötejoukkoon sekä reunaehtoihin
ollaakseen /validi/ @@ferrari(161--162).

Tässä tutkielmassa lähdetään oletuksesta, että Dalvik-virtuaalikoneen
natiivirajapinta on kokonaisjärjestelmän osana riittävän
yksinkertainen, jotta siitä on mahdollista melko suoraviivaisesti
luoda malli joka perustuu rajapinnasta tehtyihin mittauksiin
kontrolloidulla syötejoukolla. Mittaus- ja mallintamisnäkökulmaa ei
ole saatu yhdistettyä toisiinsa riittävän yleispätevästi
@@future-spe(172); tämän tutkielman lähestymistapana on rajata
näkökulma spesifisti Java-virtuaalikoneen ja natiivikoodin väliseen
viestintään, ja konstruoida malli natiivirajapinnasta mittausten
perusteella. Käsittelenkin seuraavaksi ohjelmiston suorituskyvyn
mittaamiseen käytettäviä tekniikoita ennen mallinnusformalismien
esittelyä.
   
* Suorituskyvyn mittaaminen
Tietyn käyttötapauksen kokonaisvasteajan mittaaminen on
käsitteellisesti yksinkertaista: mitataan aikaväli syötteen saamisesta
siihen hetkeen, kun haluttu tulos on tulostettu käyttäjälle.
# lähde: ferrari alkusivut? spe-book?
Toisaalta vuorovaikutteisen sovelluksen suorittaman laskennan ja
käyttäjän syötteiden vuorottelu voi olla vilkasta. Käyttäjän toiminta
on usein samanaikaista järjestelmän laskennan kanssa. Käyttäjän
harkinta- ja reagointiviiveet eivät ole osa vasteaikaa, joten
vuorovaikutukset on mittausta varten eriteltävä riittävän
yksinkertaisiin mitattaviin yksiköihin, joissa käyttäjän ja
sovelluksen roolit on erotettavissa.
# lähde tuohon

Erilaiset keinot mitata aikaa koskevat erilaisia osia
kokonaisajasta. Järjestelmän ulkopuoliselle käyttäjälle havainnot ovat
riippuvaisia todellisesta kuluneesta ajasta, /tosiajasta/ (/real
time/, /wall clock time/), jota vastaa sekuntikellolla mitattu
aikaväli [fn:bar]. Linux-käyttöjärjestelmissä tätä mittaa
järjestelmäkutsu =gettimeofday=, joka lukee laitteiston kelloa. Jos
sovellusohjelma kutsuu sitä tavallisena käyttöjärjestelmäkutsuna,
saattaa ohjelman suoritus häiriintyä tarkkuutta vaativissa
mittauksissa @@ferrari(472) [fn:gettimeofday]. Tässä tutkielmassa
kyseistä rutiinia käytetään ainoastaan tarpeeksi pitkien
kokonaisvasteaikojen mittaamiseen, jolloin pienet häiriöt eivät ole
kriittisiä.
# todo tarkista onko androidissa tarkka userspace gettimeofday (arm)
# todo tosiaika?

[fn:bar] Toisaalta käyttäjä voi kokea jopa yhtäsuuriksi mitatut
vasteajat erilaisiksi, jos työn etenemistä osoittava
käyttöliittymäelementti etenee eri tavalla @@progressbar.
# todo lue ja varmista että lähde sanoo näin ;)

[fn:gettimeofday] Joissakin laitteistoissa kyseistä Linuxin palvelua
voi kutsua vähäisellä rasitteella siirtymättä kernelin suoritustilaan.
# lähde vdso etc.

Tässä tutkielmassa kaikki suorituskykyä parantavat ratkaisut tähtäävät
/oleellisten käyttötapausten lyhentyneeseen vasteaikaan tosiaikana
mitattuna/. Tarkemman suorituskykyanalyysin kannalta pelkkä tosiajan
käyttäminen ei kuitenkaan aina ole riittävää. Linux ja muut
käyttöjärjestelmät pitävät kirjaa myös /sovellusajasta/ (Linuxissa
/user time/), eli ajasta, jonka sovellusprosessi viettää aktiivisesti
tavallisessa suoritustilassa käyttöjärjestelmäytimen ulkopuolella
(/unprivileged mode/, /user mode/). Toinen osa sovellusprosessin
suoritusajasta, järjestelmäaika (/system time/), vietetään
käyttöjärjestelmäytimen sisällä palveluissa, joita sovellus on
eksplisiittisesti kutsunut.
# todo lähteet + lievennä Linux-spesifisyys

Aika, joka kuluu I/O- tai muita palveluita odottaessa, lasketaan
tosiaikaan muttei sovellus- tai järjestelmäaikaan. Käyttäjän
kannalta esimerkiksi I/O-operaatioden odottelulla on selvästi suuri
merkitys. Sovellus- ja järjestelmäaika yhdessä taas vastaavat
sovelluksen /suoritinaikaa/ (/CPU time/), koska niihin kuuluu
ainoastaan prosessin aktiivinen suoritusaika. Tutkielmassa oletetaan,
että suoritinaika on natiivirajapinnan rasitteiden oleellisin
osatekijä, mutta tosiaikaa mittaamalla varmistetaan, etteivät
suoritinajan ulkopuoliset merkittävät viiveet jää huomiotta.

Kuten aina, vasteaikojen mittaamisen kohde on aina
ohjelma--syöte-pari, joten sopivien syötteiden käyttäminen
mittauksissa on tärkeää @@ferrari(455).

** Vasteajan jakautuminen
Kokonaisvasteajalla on merkitystä ohjelmiston käyttäjälle sekä
tulosten lopullisessa validoinnissa. Tarkempi suorituskykyanalyysi
vaatii kuitenkin tuekseen yksityiskohtaisempia mittauksia. Niiden
tavoite on purkaa vasteaika osiin ja tunnistaa ne ohjelman osat, joiden
suorituksella on kokonaisuuden kannalta suurin vaikutus
@@ferrari(455--456).

Yksittäisen ohjelmiston ajonaikaista käyttäytymistä on
käytännöllisintä ja järkevintä mitata ohjelmallisesti eikä
erillisillä mittaamiseen käytetyillä laitteistolla. Fyysiset
mittauslaittet ovat tarkkoja ja häiritsevät järjestelmän toimintaa
minimaalisesti, mutta laitteiston tasolla tapahtuvien mikrotason
tapahtumien havaitseminen on käsitteellisesti kaukana ohjelmiston
sisäisestä suorituskontekstista @@ferrari(32). Käytännön
ohjelmistokehityksessä mittauslaitteiden hyödyntäminen ei usein
ole mahdollista.
#todo: suorituskonteksti hyvä pointti mutta ferrari ei sano tuota suoraan

Mittaustekniikat jakaantuvat menetelmiin, jotka joko /kirjaavat/
(/record/) kiinnostavia /tapahtumia/ tai /tarkkailevat/ (/monitor/)
järjestelmän tai ohjelmiston /tiloja/@@spe(328). Tapahtumien
kirjaaminen tarkoittaa, että joka kerta kun valittu tapahtuma
esiintyy, tieto tapahtumasta ja siihen liittyvä oleellinen informaatio
kerätään ja tallennetaan. Tarkkailumenetelmät puolestaan perustuvat
yleensä toistuvaan /näytteidenottoon/: tasaisin väliajoin, satunnaisin
väliajoin tai tietyn tapahtuman sattuessa otetaan näyte ohjelmiston
tilasta.

Tyypillinen kirjaamismenetelmä on ohjelman /instrumentointi/:
suoritettava ohjelma kirjaa mittauksen kohteena olevat tapahtumat
eksplisiittisillä, ohjelmaan itseensä sisältyvillä käskyillä
@@spe(328).  Keskeinen esimerkki on ohjelman /kutsuprofiilin/
rakentaminen laskemalla jokaisen aliohjelman jokainen kutsu. Näin
tallennetun informaation avulla voidaan suorituksen jälkeen tulostaa
luettelo jokaisesta kutsutusta aliohjelmasta järjestettynä
kutsukertojen mukaan. Ohjelman profiilin käsitteen loi Donald Knuth
@@fortran. Tämän kaltaista instrumentointia ei välttämättä tarvitse
ohjelmoida käsin: kääntäjä voi lisätä instrumentointikäskyjä
kohdeohjelmaan tarvittaessa automaattisesti.
#todo profile kutsu vs lausetason?  plus lähde tähän
# knuth irrallinen > siirrä myöhemmäksi

Näytteenoton tavoite on kerätä ohjelman suoritustiloista edustava
otanta kirjaamatta jokaista tilanmuutosta ohjelman sisältä käsin.
Yksittäinen näyte voidaan ottaa esimerkiksi tosiaikakellon aiheuttaman
keskeytyksen laukaisemana, ja näytteeseen voidaan tallentaa
esimerkiksi suorituksessa olleen konekäskyn osoite.

Instrumentoinnin ja näytteenoton avulla ohjelman suoritusajan
jakautumisesta aliohjelmiin tai jopa yksittäisiin konekäskyihin
voidaan siis periaatteessa saada hyvinkin tarkkoja mittauksia.
Ennenaikaista optimointia loppuun asti vältelleet ohjelmistokehittäjät
voivat näin tutkia vaikkapa missä aliohjelmissa suoritin viettää
suurimman osan ajastaan. Algoritmeja muuttamalla, tietorakenteita
vaihtamalla tai ohjelmaa muuten muokkaamalla näitä /kuumia kohtia/
(/hot spot/) voidaan optimoida -- tai välttää kutsumasta niitä
ollenkaan.

** Mittausten toteuttaminen
Instrumentoitua ohjelmaa voi suorittaa normaalisti samassa
ympäristössä, jossa tuotantosovellukset tavallisestikin suoritetaan,
eli Android-laitteessa. Täysipainoinen näytteenotto sen sijaan vaatii
käyttöjärjestelmältä tukea näytteenoton suorittamiselle tiettyjen
laitteistokeskeytysten tapahtuessa. Tämä käyttöjärjestelmän toiminto
pohjautuu laskureihin ja keskeytyksiin, jotka on varta vasten
sisäänrakennettu suorittimiin. Esimerkiksi ARM-suorittimet voi asettaa
laskemaan kuluneita suoritinsyklejä, väärin ennustettuja
suoritushaaroja, muistihakuja sekä muita tapahtumia. Kun valittu
tapahtumamäärä on ylittynyt, keskeytys käynnistää
käyttöjärjestelmäytimen mittausrutiinin.
# todo arm-lähde (virallinen dokkari)
# todo 

Vaihtoehto normaalin suoritusympäristön käyttämiselle on
/virtualisointi/, jossa pelkkä sovellus tai koko ohjelmistoympäristö
käyttöjärjestelmineen suoritetaan ohjelmallisessa
virtuaalikoneessa. Tällöin virtuaalikoneeseen voi periaatteessa
ohjelmoida mitä tahansa räätälöityjä mittauksia [fn:vm]. Olen rajannut
virtualisointimenetelmät tutkielman ulkopuolelle, sillä tavallisessa
Android-laitteessa tehtävät mittaukset antavat kaikki tarvittavat
tulokset, ja virtualisoitu suoritusympäristö voi käyttäytymiseltään
erota todellisista laitteista tavoilla, joiden toteaminen edellyttäisi
joka tapauksessa mittauksia myös todellisessa ympäristössä [fn:valgrind].

Myös Androidin Java-virtuaalikoneessa Dalvikissa on ohjelmien
ajonaikaista käyttäytymistä kirjaavia toimintoja, joiden mittauksiin
Androidin kehitysympäristön suorituskykytyökalut perustuvat. Dalvik
mittaa kuitenkin Java-ohjelman osien sekä natiivialiohjelmien
suoritusaikoja, siinä missä tämän tutkielman tarkoituksena on tutkia
Dalvikin itsensä suorituskykyä -- Javan natiivirajapinnan toteutus kun
on osa C++-kielellä ja symbolisella konekielellä toteutettua
Dalvik-virtuaalikonetta.

Tutkielman mittaukset suoritetaan näytteenottotekniikalla, Linuxin
/perf/-työkalujen avulla. Android-laitteeseen on asennettu räätälöity
Linux-ydin joka tukee suorituskykylaskurien käyttöä. Itse mittaukset
suoritetaan ytimen ulkopuolisilla /perf/-työkaluilla.

[fn:vm] Esimerkki virtualisoinnista on Androidin oma /emulaattori/,
joka perustuu QEMU-virtuaalikoneeseen. Se on emulaattori, sillä se
mallintaa Androidin laitteistoarkkitehtuuria eri laitteistolla,
tavallisella mikrotietokoneella. Valgrind-työkalu, jota tavallisimmin
käytetään muistinhallinnan virheidenjäljitykseen, tukee myös
suorituskykyprofilointia. Androidin tapauksessa Valgrind
käännettäisiin Androidin suoritusympäristöön.
# lähde !!
[fn:valgrind] Sovelluksen suorittaminen Valgrind-virtuaalikoneessa on
merkittävästi normaalia hitaampaa.


** Mittaustekniikoiden valintaperusteista
Eri mittaustekniikoilla on hyvät ja huonot puolensa. Instrumentointi
ei vaadi minkäänlaista erityistukea järjestelmältä, mutta edellyttää
kuitenkin instrumentoitavien ohjelmien uudelleen kääntämistä ja usein
myös niiden muokkaamista käsin. Käsin tai metaohjelmoinnin avulla
lisätyllä instrumentoinnilla saadaan kirjattua yksityiskohtaisinta
tietoa ohjelmiston sisäisestä tilasta ja sovellusaluekohtaisesta
informaatiosta: esimerkiksi siitä, minkä tyyppiset parametrit ovat
yleisimpiä tietyissä kutsuissa tai mitkä ovat lähetettyjen viestien
yleisimmät pituudet ja jopa sisällöt. Pelkällä kääntäjän lisäämällä
ei-sovelluskohtaisella instrumentaatiolla saadaan myös tietoa, jota ei
muilla tekniikoilla tavoita: jokaisen aliohjelman kutsujen määrä ja
jokaisen kutsun vasteaika.

Instrumentaatio on kapeasti ymmärrettynä tarkin mittausmenetelmä,
sillä kaikki kirjattu data on sinänsä eksaktia. Erityisesti
vasteaikojen suhteen ongelmaksi kuitenkin muodostuu se, että
insrumentointi aina /häiritsee/ enemmän tai vähemmän suoritettavan
ohjelman toimintaa. Toisin sanoen mittauskohteena onkin instrumentoitu
eikä alkuperäinen ohjelma. Jos vasteaikoja mitataan tihein väliajoin
käyttöjärjestelmäkutsulla, joka palauttaa järjestelmän kellon arvon,
saattaa tämä kutsu ja sen aiheuttama prosessin tilamuutos vaikuttaa
ohjelman käyttäytymiseen merkittävästi, vaikka kutsujen suorittamiseen
kuluvan ajan vähentäisikin tuloksista.
# pertrubation problem
# lähteitä ferrari, smith, java vertical profiling?

Toisaalta, jos ohjelmiston suorituskyvyn seuraaminen katsotaan osaksi
sen normaalia toimintaa, ja instrumentointikäskyt ovat oleellinen osa
tuontakäytössä suoritettavaa ohjelmistoa, häirinnän ongelma
katoaa. Tämä lienee käytännöllisintä laajoissa palvelinohjelmistoissa
-- yksittäisten käyttäjien mobiililaitteissa suoritettavien
sovellusohjelmien jatkuva suorituskykyseuranta ei usein tule
kyseeseen, vaan mahdolliset instrumentointikäskyt poistetaan
tuotantoversiota rakennettaessa.

Häirinnän ongelma on vähäisempi näytteenottotekniikoissa, sillä
käyttöjärjestelmä keskeyttää ohjelman toiminnan suhteellisen harvoin.
Näytteenoton aiheuttama häirintä jää tilastollisesti
pieneksi. Näytteenotossa tutkittavan ohjelmiston tilaa pitää kuitenkin
tulkita ohjelmiston itsensä ulkopuolelta, joten käytännössä analyysin
pohjana on suorittimen tila näytteenottohetkellä: käskyosoittimen
(/program counter/), muiden rekisterien sekä pinon sisällöt.

Pelkän käskyosoittimen käyttöä suorituskykyanalyysin perustana on
kritisoitu. Käskyosoitinnäytteiden avulla saadaan kyllä selville,
missä ohjelman osassa suoritin viettää eniten aikaa. Näin on kuitenkin
vaikea hahmottaa laajempaa suorituskontekstia, joka selittäisi mistä
eniten suoritusaikaa käyttävää aliohjelmaa on
kutsuttu. Suorituskykypullonkaulojen syiden merkityksellisempi
analyysi vaatii lähtökohdakseen oikean abstraktiotason. Käytännössä
yhden yksittäisen kutsuja aiheuttavan kohdan muuttaminen korkeammalla
kutsupinossa voi siirtää matalamman tason suorituskriittiset kohdat
aivan muualle.
# dunlavey

Tämän vuoksi käyttökelpoinen näytteenotto vaatii kutsupinon
uudelleenrakentamista pinon sisällöstä otetuista raakanäytteistä.  Nyt
aliohjelman /A/ kustannuksiin voidaan laskea mukaan kaikki näytteet,
joiden kutsupinoissa /A/ esiintyy, vaikka näytteen aikana suoritin
olikin suorittamassa toista aliohjelmaa /C/. Proseduraalisessa
ohjelmointiparadigmassa on usein mielekästä nähdä aliohjelman /A/
ilmentämä abstraktio myös sellaisen laskennan syynä, joka tapahtuu
aliohjelmassa /C/ esimerkiksi kutsuketjun /((A, B), (B, C))/
välityksellä. Yksinkertaisessa yksisäikeisessä ohjelmassa pääohjelman
kontolle laskettaisiin siis /kaikki/ suoritus. Käytännössä mielekäs
abstraktiotaso näytteiden analyysille löytyy tilannekohtaisesti
jostakin pääohjelman ja suoritettavan kohdan väliltä kutsupinosta.

Profilointityökaluissa aliohjelman suoritusaikaa kutsutaan usein
/inklusiiviseksi/, jos siihen lasketaan mukaan myös aliohjelman
kutsumien muiden aliohjelmien ajat. Pelkkään käskyosoittimeen
perustuva raaka suoritusaika on usein nimeltään /self time/, tässä
tutkielmassa /eksklusiivinen/ suoritusaika.
# gprof, oprofile, etc.

Näytteenotto ei ole mittausmenetelmänä kytketty tarkalleen tiettyihin
ohjelmakohtiin.  Suorittimen keskeytyksen laukeamisen jälkeen ohjelman
suoritus saattaa edetä joitakin konekäskyjä ennen näytteen
ottamista. Vaikka periaatteessa työkalut saattavat raportoida jopa
yksittäisten konekäskyjen suhteelliset, inklusiiviset kustannukset,
kannattaa näihin suhtautua pienellä varauksella. Korkealla
kutsupinossa olevien aliohjelmien inklusiiviisiin aikoihin tällä
epätarkkuudella ei ole käytännön merkitystä.
#oprofile

Käytän tutkielman mittauksiin lähinnä /perf/-työkalun
näytteenottotekniikkaa, sillä siinä mittauskohteena on mahdollisimman
paljon tuotantoversiota vastaava sovellus. Näytteenoton avulla ei
kuitenkaan saada selville aliohjelmakutsujen /määriä/, jotka ovat yksi
osatekijä käyttämissäni mallinnusmenetelmissä. Kutsumääriä
kontrolloidaan mahdollisuuksien mukaan mitattavan ohjelman avulla ja
staattisella ohjelmakoodin analyysilla. /gcc/-kääntäjän automaattista
instrumentointia käytetään tarvittaessa tähän tarkoitukseen.

** Näytteenoton tilastollinen edustavuus
Kaikenlaisessa näytteenotossa on varmistettava, että otanta on
/tilastollisesti edustava/: rajattua otosta tutkimalla on voitava
tehdä päätelmiä koko perusjoukosta. Tässä tapauksessa haluamme
päätellä rajallisen ajanhetkijoukon avulla (otos), miten
käskyosoittimen ja kutsupinon arvot jakautuvat ohjelman koko
suoritusajalle (perusjoukko). Tämä varmistetaan suoritinsyklien
laskemiseen perustuvassa näytteenotossa /systemaattisen otannan/
menetelmällä. Siinä jokaisella ajanhetkellä on sama todennäköisyys
tulla valituksi otantaan, sillä näyte otetaan systemaattisesti
tasaisin väliajoin, ja mittaus aloitetaan satunnaisella
ajanhetkellä. Tällöin eri ajanhetkien mittausarvoja ei tarvitse
painottaa suhteesssa toisiinsa.
# todo: lue tilastotieteen perusteet ja kirjoita em. kappale paremmin
# =) lol wikipediasta käsitteet systemaattinen ja 
# todo systemattinen: lähde wikipedia
# ferrari 57-59

Systemaattisessa jaksollisessa näytteenottossa saattaa tapahtua
erilaisia suunnitteluvirheitä, joiden seurauksena tietyt ajanhetket
valitaan otokseen todennäköisemmin kuin toiset. Jos tutkittavassa
prosessissa on jokin jaksollisesti toistuva ilmiö, jonka kanssa
näytteenoton jakso sattuu synkronoitumaan, tulokset
vääristyvät. Esimerkiksi tutkittavassa järjestelmässä saattaa olla
käytössä järjestelmän kelloon perustuvia keskeytyksiä, jotka
laukaisevat tiettyjä toimintoja. Huonosti valitulla
näytteenottojaksolla nämä toiminnot yli- tai alikorostuvat
mittauksissa.

Näytteenoton toteutustavassa saattaa myös olla sisäänrakennettuja
seurausvaikutuksia, joiden takia mittaus jo lähtökohtaisesti painottaa
tiettyjä ajanhetkiä. Koska haluamme tutkia suorittimen tilaa
/tosiajassa/, on varmistuttava, että näytteet jakautuvat tasaisesti
tosiajan suhteen. Esimerkiksi monet yleisesti käytetyt Java-profilointityökalut
kykenevät saamaan näytteitä ainoastaan ohjelman ns. luovutuskohdista
(/yield point/), eivät mistä tahansa suorituskohdasta @@java-acc(193).

Tutkielman mittauksissa näytteenotto tapahtuu aina kun ARM-suorittimen
suoritinsyklejä on tapahtunut ennalta valittu määrä (tapahtuma
~CPU_CYCLES~). Android-laitteen suorittimen kellotaajuus (syklien
määrä sekunnissa) ei kuitenkaan tyypillisesti ole vakio, vaan mukautuu
laskentatarpeeseen. Mittauksissa on siis erikseen asetettava
suorittimen kellotaajuus vakioksi, etteivät suuren kellotaajuuden
ajanhetket ylikorostuisi.
# 5 tehdä tilaa, väistyä (liikenteessä)
# yield up
# 1 luovuttaa, luopua
# liitä viite arm-dokkariin

Kannattaa huomata, että otannan ei tarvitse olla satunnainen:
systemaattinen jaksollinen otanta riittää, kunhan on varmistuttu
siitä, ettei perusjoukko sisällä jaksollisia ilmiöitä. Oletamme tässä
tutkielmassa, ettei mitattava järjestelmä sisällä jaksoja, jotka
asettuisivat yksiin täsmälleen /n/ suoritinsyklin kuluttaman
ajanjakson kanssa. Varmistumme tästä suorittamalla useita mittauksia,
joista jokainen alkaa satunnaisella ajanhetkellä, ja vaihtelemme
jakson pituutta syklimäärässä.
# todo: analysoi linuxin timeria ja schedulointia..
# todo: onko dalvikissa ym. muissa komponenteissa jaksollisia ilmiöitä?
* Arkkitehtuurin mallintaminen 
# todo vanhaa tekstiä tästä alaspäin ---------===========----
# Suoritusajan analysoimiseksi ohjelma on jaettava joukkoon erillisiä
# /tiloja/, joista ohjelman suoritus on yksikäsitteisesti yhdessä
# tilassa kerrallaan @@ferrari(456--458). Ohjelman kokonaissuoritusta
# kuvaa /tila--suoritusaika/ -pareista koostuva
# jono. Kokonaissuoritusaika on jonon alkioiden suoritusaikojen summa.

# Tilajako on mielivaltainen, mutta siitä on mielenkiintoinen
# erikoistapaus, joka vastaa lähes suoraan Androidin ja monien muiden
# ympäristöjen ohjelmointityökalujen mittaamia tuloksia: jos jokainen
# ohjelman lause tai konekäskys tulkitaan omaksi tilakseen, niin näistä
# suoritustiloista koostuvaa jonoa kutsutaan ohjelman /suoritusjäljeksi/
# (/program trace/) @@ferrari(458). Luettelo kustakin lauseesta
# kokonaissuorituskertoineen on ohjelman /profiili/ @@fortran(todo
# sivu).


# Performance depends largely upon the
# volume and complexity of the inter-component com-
# munication and coordination, especially if the compo-
# nents are physically distributed processes
#
# todo älä kirjoita tällaisia lainauksia ilman lähdeviitteitä

# lisää tähän selitys ferrarin 4-luvusta deterministinen
# vs. probabilistinen malli.

Monet ohjelmistojen suorituskykyongelmat johtuvat varhaisen
suunnitteluvaiheen arkkitehtuuriratkaisuista @@perf-arch(164);
suorituskyky riippuu pitkälti komponenttien välisen kommunikaation ja
koordinoinnin mittaluokista erityisesti fyysisesti hajautetuissa
prosesseissa @@arch(2). Android-ohjelmoinnissa tällaista hajauttamista
hyödynnetään mobiilisovelluksissa, jotka kommunikoivat verkkoyhteyden
välityksellä palvelinprosessien kanssa.
# todo mittaluokista ??

Tässä tutkielmassa keskitytään kuitenkin sovelluksiin, joissa
suoritetaan laskentaa /paikallisesti/ yksittäisessä
mobiilaitteessa. Kun osaa sovelluksesta suoritetaan virtuaalikoneen
välityksellä ja toista konekielisenä suoraan prosessorissa, näiden
osien sijoittelu ja niiden välinen kommunikaatio on kuitenkin edelleen
oleellinen suorituskykytekijä.

Jotta arkkitehtuuriratkaisuiden suorituskykyä voisi arvioida
varhaisessa suunnitteluvaiheessa, tulee ohjelmiston arkkitehtuuri
/mallintaa/ @@perf-arch(165--166). Varhaiset mallit voivat olla melko
yksinkertaisiakin, sikäli kuin niiden niiden tavoitteena on karkeasti
arvioida ohjelmiston keskimääräiset, parhaat ja huonoimmat vasteajat
suhteessa vaatimuksiin.

# 4+1
# logical
# process
# physical
# development
# + use case

Mallit voivat perustua esimerkiksi 4+1-arkkitehtuurimallien kehikkoon
@@4plus1 ja UML-malleihin täydennettynä suorituskykyyn liittyvillä
laajennuksilla. Toisaalta UML-mallit ja monet ohjelmistoprosessissa
käytetyt mallit on kehitetty ohjelmiston /suunnittelun/ tueksi. Kun
halutaan /analysoida/ ohjelmiston ei-funktionaalisia ominaisuuksia,
kuten suorituskykyä, käytetään usein kvantitatiiviseen analyysiin
paremmin sopivia malleja @@rethink(2--3). On tärkeää, että mallin ja
todellisen lopullisen ohjelmiston välillä säilyy yhteys, jotta
ohjelmistosta todellisessa käytössä tehdyt mittaukset voivat korjata
mallien oletuksia kun ohjelmistoa kehitetään inkrementaalisesti ja
evoluutiivisesti.

Varhaisvaiheen suorituskykymallit sijoittuvat kolmeen päätyyppiin
@@rethink(6):

# todo: queuing vs queuing network
# todo suomennos qnm

1. jonotusmallit (queuing models),
2. Markov-mallit sekä
3. simulaatiomallit.

Tässä tutkielmassa käytetään Markov-malleja sijoittamaan käytännön
mittauksista saatavat tulokset laajempaan käsitteelliseen
kehikkoon. Markov-mallit sopivat luontevasti käytössä olevien
mittausmenetelmien pariksi, mitä käsitellään tarkemmin luvussa
. Markov-malleja on hyödynnetty arkkitehtuurin mallintamiseen
kirjallisuudessa
#todo sisäinen viite, lähteet

Ohjelmistojen suorituskykytekniikan metodeissa käytetään usein
jonotusmalleja (/Queing Network Models/). Ne soveltuvat
rinnakkaislaskentaa hyödyntäviin tilanteisiin, joissa esimerkiksi
yksittäisen palvelimen resursseista kilpailee monta asiakasta
@@spe(227--228). Tämän tutkielman keskiössä ovat suhteellisen pienen
mittakaavan Android-sovellukset. Vaikka Android on
moniajokäyttöjärjestelmä, yksi mobiililaite on tyypillisesti yhden
käyttäjän käytössä kerrallaan, ja optimitilanteessa käyttöjärjestelmä
rajoittaa samanaikaisesti suoritettavien prosessien määrää.

Simulaatiomallit ovat /suoritettavia/ malleja järjestelmästä, usein
karkeammalla tasolla kuin lopullinen järjestelmä.

Oman mainintansa ansaitsevat tietojenkäsittelytieteen perinteisen
ydinalueen, algoritmien ja tietorakenteiden tutkimuksen formaalit
tavat mallintaa ohjelmia. Algoritmien asymptoottisen käyttäytymisen
tuntemisesta on rajatussa mielessä hyötyä suorituskyvyn
mallintamisessa. Tällainen analyysi tukee kuitenkin lähinnä
yksittäisten algoritmien ja tietorakenteiden valintaa, ja antaa vain
rajallisesti tukea järjestelmän kokonaisarkkitehtuurin
laatimiselle. Käytännön ohjelmistokehitykselle merkittävä puute on
lisäksi, että asymptoottinen analyysi pelkistää ohjelman
käyttäytymistä liiaksi jättäen huomiotta yksittäisten operaatioiden
todelliset kustannukset todellisilla laitteilla -- analyysin
perusteella tehokas algoritmi saattaa esimerkiksi sopia huonosti
yhteen nykyaikaisen suorittimen välimuistin vaatimusten
kanssa. Hyödynnän kuitenkin asymptoottisen analyysin kaltaista
menetelmää ekstrapoloidessani JNI-operaatioiden käyttäytymistä
vaihtelevilla syöteparametreilla.
# todo lähde


# Tutkielmassa
# hyödynnetään rajatusti simulaatiota siinä mielessä, että
# Android-kehitystyökalujen /Android-emulaattori/ simuloi todellista
# Android-laitetta ARM-käskyjen tasolla [fn:emulator]. Emulaattoria
# hyödynnetään joidenkin mittaustulosten osalta.
#todo: lähde
# [fn:emulator] Emulaattori-käsitteen syntyaikana @@emu puhtaan
# ohjelmallisesti toteutettua vieraan suoritusympäristön täydellistä
# toisinnosta kutsuttiin simulaattoriksi. Emulaattori perustui
# laitteistotukeen. Android-emulaattori on esimerkki nykykäytöstä, jossa
# ohjelmallistakin toisintamista usein kutsutaan emuloinniksi.

# TODO: uncomment? v 
#Myös simulaatiomalleja hyödynnetään rajatusti, sillä
#Android-ohjelmia suoritetaan 

Tutkielman hypoteesi on, että Java- ja C-kieliä yhdistävän sovelluksen
erilaiset arkkitehtuuriratkaisut johtavat erilaisiin suoritusaikoihin,
vaikka sovellukset suorittaisivat saman tehtävän.  Tutkielma rajataan
sovelluksiin, joiden suoritusaikaa määrittää oleellisesti sovelluksen
prosessointi keskusyksikössä sekä keskusmuistihaut, eivät esimerkiksi
I/O-operaatiot @@ferrari(168). Tällöin analyysin kohteeksi tuleekin,
/mihin/ Android-sovellus kuluttaa suoritusaikansa.  Tätä mallinnetaan
Markov-ketjuilla.
# todo tarkista että em. pitää paikkansa lopulta

** Vasteaikojen mallintaminen Markov-ketjuilla

Hyödynnän Beizerin (1970) esittelemää yksinkertaista Markov-mallia
jolla ohjelman kokonaisvasteajan saa laskettua sen osien
suoritusajoista @@beizer,ferrari. Mallinnustavan etuna on
yksinkertaisuuden lisäksi se, että mittaustuloksina saatavat
vasteaikojen jakautumat voi yksinkertaisesti kytkeä mallin osaksi.

Mallissa ohjelma jaetaan suoritustiloihin halutulla karkeusasteella --
tutkielmassa jako noudattaa lähinnä profilointityökaluissa esiintyvien
aliohjelmien rajoja, yhdistellen tarvittaessa aliohjelmia suuremmiksi
"moduuleiksi". Malli on /verkko/, jonka /solmut/ vastaavat hetkellisiä
diskreettejä suoritustiloja, ja solmujen väliset /kaaret/ vastaavat
siirtymiä tilasta toiseen ja myös laskentaa joka siirtymässä
tapahtuu. Yhdestä tilasta voi lähteä useampi kaari, ja kaariin
kytketyt todennäköisyydet ilmaisevat todennäköisyyttä että kyseinen
siirtymä tapahtuu.

# todo tähän kuva

Mallinnustavan erikoisuutena laskenta ei sijoitu solmuihin vaan
kaariin, joilla on todennäköisyyden lisäksi keskimääräinen
suoritusaika sekä suoritusajan varianssi (jotka vastaavat
mittauksia). Muutoin kyseessä on perinteinen Markov-malli, joka on
/historiaton/: /Markov-oletuksen/ mukaisesti eri siirtymien
todennäköisyydet riippuvat ainoastaan kulloisestakin tilasta eikä
prosessin aikaisemmista tiloista. Oletus on tietenkin epärealistinen,
mutta stokastisten prosessien hyöty piileekin siinä, että abstraktikin
malli voi tiettyyn rajaan asti ennustaa todellisuuden monimutkaisiakin
prosesseja. Kuten mittauksetkin, mallin arvot ovat vahvasti
riippuvaisia ohjelmiston itsensä lisäksi sille annetuista syötteistä;
lähestymistapana tässä tutkielmassa on parametrisoida mallin
vasteaika-arvot JNI-rajapintaan kohdistuvien työkuormien suhteen.

Ohjelmiston kokonaisvasteaika ratkaistaan Beizerin mallinnustavassa
algortimilla, joka eliminoi verkosta yhden solmun
kerrallaan. Algoritmissa on eri yhtälöt /sarjaan/ ja /rinnan/
kytkettyjen solmujen sekä /silmukoiden/ poistoon.

1. Valitaan poistettava solmu.
2. Poistetaan solmu käyttämällä /sarjaan/ kytkettyjen solmujen
   poistomenetelmää. Kaarien määrä lisääntyy.
3. Yhdistetään /rinnakkaiset/ kaaret.
4. Poistetaan /silmukat/.
5. Palataan kohtaan 1.

# todo kuvat

Jokaisessa solmun tai kaaren poisto-operaatiossa malli
yksinkertaistuu, ja tuloksena syntyvien kaarien arvot lasketaan vanhan
osamallin arvoista, kunnes mallissa on ainoastaan yksi solmu. Siitä
nähdään ohjelman kokonaisvasteaika, joka saattaa vaihdella jos
ohjelman suoritus käynnistyy eri kohdista tai loppuu eri kohtiin. Jos
käytetty malli on tarpeeksi totuudenmukainen, saadaan yksinkertaiselle
yhden käyttäjän ohjelmalle arvioitua keskimääräinen suoritusaika
varianssineen jo ennen ohjelman laatimista.

# todo here...

* Tehtäviä                                                         :noexport:
** TODO [#A] mainitse tilavaativuus
** DONE [#B] käsittele lyhyesti (max 2 kpl) O-algoritmianalyysi?
** TODO CPU time vs. other time: viittaa mittausten yhteydessäa
** TODO ferrari luku 5.2.3 objektiivisuus?? mikä tämä oli
** TODO mahdollista profilointi-sanan käyttö nykykäytön mukaisesti
** TODO mainitse renderscript
** TODO oikeastaan mittausten avulla mallinnetaan aika lailla /työkuormaa/
** Aliluvut
*** Työkuorman mallintaminen                                       :noexport:
    tämä on vähän hankalampi, katotaan myöhemmin


